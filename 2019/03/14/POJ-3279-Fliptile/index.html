


<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>POJ 3279 Fliptile [ 市井烟火气 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
</head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img class="avatar" src="/images/default-avatar.jpg" alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					fireworks99
				</div>
				<div id="top-bar-slogan">
					keep hungry keep foolish
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id="details-post-item">
			<h1>POJ 3279 Fliptile</h1>
			<h2 id="关于翻转问题"><a href="#关于翻转问题" class="headerlink" title="关于翻转问题"></a>关于翻转问题</h2><blockquote>
<p>例:给定一个01串，现有翻转规则：</p>
<p>翻转某一个位置时其后面2个位置也会跟着翻转，也就是每次翻转都会翻转3个连续的位置。要将01串全部翻转为0，求最小的翻转次数</p>
<p>形似这类题的问题叫做翻转问题，也可以叫开关问题</p>
</blockquote>
<a id="more"></a>
<p><strong>原文出处</strong> <a href="https://blog.csdn.net/ac_hell/article/details/51077320" target="_blank" rel="noopener">https://blog.csdn.net/ac_hell/article/details/51077320</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote>
<p>①.若某一个位置被翻转了n次，则其实际上被翻转了n%2次，因为翻转2k次相当与没翻转，翻转2k+1次相当于翻转了1次，因为要求最小翻转次数，所以对于某一个位置要么只（主动）翻转一次，要么不（主动）翻转。</p>
<p>②.分析易知翻转的顺序并不影响最终结果。（理解不了可自己举个例子在纸上模拟下）</p>
<p>③.现在我们着眼于第1个位置，可知若要将第1个位置进行翻转只有翻转它自己，因为没有其他位置的翻转会引起它的翻转。由①可知若第1个位置为1则必须且进行翻转（并将其后2个进行连带翻转）且以后不再进行翻转，因为再进行翻转就一共翻转了2次相当于没翻转。然后着眼于第2个位置，由于第1个位置不再进行翻转，所以要想翻转第2个位置只有翻转它自己，因为没有其他位置的翻转会引起它的翻转…………………以此类推直至最后剩下的个数＜3个，因为每次都翻转3个，而剩下的少于3个了就不再进行考虑了，此时只需判断剩下的是否全为0的即可，若不全为0，则不存在全部翻转为0的方案</p>
</blockquote>
<h2 id="POJ-3279"><a href="#POJ-3279" class="headerlink" title="POJ 3279"></a>POJ 3279</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an <em>M</em> × <em>N</em> grid (1 ≤ <em>M</em> ≤ 15; 1 ≤ <em>N</em> ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p>
<p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p>
<p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.</p>
</blockquote>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em>  Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes the colors (left to right) of row i of the grid with <em>N</em> space-separated integers which are 1 for black and 0 for white </p>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>Lines 1..<em>M</em>: Each line contains <em>N</em> space-separated integers, each specifying how many times to flip that particular location. </p>
</blockquote>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>4 4</p>
<p>1 0 0 1</p>
<p>0 1 1 0</p>
<p>0 1 1 0</p>
<p>1 0 0 1</p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>0 0 0 0</p>
<p>1 0 0 1</p>
<p>1 0 0 1</p>
<p>0 0 0 0</p>
</blockquote>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>1代表黑色格子，0代表白色格子，目标是把黑色全翻转为白色</p>
<p>但翻转任意一个格子，与他相邻的格子都会被翻转</p>
<p>求解最小翻转方案</p>
</blockquote>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

const int inf = 0x3f3f3f3f;

bool a[20][20];
///a[i][j]若为1表示坐标为(i, j)的格子是黑色的，0表示白色
bool b[20][20];
///b[i][j]若为1表示(在当前方案中)坐标为(i, j)的格子作出翻转，0表示不转
bool ans[20][20];

int dx[] = {-1, 1, 0, 0, 0};
int dy[] = {0, 0, 0, -1, 1};
int n, m;
int step_min = inf;

///a[i][j]与b[i][j]都不代表翻转后(i, j)格子的颜色，可以用以下color函数找
bool color(int x, int y)
{
    int flag = a[x][y];
    ///它现在的颜色受其上下左右中是否翻转的影响
    for(int i = 0; i &lt; 5; ++i)
    {
        int xx = x + dx[i];
        int yy = y + dy[i];
        if(xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m)
            flag += b[xx][yy];
    }
    return flag &amp; 1;
}

int slove()
{
    int sum = 0;
    for(int i = 2; i &lt;= n; ++i)///从第二行起检测是否需要反转
        for(int j = 1; j &lt;= m; ++j)
            if(color(i - 1, j))///如果它上面是黑色，那么这格需要反转
                b[i][j] = 1;

    ///检测最后一行是否全白
    for(int i = 1; i &lt;= m; ++i)
        if(color(n, i))
            return inf;

    ///计算总翻转次数
    for(int i = 1; i &lt;= n; ++i)
        for(int j = 1; j &lt;= m; ++j)
            sum += b[i][j];
    return sum;
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; ++i)///涉及坐标问题，下标从1开始
        for(int j = 1; j &lt;= m; ++j)
            cin &gt;&gt; a[i][j];

    ///（按照字典序）枚举第一行所有的翻转方案
    for(int num = 0; num &lt; (1 &lt;&lt; m); ++num)
    {
        memset(b, 0, sizeof(b));
        for(int i = 1; i &lt;= m; ++i)
            b[1][i] = num &gt;&gt; (m - i) &amp; 1;

        int tem = slove();
        if(tem &lt; step_min)
        {
            step_min = tem;
            memcpy(ans, b, sizeof(b));
        }
    }
    if(step_min == inf)
        cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; &#39;\n&#39;;
    else
    {
        for(int i = 1; i &lt;= n; ++i)
            for(int j = 1; j &lt;= m; ++j)
                printf(&quot;%d%c&quot;, ans[i][j], j == m ? &#39;\n&#39;: &#39; &#39; );
    }
    return 0;
}
</code></pre>
<h3 id="部分代码解释"><a href="#部分代码解释" class="headerlink" title="部分代码解释"></a>部分代码解释</h3><pre><code class="lang-c++">///（按照字典序）枚举第一行所有的翻转方案
for(int num = 0; num &lt; (1 &lt;&lt; m); ++num)
</code></pre>
<p>这就相当于一个集合有m个元素，则有 （2 ^ m）个子集。</p>
<p>对应着，第一行有m个元素，有（2 ^ m）种翻转方案</p>
<pre><code class="lang-c++">for(int i = 1; i &lt;= m; ++i)
            b[1][i] = num &gt;&gt; (m - i) &amp; 1;
</code></pre>
<p>这是按照字典序枚举了第一行的所有翻转方案，效果如下</p>
<pre><code class="lang-c++">0 0 0 0
0 0 0 1
0 0 1 0
0 0 1 1
0 1 0 0
0 1 0 1
0 1 1 0
0 1 1 1
1 0 0 0
1 0 0 1
1 0 1 0
1 0 1 1
1 1 0 0
1 1 0 1
1 1 1 0
1 1 1 1
</code></pre>

		</div>

		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjIyNC8yMjczNQ==">
	<script type="text/javascript">
   (function(d, s) {
       var j, e = d.getElementsByTagName(s)[0];

       if (typeof LivereTower === 'function') { return; }

       j = d.createElement(s);
       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
       j.async = true;

       e.parentNode.insertBefore(j, e);
   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->


			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by Baole Zhao | 
				Powered by <a href="http://hexo.io">Hexo</a> |
				theme <a href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
