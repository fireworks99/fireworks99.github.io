


<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>POJ 2528 Mayor&#39;s posters [ 市井烟火气 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
</head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img class="avatar" src="/images/avatar.png" alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					fireworks99
				</div>
				<div id="top-bar-slogan">
					keep hungry keep foolish
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				
<div id="details">
	
	<article id="details-post">
		<div id="details-post-item">
			<h1>POJ 2528 Mayor&#39;s posters</h1>
			<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:  </p>
</blockquote>
<a id="more"></a>
<p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener">http://poj.org/problem?id=2528</a></p>
<ul>
<li>Every candidate can place exactly one poster on the wall. </li>
<li>All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown). </li>
<li>The wall is divided into segments and the width of each segment is one byte. </li>
<li>Each poster must completely cover a contiguous number of wall segments.</li>
</ul>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote>
<p>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri. </p>
</blockquote>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote>
<p>For each input data set print the number of visible posters after all the posters are placed.   The picture below illustrates the case of the sample input.   </p>
</blockquote>
<p><img src="http://poj.org/images/2528_1.jpg" alt="样例"></p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
<p>1</p>
<p>5</p>
<p>1 4</p>
<p>2 6</p>
<p>8 10</p>
<p>3 4</p>
<p>7 10</p>
</blockquote>
<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
<p>4</p>
</blockquote>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote>
<p>一面墙很长，贴海报于上。海报互遮挡，可见有几张？</p>
</blockquote>
<p><del>被敲代码耽误的诗人</del></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote>
<p>离散化、线段树，赋给每个海报区间一个数字，最后找有几个不同的数字。”海报被覆盖“在代码中体现为“对应区间被赋予新值”，那就有个数字被覆盖了，意味着最终可数的数字减少</p>
</blockquote>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p>简单的离散化可能会出现错误，给出下面两个简单的例子应该能体现普通离散化的缺陷:</p>
<p>例子一:1-10 1-4 5-10</p>
<p>例子二:1-10 1-4 6-10</p>
<p>普通离散化后都变成了[1,4][1,2][3,4]</p>
<p>线段2覆盖了[1,2],线段3覆盖了[3,4],那么线段1是否被完全覆盖掉了呢?</p>
<p>例子一是完全被覆盖掉了,而例子二没有被覆盖</p>
<p>解决的办法则是对于距离大于1的两相邻点，中间再插入一个点，本题还用到了Lazy标记的思想</p>
<p>直接更新区间进行标记而先不对子节点进行处理，如果需要往下更新再将标记下传一层。</p>
</blockquote>
<p><strong>原文出处</strong> <a href="https://www.cnblogs.com/xuejianye/p/5694750.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuejianye/p/5694750.html</a></p>
<h3 id="Code-of-improved-离散化"><a href="#Code-of-improved-离散化" class="headerlink" title="Code of improved 离散化"></a>Code of improved 离散化</h3><pre><code class="lang-c++">        ///改良版离散化
        sort(tem, tem + tot);
        ///m代表多少种数字；unique函数使得容器前m个数字不重复，
        ///而后面的数字保持为原来的值
        m = unique(tem, tem + tot) - tem;
        int temporary = m;
        for(int i = 0; i &lt; temporary - 1; ++i)
            if(tem[i + 1] - tem[i] &gt; 1)
                tem[m++] = tem[i] + 1;
        sort(tem, tem + m);///离散化后的值&gt;=tem[0]
</code></pre>
<h3 id="单点更新与区间更新"><a href="#单点更新与区间更新" class="headerlink" title="单点更新与区间更新"></a>单点更新与区间更新</h3><blockquote>
<p>区间更新涉及数据向下传递问题</p>
</blockquote>
<pre><code class="lang-c++">void down(int x)///数据下传
{
    if(a[x].val != -1)
    {
        a[x &lt;&lt; 1].val = a[x].val;
        a[x &lt;&lt; 1 | 1].val = a[x].val;
        a[x].val = -1;
    }
}
</code></pre>
<h3 id="Code-of-this-problem-2019-3-2"><a href="#Code-of-this-problem-2019-3-2" class="headerlink" title="Code of this problem(2019/3/2)"></a>Code of this problem(2019/3/2)</h3><pre><code class="lang-c++">#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100005;

struct node
{
    int L, R;
    int val;
} a[N &lt;&lt; 2];

int m, ans;
int b[N];
int c[N];
int tem[N &lt;&lt; 1];
bool vis[N &lt;&lt; 1];

void down(int x)///数据下传
{
    if(a[x].val != -1)
    {
        a[x &lt;&lt; 1].val = a[x].val;
        a[x &lt;&lt; 1 | 1].val = a[x].val;
        a[x].val = -1;
    }
}

void init(int num, int l, int r)
{
    a[num].L = l;
    a[num].R = r;
    a[num].val = -1;///数字从0开始传的缘故

    if(l == r)
        return ;

    int mid = (l + r) &gt;&gt; 1;
    init(num &lt;&lt; 1, l, mid);
    init(num &lt;&lt; 1 | 1, mid + 1, r);
}

///针对不同的题目，更新函数必有所修改
void update(int num, int l, int r, int t)
{
    if(a[num].L == l &amp;&amp; a[num].R == r)
    {
        a[num].val = t;
        return ;
    }

    if(a[num].L == a[num].R)
        return ;

    down(num);///此节点非目标节点，数据下传

    int mid = (a[num].L + a[num].R) &gt;&gt; 1;
    if(mid &gt;= r)
        update(num &lt;&lt; 1, l, r, t);
    else if(mid &lt; l)
        update(num &lt;&lt; 1 | 1, l, r, t);
    else
    {
        update(num &lt;&lt; 1, l, mid, t);
        update(num &lt;&lt; 1 | 1, mid + 1, r, t);
    }
}

void slove(int num, int l, int r)
{
//    cout &lt;&lt; num &lt;&lt; &#39; &#39; &lt;&lt; a[num].L &lt;&lt; &quot; &quot; &lt;&lt; a[num].R &lt;&lt; &#39; &#39; &lt;&lt; a[num].val &lt;&lt; &#39; &#39; &lt;&lt; vis[ a[num].val ] &lt;&lt; &#39;\n&#39;;
    if(a[num].val != -1 &amp;&amp; !vis[ a[num].val ])
    {
        vis[ a[num].val ] = 1;
        ans++;
    }
    if(a[num].L == a[num].R)///到底了,返回
        return ;
    down(num);
    int mid = (a[num].L + a[num].R) &gt;&gt; 1;
    slove(num &lt;&lt; 1, l, mid);
    slove(num &lt;&lt; 1 | 1, mid + 1, r);
}

int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        memset(b, 0, sizeof(b));
        memset(c, 0, sizeof(c));
        memset(tem, 0, sizeof(tem));
        memset(vis, 0, sizeof(vis));
        int n;
        cin &gt;&gt; n;
        int tot = 0;
        for(int i = 0; i &lt; n; ++i)
        {
            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);
            tem[tot++] = b[i];
            tem[tot++] = c[i];
        }

        ///改良版离散化
        sort(tem, tem + tot);
        m = unique(tem, tem + tot) - tem;
        int temporary = m;
        for(int i = 0; i &lt; temporary - 1; ++i)
            if(tem[i + 1] - tem[i] &gt; 1)
                tem[m++] = tem[i] + 1;
        sort(tem, tem + m);

        init(1, 1, m);
        for(int i = 0; i &lt; n; ++i)///数字是从0开始传
        {
            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;
            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;
            update(1, tl, tr, i);
        }
        ans = 0;
        slove(1, 1, m + 1);
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
    return 0;
}
</code></pre>
<h3 id="第二次做（2019-4-15）"><a href="#第二次做（2019-4-15）" class="headerlink" title="第二次做（2019/4/15）"></a>第二次做（2019/4/15）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100005;

struct node
{
    int L, R, val;
}a[N &lt;&lt; 2 | 1];

int ans, b[N], c[N], tem[N &lt;&lt; 1];
bool vis[N &lt;&lt; 1];

void down(int x)
{
    if(a[x].val != -1)///0被占用
    {
        a[x &lt;&lt; 1].val = a[x].val;
        a[x &lt;&lt; 1 | 1].val = a[x].val;
        a[x].val = -1;
    }
}

void init(int num, int l, int r)
{
    a[num].L = l;
    a[num].R = r;
    a[num].val = -1;///数字从0开始传的缘故

    if(l == r)
        return ;

    int mid = (l + r) &gt;&gt; 1;
    init(num &lt;&lt; 1, l, mid);
    init(num &lt;&lt; 1 | 1, mid + 1, r);
}

void update(int num, int l, int r, int t)
{
    if(a[num].L &gt; r || a[num].R &lt; l)
        return ;
    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)
    {
        a[num].val = t;
        return ;
    }
    if(a[num].L == a[num].R)
        return ;
    down(num);
    update(num &lt;&lt; 1, l, r, t);
    update(num &lt;&lt; 1 | 1, l, r, t);
}

void slove(int num, int l, int r)///区间[l,r]内有多少种数字
{
    if(a[num].val != -1 &amp;&amp; !vis[ a[num].val ])
    {
        vis[ a[num].val ] = 1;
        ans++;///为了遍历到底，这里没有 return
    }
    if(a[num].L == a[num].R)///到底了,返回
        return ;
    down(num);
    int mid = (a[num].L + a[num].R) &gt;&gt; 1;
    slove(num &lt;&lt; 1, l, mid);
    slove(num &lt;&lt; 1 | 1, mid + 1, r);
}

int main()
{
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        memset(b, 0, sizeof(b));
        memset(c, 0, sizeof(c));
        memset(tem, 0, sizeof(tem));
        memset(vis, 0, sizeof(vis));
        int n;
        scanf(&quot;%d&quot;, &amp;n);
        int tot = 0;
        for(int i = 0; i &lt; n; ++i)
        {
            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);
            tem[tot++] = b[i];
            tem[tot++] = c[i];
        }

        sort(tem, tem + tot);
        ///m代表多少种数字，函数把重复的数字后放
        int m = unique(tem, tem + tot) - tem;
        int tempory = m;
        for(int i = 0; i + 1 &lt; tempory; ++i)
            if(tem[i + 1] - tem[i] &gt; 1)
                tem[m++] = tem[i] + 1;
        sort(tem, tem + m);///离散化后的值&gt;=tem[0]

        init(1, 1, m);
        for(int i = 0; i &lt; n; ++i)
        {   /// + 1 是因为线段树的左界是从1开始的
            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;
            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;
            update(1, tl, tr, i);///区间赋值为i
        }
        ans = 0;
        slove(1, 1, m);
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
    return 0;
}
</code></pre>

		</div>

		<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC80NjIyNC8yMjczNQ==">
	<script type="text/javascript">
	   (function(d, s) {
	       var j, e = d.getElementsByTagName(s)[0];

	       if (typeof LivereTower === 'function') { return; }

	       j = d.createElement(s);
	       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
	       j.async = true;

	       e.parentNode.insertBefore(j, e);
	       
	       
	   })(document, 'script');
	</script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->
		
	</article>

	<div id="toc">
		
	</div>

</div>

<!-- <div id="paginator"> -->
<!-- 	 -->
<!-- </div> -->




			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by Baole Zhao | 
				Powered by <a href="http://hexo.io">Hexo</a> |
				theme <a href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
