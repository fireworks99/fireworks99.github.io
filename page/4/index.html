


<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>求知若渴，虚心若愚 [ 市井烟火气 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
</head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img class="avatar" src="/images/default-avatar.jpg" alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					fireworks99
				</div>
				<div id="top-bar-slogan">
					keep hungry keep foolish
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2020/09/19/Web-FrontEnd-Vue-pass-info-to-BackEnd-Nodejs/" class="item-title">FrontEnd Vue pass info to BackEnd Nodejs</a>
      
      <time datetime="2020-09-19T13:39:16.000Z">
        2020-09-19
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- &lt;input type=&quot;text&quot;
                     name=&quot;usernm&quot;
                     required=&quot;required&quot;
                     class=&quot;border-item&quot;
                     placeholder=&quot;username&quot;
                     value=&quot;&quot;
                     v-model=&quot;username&quot;&gt;
&lt;input type=&quot;password&quot;
                     name=&quot;passwd&quot;
                     required=&quot;required&quot;
                     class=&quot;border-i -->
        <!-- </div> -->

        
        <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>前端用Vue框架写一个“注册”页面，需要传递一些注册信息到后端Nodejs，以便写入MySQL完成注册。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/09/19/Web-FrontEnd-Vue-pass-info-to-BackEnd-Nodejs/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/27/HDU-2819-Swap-Bipartite-graph-match/" class="item-title">HDU 2819 Swap(Bipartite graph match)</a>
      
      <time datetime="2020-04-27T03:28:55.000Z">
        2020-04-27
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
刚开始想的时候，不明白怎么换，想着什么情况下既要换行又要换列，是那种情况的话该怎么换？越想越复杂。看了题解：
若可以，只换行可行，只换列也可行
二分图最大匹配等于n则可以
DFS(int x)时 link[i] = x；是标记列i被分配给x，是列被标记了！

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 110;

int n, mp[N][N], link[N];

bool vis[N];
bool DFS(int x)
{
    for(int i = 1; i &lt;= n; ++i)
        if(mp[x][i] &amp;&amp; !vis[i])
        {
            vis[i] = 1;
            if(link[i] == -1 || DFS(link[i]))
   -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给出N * N的01矩阵，能否交换行列使得最终主对角线上全为1，不能的话输出-1，能的话输出方案.</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/27/HDU-2819-Swap-Bipartite-graph-match/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/27/HDU-1281-Chessboard-game-Bipartite-graph-match/" class="item-title">HDU 1281 Chessboard game(Bipartite graph match)</a>
      
      <time datetime="2020-04-27T02:05:22.000Z">
        2020-04-27
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
同HDU 1045 Fire Net类似，解法思想(二分图匹配)也相同

方案一 较为暴力
求完最大匹配后，将每条匹配的边撤掉再求一遍最大匹配，看是否减少，若减少则该边对应点是最要点。

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 105;

int n, m, k;
bool vis[N];
int mp[N][N], link[N], t_link[N];

///DFS(int x): link[to] = x not link[x] = to

bool DFS(int x)
{
    for(int i = 1; i &lt;= n; ++i)
        if(mp[x][i] &amp;&amp; !vis[i])
        {
            vis[i] = 1;
            if(li -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N行M列的棋盘，空白地区放棋子“車”，使彼此不能攻击到，非空白地区不影响彼此的攻击(不是“墙”)，求在放最多“車”的前提下，有几个点是“重要点”（棋子不放在这里就会减少可放棋子数）？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/27/HDU-1281-Chessboard-game-Bipartite-graph-match/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/26/HDU-2444-The-Accomodation-of-Students-Bipartite-graph/" class="item-title">HDU 2444 The Accomodation of Students(Bipartite graph color)</a>
      
      <time datetime="2020-04-26T04:10:45.000Z">
        2020-04-26
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
1.判断是否是二分图（染色法）
2.二分图最大匹配

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 20005;
const int M = 20005;

int n, m, color[N];;

int head[N], cnt;
struct edge
{
    int v, pre;
} e[M];

void add(int u, int v)
{
    e[cnt].v = v;
    e[cnt].pre = head[u];
    head[u] = cnt++;
}

bool succeed(int x)
{
    for(int i = head[x]; ~i; i = e[i].pre)
    {
        int to = e[i].v;
        if(color[to] == -1) -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个人M个相识关系，问：能否将所有人分成两拨，每一拨中的人彼此互不相识。若能，分成两拨后，能从彼此中挑出多少对相识的？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/26/HDU-2444-The-Accomodation-of-Students-Bipartite-graph/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/26/HDU-1045-Fire-Net-DFS-or-bipartite-graph-match/" class="item-title">HDU 1045 Fire Net(DFS or bipartite graph match)</a>
      
      <time datetime="2020-04-26T03:11:09.000Z">
        2020-04-26
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
可以简单のDFS
另外的二分图匹配：
假设没有墙壁，为每行、每列标号，针对每个点进行建边，求最大匹配





1
1
1
1




2
2
2
2


3
3
3
3


4
4
4
4








1
2
3
4




1
2
3
4


1
2
3
4


1
2
3
4





建边add(1, 1)add(1, 2)add(1, 3)add(1,4)add(2,1)……
在求最大匹配时，假设第一个表中的2匹配了第二个表中的3，那么相当于在第二行第三列建一座炮台，由于本行都是2，且2已经被分配，所以本行不会再被分配炮台；同理，本列都是3，且3已经被分配，所以本列不会再被分配炮台。如此限制了同行或同列不会出现两座炮台。
现在有墙，标号便可增加了，比如样例

4
.X..
....
XX..
....





1
X
2
2




3
3
3
3


X
X
4
4


5
5
5
5








1
X
5
6




1
3
5
6


X
X
5
6


2
4
5
6




Code#include &lt;cstdio&gt;
#inc -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给出一个地图，有空地，有墙，在空地上安排炮台，炮台会向四方攻击，但不会穿透墙壁，要避免炮台彼此攻击到，求最多能安排多少炮台？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/26/HDU-1045-Fire-Net-DFS-or-bipartite-graph-match/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/25/HDU-4685-Prince-and-Princess-bipartite-graph-match-and-shrink-nodes/" class="item-title">HDU 4685 Prince and Princess(bipartite graph match and shrink nodes)</a>
      
      <time datetime="2020-04-25T13:44:47.000Z">
        2020-04-25
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
为了保证最大匹配数，先对王子进行最大匹配(二分图匹配の匈牙利算法DFS)。
在最大匹配前提下，再找各王子除了匹配到的公主外还可以匹配哪些公主
遍历王子，对于没匹配公主的每个王子：
设置一个虚点(公主)与之匹配，并让所有王子指向这一虚点



遍历公主，对于没匹配王子的每个公主：
设置一个虚点(王子)与之匹配，并让这一虚点指向所有公主



针对参与匹配的所有公主(最大匹配中的+虚点中的)，建立反向边
强连通分量缩点，处在同一个强连通分量中的王子与公主，可以彼此匹配
A遍历王子，love[A][B]==1用来排除B是王子(保证B是公主)

Code#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 2005;
const int M = 2 * N * N;
c -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个王子M个公主，王子只能匹配自己喜欢的公主，公主随意。给出王子对于公主的喜爱信息，求在保证最大配对数的前提下，每个王子分别可以匹配哪些公主。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/25/HDU-4685-Prince-and-Princess-bipartite-graph-match-and-shrink-nodes/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/25/HDU-4635-Strongly-connected-shrink-nodes/" class="item-title">HDU 4635 Strongly connected(shrink nodes)</a>
      
      <time datetime="2020-04-25T03:57:16.000Z">
        2020-04-25
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
1.现在有N个点，0条边，可添加 N * (N - 1) 条边(保证是简单图)
2.为了保证非强连通，需要去掉一些边。最终的图环缩点后是两个大点。假设第一个大点中含有X个小点，那第二个大点中就含有(N - X)个小点，那原先他们之间的2 * X*(N-X)条边就要去掉一半，即答案是N(N - 1) - X(N - X)
3.由于原图已有M条边，所以最终答案是N(N - 1) - M - X(N - X)
4.那么X(N - X)在什么情况下最小呢？当二次函数处理时发现X越近0或越近N时最小，即最后的两个大点所含的小点数目之差越大越优。
5.假设原图缩点后各大点所含小点数为：2，4，8，16。那么将2做一强连通分量，剩下的4+8+16做另一强连通分量时，答案最优。所以要找缩点后内部含点数最少的强连通分量，其内部点数为X。
6.有个前提：这个强联通分量的入度或出度为0(才可以成为最后两个点之一)

Code#include &lt;stack&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;c -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给出一个含有N个点M条有向边的简单图(无自环无重边)，求：在保证图是简单图且非强连通的前提下，最多可以再添加几条边？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/25/HDU-4635-Strongly-connected-shrink-nodes/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/24/HDU-4612-Warm-up-Bridges-Diameter-of-tree/" class="item-title">HDU 4612 Warm up(Bridges + Diameter of tree)</a>
      
      <time datetime="2020-04-24T05:35:38.000Z">
        2020-04-24
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
本来想当成POJ 3694 处理，桥的数目 - (距离LCA和最大的两个叶子节点到LCA的距离和)，但两层循环求到LCA距离和会TLE！
学到了：树的直径dist[ BFS( BFS(1) ) ]
第一次BFS返回一个叶子节点

Code#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 200005;
const int M = 4200005;

int n, m, Q;
int cnt, tot, idx, id[N], h1[N], h2[N], low[N], times[N], num_bridges;

bool bridge[M];
struct edge
{
    int u, v, pre;
} e[M];

void init()
{
    cnt = tot = idx = nu -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个点M条无向边(可含重边)，再添加一条边，最后的桥最少有多少？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/24/HDU-4612-Warm-up-Bridges-Diameter-of-tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/24/POJ-3177-Redundant-Paths-shrink-nodes-and-bridges/" class="item-title">POJ 3177 Redundant Paths(shrink nodes and bridges)</a>
      
      <time datetime="2020-04-24T03:56:37.000Z">
        2020-04-24
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analzye
先进行环缩点，缩点完后是一棵树。
连接任意两个节点，皆可成环。
然而连接叶子节点比连接非叶子节点更优(需添加的边较少)。
而且要连接的这两个叶子节点，其到LCA的距离越大越优。
因为：连接树(缩点后的图)中某两个距离LCA最大的叶子节点，形成的环再次缩点会缩到根节点里，这样就减少了两个点。若非如此，每次只减少一个点。
答案：假设有ans个叶子节点，每添一条边减少两个点，需要添加ans / 2条边。若ans为奇数，需要(ans + 1) / 2条边。两者可合并成后者。
如何求缩点后叶子节点的个数ans？
叶子节点特征：度数为1
方案：求桥，原图的桥是缩点后的树上的边。遍历原图每个点，对每个点遍历出边，若此出边为桥，则它所连接的两点所在的连通分量(缩点后的点)度数++。最后遍历每个缩点后的点，度数为1的是叶子节点。

Code#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#inc -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个点M条无向边，原图是连通的，现要添加一些边，使得每两点之间的路至少有两条。求最少连接几条边。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/24/POJ-3177-Redundant-Paths-shrink-nodes-and-bridges/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/04/08/POJ-3694-Network-Bridges-and-LCA/" class="item-title">POJ 3694 Network(Bridges and LCA)</a>
      
      <time datetime="2020-04-08T13:42:32.000Z">
        2020-04-08
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
1.将图进行正宗缩点（新点+新边的那种）形成树
2.这棵树的每条边都是桥，在点u点v间添一条边(若u、v不在同一个连通分量中，即没缩成同一点，此举必成环），后来的桥的数目等于原来桥的数目减掉新图里这个环中(不算边u,v)边的数目。而这个数目等于u、v(对应缩点)到他们最近公共祖先LCA的距离和！这个思想绝了！原本在一般图中，要找这样一个环的边数，怕是要循环或者递归啥的，可偏偏这是在一棵树里！它有这样的特点。
具体步骤：
1.Tarjan对原图求桥
2.在有桥的前提下DFS正经缩点(学到了!)
3.根据缩点建新图(添新边以连接新缩点)
4.BFS求新点的深度(层)，为求某两点距离其LCA的距离做准备
5.利用个点深度求两点距离各自LCA的距离
最后添边在LCA函数里一边查询距离，一边更新(桥变非桥)

Something
关于正宗缩点：
1.朱刘算法求最小树形图的时候，缩点并不是很正宗，点处理的很好，但是边还是用的之前的边，没添一条没删一条。当然这是算法必须具备的特点，正经缩点还不适合它的情境、它的需求。
2.并查集缩点就更不正宗了……
关于处理重边的问题：
为了不走反向 -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给出可能含有重边的无向图，求桥的初始数目。Q次添边，每次输出添边后桥的数目。题目保证初始时刻图是连通的。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/04/08/POJ-3694-Network-Bridges-and-LCA/"> Read more -->
          </a></span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <a class="extend prev" rel="prev" href="/page/3/"> </a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/5/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
        <a class="friends-list-link" style="display: block;" href="https://fireworks99.github.io/" title="" target="_blank">fireworks99</a>
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome-Extensions/">Chrome Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP----------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPのST算法/">DPのST算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの区间DP/">DPの区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの状压DP/">DPの状压DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの线性DP/">DPの线性DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの背包DP/">DPの背包DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FE-Performance/">FE Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのNote/">JavaScriptのNote</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのPromise/">JavaScriptのPromise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのmysql/">NodeJSのmysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのstatic/">NodeJSのstatic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのupload/">NodeJSのupload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue---------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのPlugin/">VueのPlugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのRenderFunc/">VueのRenderFunc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのaxios/">Vueのaxios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのcomponents/">Vueのcomponents</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのfilters/">Vueのfilters</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのreactivity/">Vueのreactivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのrouter/">Vueのrouter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのv-sth/">Vueのv-sth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-API/">Web API--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-APIのWindow/">Web APIのWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web杂项/">Web杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图のKM算法/">二分图のKM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图の匈牙利算法/">二分图の匈牙利算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化の二分/">优化の二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言/">其他语言--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のHTML/">其他语言のHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のJAVA/">其他语言のJAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のPython/">其他语言のPython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のnext-permutation/">函数のnext_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のprev-permutation/">函数のprev_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-判环/">图论の拓扑排序(判环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-无环/">图论の拓扑排序(无环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の欧拉路/">图论の欧拉路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法/">基本算法--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の贪心/">基本算法の贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の递推/">基本算法の递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のAC自动机/">字符串のAC自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のKMP/">字符串のKMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串の最长回文子串/">字符串の最长回文子串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧/">技巧-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の前缀和/">技巧の前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の博弈/">技巧の博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の哈希/">技巧の哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の尺取法/">技巧の尺取法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の差分/">技巧の差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の异或/">技巧の异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の弹性碰撞/">技巧の弹性碰撞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の归并排序/">技巧の归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の折半枚举/">技巧の折半枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の暴力打表/">技巧の暴力打表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の翻转问题/">技巧の翻转问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の莫队算法/">技巧の莫队算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の输入挂/">技巧の输入挂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据类型のstring/">数据类型のstring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构-------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のDancing-Links/">数据结构のDancing-Links</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmap/">数据结构のmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmultiset/">数据结构のmultiset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のpriority-queue/">数据结构のpriority_queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のset/">数据结构のset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のvector/">数据结构のvector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の主席树/">数据结构の主席树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の单调栈/">数据结构の单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の字典树/">数据结构の字典树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の并查集/">数据结构の并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の最小生成树/">数据结构の最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の栈-stack/">数据结构の栈(stack)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の树状数组/">数据结构の树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の线段树/">数据结构の线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の链式前向星/">数据结构の链式前向星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论のGCD与LCM/">数论のGCD与LCM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の同余定理/">数论の同余定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の大数求余/">数论の大数求余</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の快速幂/">数论の快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の扩展欧几里得/">数论の扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の杂项/">数论の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の欧拉降幂/">数论の欧拉降幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の素数筛/">数论の素数筛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の费马小定理/">数论の费马小定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の高斯消元法/">数论の高斯消元法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のKruskal/">最小生成树のKruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のPrim/">最小生成树のPrim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の树形图/">最小生成树の树形图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の计数/">最小生成树の计数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のBellman-Ford/">最短路のBellman-Ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のDijkstra/">最短路のDijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のFloyd/">最短路のFloyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のspfa/">最短路のspfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/知识/">知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索/">简单搜索---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のA/">简单搜索のA*</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のBFS/">简单搜索のBFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のDFS/">简单搜索のDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索の剪枝/">简单搜索の剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学/">组合数学----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の容斥/">组合数学の容斥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の组合数/">组合数学の组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最大流最小割/">网络流の最大流最小割</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最小费用流/">网络流の最小费用流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何/">计算几何----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何の离散化/">计算几何の离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络の杂项/">计算机网络の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图/">连通图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の2-sat/">连通图の2-sat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图のLCA/">连通图のLCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の割点/">连通图の割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の桥/">连通图の桥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の缩点/">连通图の缩点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题解/">题解</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/03/29/High-order-component/">Vue High order component</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/03/28/Vue-Render-Function/">Vue Render Function</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/03/27/Vue-Plugin/">Vue Plugin</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/03/22/Mini-Data-Observer/">Mini Data Observer</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2022/12/02/JavaScript-Global-Object/">JavaScript Global Object</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <a class="extend prev" rel="prev" href="/page/3/"> </a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/5/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by Baole Zhao | 
				Powered by <a href="http://hexo.io">Hexo</a> |
				theme <a href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
