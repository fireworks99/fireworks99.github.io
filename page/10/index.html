


<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>求知若渴，虚心若愚 [ 市井烟火气 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
</head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img class="avatar" src="/images/default-avatar.jpg" alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					fireworks99
				</div>
				<div id="top-bar-slogan">
					keep hungry keep foolish
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2019/11/24/FZU-1686-神龙的难题-DLX-repeat-cover/" class="item-title">FZU 1686 神龙的难题(DLX repeat cover)</a>
      
      <time datetime="2019-11-24T12:02:26.000Z">
        2019-11-24
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 建模
把每个1视为列，每一种覆盖方式视为行
最少需要拿出多少行，使得每列都含有1——重复覆盖

Code#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int MAX_V = 100005;///数组开小可能超时


int n, m, length, width, res, tot;
int cnt[255];///第i列1元素的个数
int L[MAX_V], R[MAX_V], U[MAX_V], D[MAX_V];
int Head[255];///第i行第一个1元素的ID,意义同列标元素
int Row[MAX_V], Col[MAX_V];///记录id所在行列
int ans[255], mp[20][20];
bool vis[255];

void init()
{
    for(int i = 0; i &lt -->
        <!-- </div> -->

        
        <h3 id="Deacription"><a href="#Deacription" class="headerlink" title="Deacription"></a>Deacription</h3><blockquote>
<p>N x M的01矩阵，给出a、b，表示一次性可以将a行b列的小矩阵内的数字全变成0，问最终使全图为0需要几步</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/24/FZU-1686-神龙的难题-DLX-repeat-cover/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/24/HDU-3948-who-s-your-daddy-DLX-repeat-cover/" class="item-title">HDU 3498 who&#39;s your daddy(DLX repeat cover)</a>
      
      <time datetime="2019-11-24T09:00:46.000Z">
        2019-11-24
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Sample Input5 4

1 2
1 3
2 4
4 5

建模1 1 1 0 0
1 1 0 1 0
1 0 1 0 0
0 1 0 1 1
0 0 0 1 1

问题转换
至少选出多少行,使每列都含有1

Dancing Links X 重复覆盖
①含1最少列，1所在行“们”必然不会被同时选中
②含1最少列 中 任选一行，将该行1元素所在列删除(这个过程会删掉列标元素——这样R[0] == 0可判作准出口，此列这个1却保留了——为了向右继续删)
③删除列是因为这列已经有1了，我以后选行的时候无需参考
④与精确覆盖思路上不同的是：精确覆盖删到只剩Head这个元素算成功，而重复覆盖只是把所有列标元素删掉算找到一个答案(当然它会遍历所有情况，找到最优的)
⑤与精确覆盖实现上不同的是：重复覆盖abandon与resume函数里的参数是id，而精确覆盖形参是列表元素，里面删除内容也不同

Code#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;iostream& -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个数字，M组”相邻”关系</p>
<p>消灭数字，攻击某个数字的时候，它本身以及与它相邻的数字会被消灭，求最少攻击次数</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/24/HDU-3948-who-s-your-daddy-DLX-repeat-cover/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/17/hihocoder-1317-Dancing-Links-X/" class="item-title">hihocoder 1317 (DLX cover precisely)</a>
      
      <time datetime="2019-11-17T10:56:48.000Z">
        2019-11-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Dancing Link X
https://www.cnblogs.com/grenet/p/3145800.html
Dancing Links : 循环双向链，纵横交叉形成的网状结构

Code#include &lt;cstdio&gt;
#include &lt;iostream&gt;
using namespace std;
const int MAX_V = 10010;


int n, m;
int cnt[105];///第i列1元素的个数
int L[MAX_V], R[MAX_V], U[MAX_V], D[MAX_V];
int Head[105];///第i行第一个1元素的ID,意义同列标元素
int Row[MAX_V], Col[MAX_V];///记录id所在行列
int ans[105];


void init()
{
    for(int i = 0; i &lt;= m; ++i)///初始化Head及m个列标元素
    {
        cnt[i] = 0;
        L[i] = i - 1;
        R[i] =  -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>小Ho最近遇到一个难题，他需要破解一个棋局。</p>
<p>棋局分成了n行，m列，每行有若干个棋子。小Ho需要从中选择若干行使得每一列有且恰好只有一个棋子。</p>
<p><a href="http://hihocoder.com/problemset/problem/1317" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1317</a></p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/17/hihocoder-1317-Dancing-Links-X/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/13/POJ-Sudoku-数独-2676-2918-3074-3076/" class="item-title">POJ Sudoku(数独) 2676 2918 3074 3076</a>
      
      <time datetime="2019-11-13T12:34:11.000Z">
        2019-11-13
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
对于2676 和 2918 两题来说，不需要复杂的剪枝，普通DFS即可过

Code#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int ans[12][12];
string s[12];
bool flag;

bool check (int x, int y, int num)
{
    for(int i = 1; i &lt;= 9; ++i)
        if(ans[x][i] == num || ans[i][y] == num)
            return 0;
    int base_x = (x - 1) / 3 * 3;
    int base_y = (y - 1) / 3 * 3;
    int xx = x % 3, yy = y % 3;

    int cx = (x -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>填补数独空白处</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/13/POJ-Sudoku-数独-2676-2918-3074-3076/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/08/HDU-2586-How-far-away-LCA/" class="item-title">HDU 2586 How far away(LCA)</a>
      
      <time datetime="2019-11-08T11:54:12.000Z">
        2019-11-08
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
https://blog.csdn.net/nameofcsdn/article/details/52230548

Code（RMQ~ST离线做法）#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 41000;

int n, m;
int tot;//遍历数
int dis[N];//距离根节点1的距离


struct node
{
    int v, w, pre;
} a[N * 2];
int head[N * 2], cnt = 1;

void add_edge(int u, int v, int w)
{
    a[cnt].v = v;
    a[cnt].w = w;
    a[cnt].pre = head[u];
    head[u] = cnt++;
}


bool -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>n个点，n - 1条边连起来(构成了一棵树)，无更新操作，查询任意两点间距离</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/08/HDU-2586-How-far-away-LCA/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/05/POJ-3683-Paiest-John-s-Busiest-Day-2-sat-Tarjan-Topo/" class="item-title">POJ 3683 Paiest John&#39;s Busiest Day(2-sat:Tarjan+Topo)</a>
      
      <time datetime="2019-11-05T11:32:29.000Z">
        2019-11-05
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 2-sat
①输入+初始化 input() + initial()
②添边 add_edge()
③缩点 Tarjan()
④判可行否 judge()
⑤若可行，记下超点的对立点
⑥反向建边拓扑染色：
遍历所有的点
对于每个点:
若与他相连接的点跟它本身不处于同一个强连通分量中
将两个强连通分量(即两个超点)反向建边
进行BFS拓扑染色

Code#include &lt;stack&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 10005;

struct time
{
    int start, over;
} tm[N];

stack&lt;int&gt; st;
vector&lt;int&gt; v[N];///Trajan用
vector&lt; -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>有一个小镇上只有一个牧师。这个小镇上有一个传说，在九月一日结婚的人会受到爱神的保佑，但是要牧师举办一个仪式。这个仪式要么在婚礼刚刚开始的时候举行，要么举行完婚礼正好结束。<br>现在已知有n场婚礼，告诉你每一场的开始和结束时间，以及举行仪式所需要的时间。问牧师能否参加所有的婚礼，如果能则输出一种方案.</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/05/POJ-3683-Paiest-John-s-Busiest-Day-2-sat-Tarjan-Topo/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/04/POJ-3207-Ikki-s-Story-IV-2-sat/" class="item-title">POJ 3207 Ikki&#39;s Story IV(2-sat)</a>
      
      <time datetime="2019-11-04T12:07:41.000Z">
        2019-11-04
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 2-sat
什么是2-SAT呢？就是
①有一些集合，(对应此题中有一些边)
②每个集合中有且仅有两个元素，(某条边是从圈内连or从圈外连)
③两个元素必须且只能选一个，(从圈内连或者从圈外连，二选一)
④集合间的元素存在一定的选择关系，(边不能相交)
求解可行性及可行方案。

算法过程
1、连边
2、跑Tarjan
3、判可行性，即同一集合中的两个点是否同属一个强连通块
(若不求可行方案，到此步即可)
4、缩点建新图，连反边
5、拓扑序，若当前点没有被访问过，则选择该点，不选择其另外的点

Analyze
对于此题，连线对应区间如果相交，那么两线不能同时在圈内或同时在圈外

Code#include &lt;stack&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

stack&lt;int&gt; st;
vector&lt;int -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个点按顺序排列在一个圆环上，要连接M条边，可从圈内连，可从圈外连，问能否实现各边不相交</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/04/POJ-3207-Ikki-s-Story-IV-2-sat/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/02/POJ-1703-Find-them-Catch-them（并查集变形）/" class="item-title">POJ 1703 Find them, Catch them（并查集变形）</a>
      
      <time datetime="2019-11-02T07:29:03.000Z">
        2019-11-02
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 并查集
初始化一个 2 * N 的并查集，
如果a和b属于不同帮派，
unite(a, b + n) &amp;&amp; unite(b, a + n)
这样如果c和b属于不同帮派
unite(c, b + n) &amp;&amp; unite(b, c + n)
就把a和c连起来了
!!!什么神仙做法！！！
是不是暗示我们，有些题多用点空间就能解决问题

Code#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 100005;

int n, m;
int pre[N * 2];

void init()
{
    for(int i = 0; i &lt;= n * 2; ++i)
        pre[i] = i;
}

int found(int x)
{
    if(pre[x] != x)
   -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>有两个帮派，</p>
<p>给出 D a b 表示a和b位于不同帮派，</p>
<p>给出 A a b 表示询问a和b是否属于同一帮派</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/02/POJ-1703-Find-them-Catch-them（并查集变形）/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/02/POJ-2010-Moo-University-Financial-Aid-贪心-优先队列/" class="item-title">POJ 2010 Moo University Financial Aid(贪心+优先队列)</a>
      
      <time datetime="2019-11-02T05:40:55.000Z">
        2019-11-02
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 贪心
按成绩排序作为基本顺序
处理上部：
选取后 N/2 个学生，将每个申请金额置于一个优先级队列中(由大到小)，并记下总和
从第 C - N / 2 - 1 个位置当做中位数依次往下测试(保证了选取最大的)
处理下部：
在基本顺序的基础上将下部分(要测试的位置以下)按申请金额由小到大排序
取前 N / 2 个的金额总和，记下最后一个位置(即 int last_pos = N / 2 - 1)
检测：
上部金额 + 下部金额 + 当前检测位置金额 &lt;= F 即退出
否则：
①将当前检测位置 idx 并入上部
②让其前一位置 idx - 1 脱离下部
在对idx - 1这个位置检测

Code#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

struct node
{
    int score -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>学校要选出N个人发放助学金，</p>
<p>但有C个人申请（给出C个人的成绩和各自的申请金额），</p>
<p>而且学校只能发放不超过F的金钱，</p>
<p>找出一种策略，使得被发放助学金的学生的群体，</p>
<p>他们的成绩的中位数最大</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/02/POJ-2010-Moo-University-Financial-Aid-贪心-优先队列/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2019/11/02/POJ-3614-Sunscreen-贪心-优先队列/" class="item-title">POJ 3614 Sunscreen(贪心+优先队列)</a>
      
      <time datetime="2019-11-02T02:52:41.000Z">
        2019-11-02
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 贪心
对牛和防晒霜从小到大排序
对于每瓶防晒霜来说，它有一个spf值，
找出所有下界小于spf的牛，放在一起
在这里面，上界也小于spf的牛可以直接扔掉(没救了)
上界大于spf即满足条件，此时防晒霜应优先给上界小的牛用
因为上界大的牛有更大的获得后续防晒霜的可能性
这里适合使用优先队列，从满足条件的牛中选出上界最小的
如果当前防晒霜用完了队列里还有牛，没关系，继续用下一瓶

Code#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

struct node
{
    int l, r;
}a[3000];

bool cmp(node a, node b)
{
    if(a.l != b.l)
        return a.l &lt; b.l;
    return a.r &lt; b.r;
}

struct spf
{
    i -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>C头牛，L瓶防晒霜，</p>
<p>C行，每行代表每头牛既能日光浴又不会被晒伤时的spf取值范围</p>
<p>L行，每行代表每瓶防晒霜能使牛的spf值变成多少，以及每瓶能涂抹几头牛</p>
<p>求最多有几头牛可以既能晒日光浴又能不被晒伤</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2019/11/02/POJ-3614-Sunscreen-贪心-优先队列/"> Read more -->
          </a></span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <a class="extend prev" rel="prev" href="/page/9/"> </a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/11/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
        <a class="friends-list-link" style="display: block;" href="https://fireworks99.github.io/" title="" target="_blank">fireworks99</a>
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome-Extensions/">Chrome Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP----------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPのST算法/">DPのST算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの区间DP/">DPの区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの状压DP/">DPの状压DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの线性DP/">DPの线性DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの背包DP/">DPの背包DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FE-Performance/">FE Performance</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのNote/">JavaScriptのNote</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのPromise/">JavaScriptのPromise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのmysql/">NodeJSのmysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのstatic/">NodeJSのstatic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのupload/">NodeJSのupload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue---------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのPlugin/">VueのPlugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのRenderFunc/">VueのRenderFunc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのaxios/">Vueのaxios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのcomponents/">Vueのcomponents</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのfilters/">Vueのfilters</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのi8n/">Vueのi8n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのreactivity/">Vueのreactivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのrouter/">Vueのrouter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのv-sth/">Vueのv-sth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのvuex/">Vueのvuex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-API/">Web API--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-APIのWindow/">Web APIのWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web杂项/">Web杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图のKM算法/">二分图のKM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图の匈牙利算法/">二分图の匈牙利算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化の二分/">优化の二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言/">其他语言--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のHTML/">其他语言のHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のJAVA/">其他语言のJAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のPython/">其他语言のPython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のnext-permutation/">函数のnext_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のprev-permutation/">函数のprev_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-判环/">图论の拓扑排序(判环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-无环/">图论の拓扑排序(无环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の欧拉路/">图论の欧拉路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法/">基本算法--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の贪心/">基本算法の贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の递推/">基本算法の递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のAC自动机/">字符串のAC自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のKMP/">字符串のKMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串の最长回文子串/">字符串の最长回文子串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧/">技巧-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の前缀和/">技巧の前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の博弈/">技巧の博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の哈希/">技巧の哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の尺取法/">技巧の尺取法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の差分/">技巧の差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の异或/">技巧の异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の弹性碰撞/">技巧の弹性碰撞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の归并排序/">技巧の归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の折半枚举/">技巧の折半枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の暴力打表/">技巧の暴力打表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の翻转问题/">技巧の翻转问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の莫队算法/">技巧の莫队算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の输入挂/">技巧の输入挂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据类型のstring/">数据类型のstring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构-------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のDancing-Links/">数据结构のDancing-Links</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmap/">数据结构のmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmultiset/">数据结构のmultiset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のpriority-queue/">数据结构のpriority_queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のset/">数据结构のset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のvector/">数据结构のvector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の主席树/">数据结构の主席树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の单调栈/">数据结构の单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の字典树/">数据结构の字典树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の并查集/">数据结构の并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の最小生成树/">数据结构の最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の栈-stack/">数据结构の栈(stack)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の树状数组/">数据结构の树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の线段树/">数据结构の线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の链式前向星/">数据结构の链式前向星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论のGCD与LCM/">数论のGCD与LCM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の同余定理/">数论の同余定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の大数求余/">数论の大数求余</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の快速幂/">数论の快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の扩展欧几里得/">数论の扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の杂项/">数论の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の欧拉降幂/">数论の欧拉降幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の素数筛/">数论の素数筛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の费马小定理/">数论の费马小定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の高斯消元法/">数论の高斯消元法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のKruskal/">最小生成树のKruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のPrim/">最小生成树のPrim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の树形图/">最小生成树の树形图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の计数/">最小生成树の计数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のBellman-Ford/">最短路のBellman-Ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のDijkstra/">最短路のDijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のFloyd/">最短路のFloyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のspfa/">最短路のspfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/知识/">知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索/">简单搜索---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のA/">简单搜索のA*</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のBFS/">简单搜索のBFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のDFS/">简单搜索のDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索の剪枝/">简单搜索の剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学/">组合数学----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の容斥/">组合数学の容斥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の组合数/">组合数学の组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最大流最小割/">网络流の最大流最小割</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最小费用流/">网络流の最小费用流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何/">计算几何----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何の离散化/">计算几何の离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络の杂项/">计算机网络の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图/">连通图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の2-sat/">连通图の2-sat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图のLCA/">连通图のLCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の割点/">连通图の割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の桥/">连通图の桥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の缩点/">连通图の缩点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题解/">题解</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/05/04/click-vs-onclick/">@click vs onclick</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/04/25/elementUI-sync/">elementUI .sync</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/04/24/JS-async-await/">JS async/await</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/04/20/JS-this/">JS this</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2023/04/07/Vue-childProps-sync-parentData/">Vue :childProps.sync=&#39;parentData&#39;</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <a class="extend prev" rel="prev" href="/page/9/"> </a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/11/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by Baole Zhao | 
				Powered by <a href="http://hexo.io">Hexo</a> |
				theme <a href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
