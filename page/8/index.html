


<!DOCTYPE html>
<html lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<title>求知若渴，虚心若愚 [ 市井烟火气 ]</title>
	
	
	<!-- stylesheets list from _config.yml -->
	
	<link rel="stylesheet" href="/css/PreciousJoy.css">
	
	<link rel="stylesheet" href="/css/top-bar.css">
	
	<link rel="stylesheet" href="/css/menu-outer.css">
	
	<link rel="stylesheet" href="/css/content-outer.css">
	
	<link rel="stylesheet" href="/css/bottom-outer.css">
	
	<link rel="stylesheet" href="/css/atom-one-dark.css">
	
	<link rel="stylesheet" href="/css/recent-posts-item.css">
	
	<link rel="stylesheet" href="/css/article-sidebar-toc.css">
	
	<link rel="stylesheet" href="/css/jquery.fancybox.min.css">
	
	<link rel="stylesheet" href="/css/search.css">
	
	<link rel="stylesheet" href="/css/toc.css">
	
	<link rel="stylesheet" href="/css/sidebar.css">
	
	<link rel="stylesheet" href="/css/archive.css">
	
	<link rel="stylesheet" href="/css/jquery.mCustomScrollbar.min.css">
	
	<link rel="stylesheet" href="/css/Z-last-cover-others.css">
	
	
	
</head>




<body id="wrapper">

	<div id="">
		
		<div id="top-bar">
			
			<div id="avatar-box">
				<img class="avatar" src="/images/default-avatar.jpg" alt="avatar">
			</div>

			<div id="top-bar-text">
				<div id="top-bar-title">
					fireworks99
				</div>
				<div id="top-bar-slogan">
					keep hungry keep foolish
				</div>
			</div>

		</div>

		<div id="menu-outer">
			<div id="menu-inner">
				
				
				<div class="menu-item">
					<a href="/">Home</a>
				</div>
				
				<div class="menu-item">
					<a href="/about">About</a>
				</div>
				
				<div class="menu-item">
					<a href="/archives">Archives</a>
				</div>
				

				<div class="menu-item menu-item-search">
					
  <span class="local-search local-search-google local-search-plugin">
      <input type="search" placeholder="站内搜索" id="local-search-input" class="local-search-input-cls" style="">
      <div id="local-search-result" class="local-search-result-cls"></div>
  </span>
	
				</div>

			</div>
		</div>

		<div id="content-outer">
			<div id="content-inner">

				

<div id="recent-posts-box">

  
  <div id="recent-posts">
    <!-- <h1>Recent Posts</h1> -->
    
    
    <div class="recent-post-item">

      <a href="/2020/03/22/HDU-3642-Get-The-Treasury-Segment-Tree-Scanning-Lines/" class="item-title">HDU 3642 Get The Treasury(Segment Tree Scanning Lines)</a>
      
      <time datetime="2020-03-22T12:15:33.000Z">
        2020-03-22
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
相交至少三次与相交至少两次的处理方法一样
然后三维，降维做题，遍历Z轴，一层一层地求解
还有一点要注意，ans += len3[1] * (e[i + 1].h - e[i].h);不行了，相邻的两个面，e[i + 1]与e[i]只是y轴上相邻，Z轴上可能天上地下，所以用一个变量last记录本层前一个y

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 20010;

int n;

int num;
int X[N];
int cnt[N &lt;&lt; 2 | 1];
int len1[N &lt;&lt; 2 | 1], len2[N &lt;&lt; 2 | 1], len3[N &lt;&lt; 2 | 1];

struct edge
{
    int l, r, h, zd, zu;
    int flag;
    e -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>长方体相交，求相交至少3次部分的体积</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/22/HDU-3642-Get-The-Treasury-Segment-Tree-Scanning-Lines/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/22/HDU-1255-Covered-area-Segment-Tree-Scanning-Lines/" class="item-title">HDU 1255 Covered area(Segment Tree Scanning Lines)</a>
      
      <time datetime="2020-03-22T09:08:38.000Z">
        2020-03-22
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
相对于求矩形面积并集，此题所求的特点在于cnt[o] &gt;= 2 才有 len[o] = X[R + 1] - X[L];。另外这要求每段的cnt及时更新，而之前那种方法不down，数据没有被正确表示，而现在就需要用上lazy数组down下去了。
另外加一个query函数释放所有的lazy以更新数据
对于之前写过的线段树们，下面节点的状态没被更新不影响上面节点状态的正确性，而这一题下面节点不被lazy更新会导致上面节点呈现着错误的状态，所以每次从线段树取值时都需要释放所有lazy更新这棵树。
现在这种方案：需要用到线段树维护的值时，释放全部lazy
相比较于：不用lazy，每次update都更新到底
还是省时间的

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 2100;

int n;

int num;
double X[N];
 -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>多个矩形相交，求至少被覆盖过两次的面积</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/22/HDU-1255-Covered-area-Segment-Tree-Scanning-Lines/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/21/POJ-1151-Atlantis-Segment-Tree-about-Scanning-lines/" class="item-title">POJ 1151 Atlantis(Segment Tree about Scanning lines)</a>
      
      <time datetime="2020-03-21T08:44:37.000Z">
        2020-03-21
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- 扫描线

线段树是可以从0开始的，只是保证标号从1开始就行
线段树每个点维护一段区间
当然需要离散化，将浮点数类型的x值对应成每条垂线的标号，这样之后可以用线段树维护当前扫描线的长度，计算具体长度时逆离散化。
扫描线长度 * 两条相邻两条水平线的高度差 = 矩形面积

Upvoid up(int o, int L, int R)
{
    if(cnt[o])
        len[o] = X[R + 1] - X[L];
    else if(L == R)
        len[o] = 0;
    else
        len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];
}


这里按理说有if与else就行了，只是当L == R时不能按照else处理(叶子节点没有子节点了)，所以单独写一下。它等于0是因为这个不可分割的一段没有被覆盖，所以不取它。并不是因为什么“点没有长度”，这里线段树每个点也对应一段区间(不可再分割了)。

Code#include &lt;cstdio&gt;
#include &lt;cs -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>求N个矩形面积的并集</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/21/POJ-1151-Atlantis-Segment-Tree-about-Scanning-lines/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/20/HDU-4553-Date-arrange-Segment-Tree/" class="item-title">HDU 4553 Date arrange(Segment Tree)</a>
      
      <time datetime="2020-03-20T11:04:47.000Z">
        2020-03-20
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
题目要求：寻找具有某种属性的、连续的最长区间
与HDU 1540相同，都是找符合某一特点的连续的最长区间
那么线段树也是一样的
val：ans、lmax、rmax最长连续空间时间段的长度
此时ans起辅助作用，主角是lmax与rmax，只要down地足够深，要查找的区间总是某些个lmax与rmax的和。
此题维护两棵线段树：DS树与NS树
①DS x:
若DS树有长度足够的区间，去DS树上找结束位置(-x即起始位置)
将DS树对应区间三个val置零
找不到区间直接输出相应字符串
②NS x:
若DS树有长度足够的区间，去DS树上找结束位置(-x即起始位置)
将DS树和NS树对应区间三个val置零
若DS树没有足够空间，但NS树有足够空间，去NS书上找
将DS树和NS树对应区间三个val置零
若都没有足够空间，输出相应字符串
③STUDY x y:
将DS树和NS树对应区间恢复为1（即val值恢复为区间长度）
另外代码中的query函数，三分去找够大的空闲区间的第x时刻

Code#include &lt;cstdio&gt;
#include &lt;cstring&g -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>中文题目：小明</p>
<p>与DS开黑</p>
<p>与NS约会</p>
<p>学习</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/20/HDU-4553-Date-arrange-Segment-Tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/19/HDU-4614-Vases-and-Flowers-Segment-Tree-and-Binary-Search/" class="item-title">HDU 4614 Vases and Flowers(Segment Tree and Binary Search)</a>
      
      <time datetime="2020-03-19T11:22:14.000Z">
        2020-03-19
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
问题：
①关于找位置没有思路，不知道线段树的val记录什么才能方便找位置
②关于更新：区间[X, Y]内的0更新为1，这一点若是单点修改很费时，咋办
对策：
①val记录区间内1的个数，二分找答案
②不需要单点更新，区间更新即可，这种bool状态非此即彼，将区间内非0的单点修改为1等效于将整个区间所有点置1

Something about Segment Tree
①关于懒惰：
像维护区间和这种要求，int型的lazy实现了两个作用：
1.是否需要down 
2.down的值是多大。
而本题是维护“状态”(的区间和)，已知知道down多少(即区间长度)，原则上只用bool型变量标记一下就行，但实际上有三个状态(1.不需要down2.down‘1’3.down’0’)，要用int。
②不用结构体的线段树可以省去建树的过程，但是以后写其他函数形参里都要加两个变量L、R。涉及到子区间先写一下mid。
③update和query很简单的时候可以写在一起。
④val down 后是否需要up：视具体情境。

Code#include &lt;cstdio&gt;
#includ -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>区间[0, n - 1]，初始值全0，有m次操作。<br>操作分两类：<br>1 X Y 从位置X开始寻找Y个0，如果不足Y个，则寻找尽量多的0，并将他们的值全部修改为1，输出第一个和最后一个修改的1的位置。<br>2 X Y 输出区间[ X , Y ]内1的个数，并将区间内的1修改为0。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/19/HDU-4614-Vases-and-Flowers-Segment-Tree-and-Binary-Search/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/17/HDU-3974-Assign-the-task-DFS-Segment-Tree/" class="item-title">HDU 3974 Assign the task(DFS + Segment Tree)</a>
      
      <time datetime="2020-03-17T15:02:57.000Z">
        2020-03-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- DFS序

①能将树的上各点的“父子关系”体现出来
②区间左端点是代表，左端点.val恰好能反应这个区间对应点的当前属性

Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 50010;

int n, m, pre[N], tot, in[N], out[N];
bool vis[N];
char s[10];

int cnt, head[N];
struct edge
{
    int v, nxt;
}e[N];

struct interval
{
    int L, R, val;
}a[N &lt;&lt; 2 | 1];

void init()
{
    cnt = tot = 0;
    memset(head, -1, sizeof(head));
    memset(pre, -1, sizeof(pre));
    me -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个点代表N个员工，形成一棵树，某点的父节点代表他的上司。公司分配任务时，若分配任务y给x，那么x的下属也会停止他们手头的任务来做任务y。</p>
<p>分配任务、查询某人在做哪个任务。</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/17/HDU-3974-Assign-the-task-DFS-Segment-Tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/17/HDU-1540-Tunnel-Warfare-Segment-Tree/" class="item-title">HDU 1540 Tunnel Warfare(Segment Tree)</a>
      
      <time datetime="2020-03-17T07:09:58.000Z">
        2020-03-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
可以用 线段树 || 树状数组 || set 
线段树：
a[num].lmax：包含区间左端点的最大连续子区间长度
a[num].rmax：包含区间右端点的最大连续子区间长度
a[num].ans：本区间最大连续子区间长度（仅用于剪枝：==0 return）
举例：
query(int num, int t)
int mid = (a[num].L + a[num].R) &gt;&gt; 1;
if(t &lt;= mid)
{
    if(a[num &lt;&lt; 1].rmax &gt;= mid - t + 1)
    {
        ans += a[num &lt;&lt; 1].rmax + a[num &lt;&lt; 1 | 1].lmax;
        return ;
    }
    else
        query(num &lt;&lt; 1, t);
}
else


Code#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream& -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>N个点(1 ~ N)，M个操作</p>
<p>D x 破坏点x</p>
<p>Q x 查询与x直接或间接相连的点（包括x自身）</p>
<p>R x 修复最近一次被破坏的点</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/17/HDU-1540-Tunnel-Warfare-Segment-Tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/17/HDU-4027-Can-you-answer-these-queries-Segment-tree/" class="item-title">HDU 4027 Can you answer these queries(Segment tree)</a>
      
      <time datetime="2020-03-17T03:21:59.000Z">
        2020-03-17
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Something about Segment Tree
线段树有initial、update、query三个函数
initial函数用到了int mid = ( + ) &gt;&gt; 1;
而流氓写法的update、query函数没有用到mid

Analyze
觉得这种题目的更新没办法lazy，区间更新只能换成暴力单点更新。
此题的剪枝在于“算术平方根”，所给范围内的数字求8次以内次数的算术平方根就会变成1，现在拿一组变量纪录每个区间的最大值，若区间最大值是1，那么就没必要向下更新了。

Code#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
#define ll long long
const int N = 100005;

ll n, k, ans, val[N];
struct node
{
    ll L, R, sum, m -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给出一个数字N，给出1到N这个N个数字的初值</p>
<p>M个操作：</p>
<ol>
<li>更新x、y之间所有数字为他们的算术平方根</li>
<li>查询x、y之间所有数字的和</li>
</ol>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/17/HDU-4027-Can-you-answer-these-queries-Segment-tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/16/ZOJ-1610-Count-the-colors-Segment-tree/" class="item-title">ZOJ 1610 Count the colors(Segment tree)</a>
      
      <time datetime="2020-03-16T08:16:00.000Z">
        2020-03-16
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
跟POJ有一道“贴海报”的题类似，只不过那题只求最终可以看到几种海报，这题还要统计段数。暴力单点查询，用一个last变量记录上一个点的颜色，若与现在这个点颜色不相同，那当前颜色段数++。更新last。

Code#include &lt;map&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 8005;

int n, cnt[N], last = -1;
struct interval
{
    int L, R, val;
} a[N &lt;&lt; 2 | 1];

void init(int num, int l, int r)
{
    a[num].L = l;
    a[num].R = r;
    a[num].val = -1;

    if(l == r)
        return ;

    int  -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>给区间涂色（可遮挡），问最终可看到哪几种颜色，以及这几种颜色分别有几段？</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/16/ZOJ-1610-Count-the-colors-Segment-tree/"> Read more -->
          </a></span>
        </div>

        
    
    <div class="recent-post-item">

      <a href="/2020/03/16/POJ-3026-Brog-Maze-BFS-Prim/" class="item-title">POJ 3026 Brog Maze(BFS+Prim)</a>
      
      <time datetime="2020-03-16T03:23:31.000Z">
        2020-03-16
      </time>
      
      <!-- <div class="article-digest"> -->
        <!-- Analyze
用BFS求出(S、A)各点之间的最小距离，建立图的边
求最小生成树

Code#include &lt;queue&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int N = 55;
const int INF = 0x3f3f3f3f;
typedef pair&lt;int, int&gt; P;

int n, m, node[N][N], num, dis[N][N], e[N * N][N * N], low[N * N];
char str[N], mp[N][N];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
bool vis[N][N], used[N * N];


void BFS(int x, int y)
{
    memset(vis, 0, sizeof(vis) -->
        <!-- </div> -->

        
        <h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote>
<p>将S和A所在点连成最小生成树</p>
</blockquote>
        
        


        <span>
          <a class="article-read" href="/2020/03/16/POJ-3026-Brog-Maze-BFS-Prim/"> Read more -->
          </a></span>
        </div>

        
      </div>
      


      <div id="recent-posts-paginator">
        <a class="extend prev" rel="prev" href="/page/7/"> </a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/9/"> </a>
      </div>

    </div>

<aside id="sidebar">
  
  <div class="widget-box">
  	  <div class="widget-box">
    <h3 class="widget-title-friends">friends</h3>
    <div class="widget">
      
        <a class="friends-list-link" style="display: block;" href="https://fireworks99.github.io/" title="" target="_blank">fireworks99</a>
      
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-tag">tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Chrome-Extensions/">Chrome Extensions</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DP/">DP----------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPのST算法/">DPのST算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの区间DP/">DPの区间DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの状压DP/">DPの状压DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの线性DP/">DPの线性DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DPの背包DP/">DPの背包DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECS/">ECS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FE/">FE----------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの主流布局/">FEの主流布局</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの多端适配/">FEの多端适配</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの工程化/">FEの工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの异步调用/">FEの异步调用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの性能优化/">FEの性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの模块化/">FEの模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FEの浏览器兼容/">FEの浏览器兼容</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのNote/">JavaScriptのNote</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptのPromise/">JavaScriptのPromise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJS/">NodeJS---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのmysql/">NodeJSのmysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのstatic/">NodeJSのstatic</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NodeJSのupload/">NodeJSのupload</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue---------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのPlugin/">VueのPlugin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VueのRenderFunc/">VueのRenderFunc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのaxios/">Vueのaxios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのcomponents/">Vueのcomponents</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのfilters/">Vueのfilters</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのi8n/">Vueのi8n</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのreactivity/">Vueのreactivity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのrouter/">Vueのrouter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのv-sth/">Vueのv-sth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vueのvuex/">Vueのvuex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-API/">Web API--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web-APIのWindow/">Web APIのWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web杂项/">Web杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图/">二分图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图のKM算法/">二分图のKM算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分图の匈牙利算法/">二分图の匈牙利算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化/">优化-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/优化の二分/">优化の二分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言/">其他语言--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のHTML/">其他语言のHTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のJAVA/">其他语言のJAVA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/其他语言のPython/">其他语言のPython</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数/">函数--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のnext-permutation/">函数のnext_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/函数のprev-permutation/">函数のprev_permutation</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论/">图论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-判环/">图论の拓扑排序(判环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の拓扑排序-无环/">图论の拓扑排序(无环)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图论の欧拉路/">图论の欧拉路</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法/">基本算法--------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の贪心/">基本算法の贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基本算法の递推/">基本算法の递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串/">字符串-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のAC自动机/">字符串のAC自动机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串のKMP/">字符串のKMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串の最长回文子串/">字符串の最长回文子串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧/">技巧-------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の前缀和/">技巧の前缀和</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の博弈/">技巧の博弈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の哈希/">技巧の哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の尺取法/">技巧の尺取法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の差分/">技巧の差分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の异或/">技巧の异或</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の弹性碰撞/">技巧の弹性碰撞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の归并排序/">技巧の归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の折半枚举/">技巧の折半枚举</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の暴力打表/">技巧の暴力打表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の翻转问题/">技巧の翻转问题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の莫队算法/">技巧の莫队算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技巧の输入挂/">技巧の输入挂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据类型のstring/">数据类型のstring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构-------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のDancing-Links/">数据结构のDancing-Links</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmap/">数据结构のmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のmultiset/">数据结构のmultiset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のpriority-queue/">数据结构のpriority_queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のset/">数据结构のset</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构のvector/">数据结构のvector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の主席树/">数据结构の主席树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の单调栈/">数据结构の单调栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の字典树/">数据结构の字典树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の并查集/">数据结构の并查集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の最小生成树/">数据结构の最小生成树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の栈-stack/">数据结构の栈(stack)</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の树状数组/">数据结构の树状数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の线段树/">数据结构の线段树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构の链式前向星/">数据结构の链式前向星</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论/">数论--------------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论のGCD与LCM/">数论のGCD与LCM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の同余定理/">数论の同余定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の大数求余/">数论の大数求余</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の快速幂/">数论の快速幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の扩展欧几里得/">数论の扩展欧几里得</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の杂项/">数论の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の欧拉降幂/">数论の欧拉降幂</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の素数筛/">数论の素数筛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の费马小定理/">数论の费马小定理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数论の高斯消元法/">数论の高斯消元法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树/">最小生成树------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のKruskal/">最小生成树のKruskal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树のPrim/">最小生成树のPrim</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の树形图/">最小生成树の树形图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最小生成树の计数/">最小生成树の计数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路/">最短路-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のBellman-Ford/">最短路のBellman-Ford</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のDijkstra/">最短路のDijkstra</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のFloyd/">最短路のFloyd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/最短路のspfa/">最短路のspfa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/知识/">知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索/">简单搜索---------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のA/">简单搜索のA*</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のBFS/">简单搜索のBFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索のDFS/">简单搜索のDFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/简单搜索の剪枝/">简单搜索の剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学/">组合数学----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の容斥/">组合数学の容斥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组合数学の组合数/">组合数学の组合数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流/">网络流-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最大流最小割/">网络流の最大流最小割</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络流の最小费用流/">网络流の最小费用流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何/">计算几何----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算几何の离散化/">计算几何の离散化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机网络の杂项/">计算机网络の杂项</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图/">连通图-----------------------</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の2-sat/">连通图の2-sat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图のLCA/">连通图のLCA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の割点/">连通图の割点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の桥/">连通图の桥</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/连通图の缩点/">连通图の缩点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/题解/">题解</a></li></ul>
    </div>
  </div>


  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-archive">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/04/">April 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">March 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">February 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">October 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">September 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li></ul>
    </div>
  </div>

  </div>
  
  <div class="widget-box">
  	
  <div class="widget-box">
    <h3 class="widget-title-post">recent_posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a class="recent_posts-list-link" href="/2024/05/10/HJ44-Sudoku/">HJ44 Sudoku</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2024/05/09/HJ28-素数伴侣/">HJ28 素数伴侣</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2024/04/12/Modular/">Modular</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2024/04/12/Engineering/">Engineering</a>
          </li>
        
          <li>
            <a class="recent_posts-list-link" href="/2024/04/12/Async-invoke/">Async invoke</a>
          </li>
        
      </ul>
    </div>
  </div>

  </div>
  
</aside>

<!-- <div id="paginator"> -->
<!--   <a class="extend prev" rel="prev" href="/page/7/"> </a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><a class="extend next" rel="next" href="/page/9/"> </a> -->
<!-- </div> -->

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            processEscapes: true
          }
        });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
            tex2jax: {
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
            }
          });
      </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
              var all = MathJax.Hub.getAllJax(), i;
              for(i=0; i < all.length; i += 1) {
                  all[i].SourceElement().parentNode.className += ' has-jax';
              }
          });
    </script>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



			</div>
		</div>

		<div id="bottom-outer">
			<div id="bottom-inner">
				Site by Baole Zhao | 
				Powered by <a href="http://hexo.io">Hexo</a> |
				theme <a href="https://github.com/fireworks99/hexo-theme-PreciousJoy">PreciousJoy</a>
			</div>
		</div>

		
	</div>





	
	<!-- scripts list from theme config.yml -->
	
	<script src="/js/jquery-3.5.1.min.js"></script>
	
	<script src="/js/PreciousJoy.js"></script>
	
	<script src="/js/highlight.pack.js"></script>
	
	<script src="/js/jquery.fancybox.min.js"></script>
	
	<script src="/js/search.js"></script>
	
	<script src="/js/load.js"></script>
	
	<script src="/js/jquery.mCustomScrollbar.concat.min.js"></script>
	
	<script src="/js/clipboard.min.js"></script>
	
	

	<script>hljs.initHighlightingOnLoad();</script>

</body>
</html>
