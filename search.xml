<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue Router</title>
      <link href="2023/03/31/Vue-Router/"/>
      <url>2023/03/31/Vue-Router/</url>
      
        <content type="html"><![CDATA[<h2 id="路由的两种方式"><a href="#路由的两种方式" class="headerlink" title="路由的两种方式"></a>路由的两种方式</h2><ol><li>Hash：<code>location.hash = &#39;about&#39;</code>，形如<code>file:///Users/.../202303311041.html#foo</code></li><li>HTML5 History API：<ul><li><code>history.pushState({}, &#39;&#39;, &quot;about&quot;)</code> （可返回）</li><li><code>history.replaceState({}, &#39;&#39;, about)</code>；不可返回</li><li><code>history.go(num)</code></li></ul></li></ol><a id="more"></a><h2 id="1-The-simplest-router"><a href="#1-The-simplest-router" class="headerlink" title="1.The simplest router"></a>1.The simplest router</h2><p> (hashchange + <code>&lt;component :is&gt;</code>)</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;a href=&quot;#foo&quot;&gt;foo&lt;/a&gt;        &lt;a href=&quot;#bar&quot;&gt;bar&lt;/a&gt;        &lt;component :is=&quot;cmp&quot;&gt;&lt;/component&gt;    &lt;/div&gt;    &lt;script&gt;        const app = new Vue({            el: &quot;#app&quot;,            components: {                Foo: {                    template: &quot;&lt;div&gt;foo&lt;/div&gt;&quot;                },                Bar: {                    template: &quot;&lt;div&gt;bar&lt;/div&gt;&quot;                }            },            data() {                return {                    cmp: &quot;bar&quot;                };            }        });        window.addEventListener(&#39;hashchange&#39;, () =&gt; {            // app.cmp = window.location.hash === &quot;#foo&quot; ? &quot;foo&quot; : &quot;bar&quot;;            app.cmp = window.location.hash.slice(1);        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-Extracting-a-route-table"><a href="#2-Extracting-a-route-table" class="headerlink" title="2.Extracting a route table"></a>2.Extracting a route table</h2><p> (hashchange + <code>&lt;component :is&gt;</code>)</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;a href=&quot;#foo&quot;&gt;foo&lt;/a&gt;        &lt;a href=&quot;#bar&quot;&gt;bar&lt;/a&gt;        &lt;a href=&quot;#fire&quot;&gt;fire&lt;/a&gt;        &lt;component :is=&quot;curCmp&quot;&gt;&lt;/component&gt;    &lt;/div&gt;    &lt;script&gt;        const Foo = { template: `&lt;div&gt;foo&lt;/div&gt;` };        const Bar = { template: `&lt;div&gt;bar&lt;/div&gt;` };        const Fire = { template: `&lt;div&gt;fire&lt;/div&gt;` };        const NotFound = { template: `&lt;div&gt;not found&lt;/div&gt;` };        const routeTable = {            foo: Foo,            bar: Bar,            fire: Fire        };        const app = new Vue({            el: &quot;#app&quot;,            components: {                Foo, Bar, Fire, NotFound            },            data() {                return {                    cmp: &quot;bar&quot;                }            },            computed: {                curCmp() {                    return routeTable[this.cmp] || NotFound;                }            }        });        window.addEventListener(&#39;hashchange&#39;, () =&gt; {            // app.cmp = window.location.hash === &quot;#foo&quot; ? &quot;foo&quot; : &quot;bar&quot;;            app.cmp = window.location.hash.slice(1);        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p> (hashchange + render)</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;!-- &lt;a href=&quot;#foo&quot;&gt;foo&lt;/a&gt;        &lt;a href=&quot;#bar&quot;&gt;bar&lt;/a&gt;        &lt;a href=&quot;#fire&quot;&gt;fire&lt;/a&gt;        &lt;component :is=&quot;curCmp&quot;&gt;&lt;/component&gt; --&gt;    &lt;/div&gt;    &lt;script&gt;        const Foo = { template: `&lt;div&gt;foo&lt;/div&gt;` };        const Bar = { template: `&lt;div&gt;bar&lt;/div&gt;` };        const Fire = { template: `&lt;div&gt;fire&lt;/div&gt;` };        const NotFound = { template: `&lt;div&gt;not found&lt;/div&gt;` };        const routeTable = {            foo: Foo,            bar: Bar,            fire: Fire        };        const app = new Vue({            el: &quot;#app&quot;,            components: {                Foo, Bar, Fire, NotFound            },            data() {                return {                    cmp: &quot;bar&quot;                }            },            render(h) {                return h(&#39;div&#39;, [                    h(&#39;a&#39;, { attrs: {href: &quot;#foo&quot;} }, &quot;foo&quot;),                    h(&#39;a&#39;, { attrs: {href: &quot;#bar&quot;} }, &quot;bar&quot;),                    h(&#39;a&#39;, { attrs: {href: &quot;#fire&quot;} }, &quot;fire&quot;),                    h(routeTable[this.cmp] || NotFound)                ]);            }        });        window.addEventListener(&#39;hashchange&#39;, () =&gt; {            // app.cmp = window.location.hash === &quot;#foo&quot; ? &quot;foo&quot; : &quot;bar&quot;;            app.cmp = window.location.hash.slice(1);        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="3-URL-matching"><a href="#3-URL-matching" class="headerlink" title="3.URL matching"></a>3.URL matching</h2><p>（with ‘path-to-regexp’）</p><p>前面的例子仅仅是在顶级页面切换，情境简单。</p><blockquote><p>路由形参：’/user/:username’</p><p>路由实参：’/user/123’</p><p>路由解析：{ username: ‘123’ }</p></blockquote><script src="https://cdn.jsdelivr.net/npm/path-to-regexp@6.2.1/dist.es2015/index.min.js"></script><p>第三方库path-to-regexp的使用</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;../JS/path-to-regexp.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        /**         * 路由形参：&#39;/user/:username&#39;         * 路由实参：&#39;/user/123&#39;         * 路由解析：{ username: &#39;123&#39; }        **/        const keys = [];        const regex = pathToRegexp(&quot;/foo/:username&quot;, keys);        console.log(keys);        /**         * [            {                &quot;name&quot;: &quot;username&quot;,                &quot;prefix&quot;: &quot;/&quot;,                &quot;delimiter&quot;: &quot;/&quot;,                &quot;optional&quot;: false,                &quot;repeat&quot;: false,                &quot;partial&quot;: false,                &quot;pattern&quot;: &quot;[^\\/]+?&quot;            }           ]           keys[0].name        **/        const result = regex.exec(&#39;/foo/123&#39;);        console.log(result);                    //[&quot;/foo/123&quot;,&quot;123&quot;]        //result[0 + 1]        //路由解析:         // {         //     keys[0].name: result[0 + 1],        //     keys[1].name: result[1 + 1],        //     ...        //     keys[n].name: result[n + 1]        // }        const res1 = regex.exec(&#39;/bar/123&#39;);        console.log(res1);                       //null        const res2 = regex.exec(&#39;foo/123&#39;);      //缺少 &#39;/&#39;，匹配不到        console.log(res2);                       //null    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>实现一个简单的router</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;../JS/path-to-regexp.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        const Foo = {            props: [&#39;id&#39;],            template: `&lt;div&gt;foo with id: {{id}}&lt;/div&gt;`        };        const Bar = { template: `&lt;div&gt;bar&lt;/div&gt;` };        const NotFound = { template: `&lt;div&gt;not found&lt;/div&gt;` };        const routeTable = {            &#39;/foo/:id&#39;: Foo,            &#39;/bar&#39;: Bar        };        //打表(预编译)        const compiledRoutes = []        Object.keys(routeTable).forEach(key =&gt; {            const dynamicSegments = []            const regex = pathToRegexp(key, dynamicSegments)            const component = routeTable[key]            compiledRoutes.push({                component,                regex,                dynamicSegments            })        })        //查表        console.log(compiledRoutes.length);         //2        compiledRoutes.forEach(value =&gt; console.log(value));        /**         *          *  compiledRoutes[0]:         *          *  component: {                &quot;props&quot;: [                    &quot;id&quot;                ],                &quot;template&quot;: &quot;&lt;div&gt;foo with id: {{id}}&lt;/div&gt;&quot;            }            dynamicSegments: [{                &quot;name&quot;: &quot;id&quot;,                &quot;prefix&quot;: &quot;/&quot;,                &quot;delimiter&quot;: &quot;/&quot;,                &quot;optional&quot;: false,                &quot;repeat&quot;: false,                &quot;partial&quot;: false,                &quot;pattern&quot;: &quot;[^\\/]+?&quot;            }],            regex: /^\/foo\/((?:[^\/]+?))(?:\/(?=$))?$/i        **/        /**         *          *  compiledRoutes[1]:         *          *  component: {                &quot;template&quot;: &quot;&lt;div&gt;bar&lt;/div&gt;&quot;            }            dynamicSegments: [],            regex: /^\/bar(?:\/(?=$))?$/i        **/        window.addEventListener(&#39;hashchange&#39;, () =&gt; {            app.url = window.location.hash.slice(1);        });        const app = new Vue({            el: &quot;#app&quot;,            data() {                return {                    // url: &quot;bar&quot;                    url: window.location.hash.slice(1)                }            },            render(h) {                const path = &#39;/&#39; + this.url;//为了能匹配到                let componentToRender;                let props = {};                //solution                compiledRoutes.some(route =&gt; {                    const match = route.regex.exec(path)                    componentToRender = NotFound                    if (match) {                        componentToRender = route.component                        route.dynamicSegments.forEach((segment, index) =&gt; {                            props[segment.name] = match[index + 1]                            /**                             * props[&quot;id&quot;] = match[1] = &quot;456&quot;                            **/                        })                        return true                    }                })                /**                 *                 **/                return h(&#39;div&#39;, [                    h(componentToRender, { props }),                    h(&#39;a&#39;, { attrs: { href: &#39;#foo/123&#39; } }, &#39;foo 123&#39;),                    &#39; | &#39;,                    h(&#39;a&#39;, { attrs: { href: &#39;#foo/456&#39; } }, &#39;foo 456&#39;),                    &#39; | &#39;,                    h(&#39;a&#39;, { attrs: { href: &#39;#bar&#39; } }, &#39;bar&#39;),                    &#39; | &#39;,                    h(&#39;a&#39;, { attrs: { href: &#39;#garbage&#39; }}, &#39;garbage&#39;)                ])            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのrouter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Vuex</title>
      <link href="2023/03/30/Vue-Vuex/"/>
      <url>2023/03/30/Vue-Vuex/</url>
      
        <content type="html"><![CDATA[<p>需求：一个计数器组件，要渲染三次，这个计数器组件展示count变量，添加一个按钮，点击这个按钮一次，三个计数器都++。</p><a id="more"></a><h2 id="1-属性传递"><a href="#1-属性传递" class="headerlink" title="1.属性传递"></a>1.属性传递</h2><p>count数据存储在共同的最近公共祖先组件中，通过props属性接收。</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;counter :count=&quot;count&quot;&gt;&lt;/counter&gt;        &lt;counter :count=&quot;count&quot;&gt;&lt;/counter&gt;        &lt;counter :count=&quot;count&quot;&gt;&lt;/counter&gt;        &lt;button @click=&quot;count++&quot;&gt;count++&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        const app = new Vue({            el: &quot;#app&quot;,            data() {                return {                    count: 0                }            },            components: {                Counter: {                    props: [&quot;count&quot;],                    template: `&lt;div&gt;{{ count }}&lt;/div&gt;`                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="2-状态管理"><a href="#2-状态管理" class="headerlink" title="2.状态管理"></a>2.状态管理</h2><p>上述方案中，如果组件树很庞大，而<strong>LCA组件又是根组件</strong>，那么需要不断传递props，这样不合理。</p><p>所以要有一种方法</p><ul><li>使所有这些子组件共享同一状态</li><li>根组件能够更新这一状态</li></ul><h3 id="①-Shared-objects"><a href="#①-Shared-objects" class="headerlink" title="①.Shared objects"></a>①.Shared objects</h3><blockquote><p>共享对象当作状态</p></blockquote><p>(将共享对象作为组件data，组件data返回的变量会被Vue跟踪监听，从而具有“响应性”)</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;button @click=&quot;inc()&quot;&gt;count++&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        const state = {            count: 0        };        const Counter = {            data() {                //组件data属性返回的变量会被Vue跟踪监听                //从而具有“响应性”                return state;            },            render(h) {                return h(&#39;div&#39;, this.count);            }        }        const app = new Vue({            el: &quot;#app&quot;,            components: {                Counter            },            methods: {                inc() {                    state.count++;                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="②-Shared-Vue-instances"><a href="#②-Shared-Vue-instances" class="headerlink" title="②.Shared Vue instances"></a>②.Shared Vue instances</h3><blockquote><p>共享Vue实例作为状态</p></blockquote><p>(Vue实例默认具有响应性)</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;button @click=&quot;inc()&quot;&gt;count++&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        const state = new Vue({            data: {                count: 0            },            methods: {                inc() {                    this.count++;                }            }        });        const Counter = {            render: h =&gt; h(&#39;div&#39;, state.count)        }        const app = new Vue({            el: &quot;#app&quot;,            components: {                Counter            },            methods: {                inc() {                    state.inc();                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="③-Mutations-APl"><a href="#③-Mutations-APl" class="headerlink" title="③.Mutations APl"></a>③.Mutations APl</h3><blockquote><p>mutations：是真正<strong>变更状态</strong>的地方。必须是<strong>同步</strong>的。（快照）</p><p>actions：可以有异步代码。</p></blockquote><p><strong>实现一个简单的VueX：</strong></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;button @click=&quot;inc()&quot;&gt;count++&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        //按照使用方法，实现这个功能        function createStore({state, mutations}) {            return new Vue({                data: {                    state                },                methods: {                    commit(mutation) {                        if(!mutations.hasOwnProperty(mutation)) {                            throw new Error(&#39;Unknown mutation&#39;);                        }                        mutations[mutation](state);                    }                }            })        }        const store = createStore({            state: {count: 0},            mutations: {                inc(state) {                    state.count++;                }            }        });        const Counter = {            render(h) {                return h(&#39;div&#39;, store.state.count);            }        };        const app = new Vue({            el: &quot;#app&quot;,            components: {                Counter            },            methods: {                inc() {                    store.commit(&#39;inc&#39;);                }            }        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="④Functional-interface"><a href="#④Functional-interface" class="headerlink" title="④Functional interface"></a>④Functional interface</h3><blockquote><p>函数式编程</p></blockquote><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;counter&gt;&lt;/counter&gt;        &lt;button @click=&quot;inc()&quot;&gt;count++&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        /**         * 解构赋值：         * 有名字时，是按名字来的，与顺序无关         * 没名字时，按顺序来         * */        //按照使用方法，实现这个功能        function app({ el, model, view, actions }) {            const wrappedActions = {}            Object.keys(actions).forEach(key =&gt; {                const originalAction = actions[key]                wrappedActions[key] = () =&gt; {                    vm.model = originalAction(vm.model)                }            })            const vm = new Vue({                el,                data: {                    model                },                render(h) {                    return view(h, this.model, wrappedActions)                },                methods: actions            })        }        app({            el: &#39;#app&#39;,            model: {                count: 0            },            actions: {                inc: ({ count }) =&gt; ({ count: count + 1 }),                dec: ({ count }) =&gt; ({ count: count - 1 })            },            view: (h, model, actions) =&gt; h(&#39;div&#39;, { attrs: { id: &#39;app&#39; } }, [                model.count,                &#39; &#39;,                h(&#39;button&#39;, { on: { click: actions.inc } }, &#39;+&#39;),                h(&#39;button&#39;, { on: { click: actions.dec } }, &#39;-&#39;)            ])        })    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>参数actions那里挺绕的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのvuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue High order component</title>
      <link href="2023/03/29/High-order-component/"/>
      <url>2023/03/29/High-order-component/</url>
      
        <content type="html"><![CDATA[<h2 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h2><p>你原本有一个组件，你可以通过另外一个组件进行包裹，这个新的组件既具有原来组件的功能，又可以添加自己的功能，这种方式成为高阶组件。</p><a id="more"></a><h3 id="①案例："><a href="#①案例：" class="headerlink" title="①案例："></a>①案例：</h3><pre><code class="lang-js">// 基础组件，只负责把传入src属性显示到一个图片标签const Avatar = {  props: [&#39;src&#39;],  template: `&lt;img :src=&quot;src&quot;&gt;`}</code></pre><p><code>Avatar</code>组件，它接收一个<code>src</code>属性并显示到<code>img</code>标签。这个组件非常简单，但是在使用的时候不是很方便，因为我们需要传递一个完整的图片地址给它。我们使用的时候，希望只传递用户的名字就可以显示头像图片，这种场景使用高阶组件实现是最合适的。</p><h3 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;smart-avatar username=&quot;fireworks99&quot;&gt;&lt;/smart-avatar&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    // 该函数只是用来模拟网络请求    function fetchURL(username, cb) {        setTimeout(() =&gt; {            // hard coded, bonus: exercise: make it fetch from gravatar!            cb(&#39;https://avatars3.githubusercontent.com/u/6128107?v=4&amp;s=200&#39; + username)        }, 500)    }    // 基础组件，只负责把传入src属性显示到一个图片标签    const Avatar = {        props: [&#39;src&#39;],        template: `&lt;img :src=&quot;src&quot;&gt;`    }    function withAvatarURL(InnerComponent) {        return {            props: [&#39;username&#39;],            inheritAttrs: false, // 2.4 only            data() {                return { url: null }            },            created() {                fetchURL(this.username, url =&gt; {                    this.url = url                })            },            render(h) {                return h(InnerComponent, {                    // attrs: this.$attrs, // 2.4 only                    props: {                        src: this.url || &#39;http://via.placeholder.com/200x200&#39;                    }                })            }        }    }    const SmartAvatar = withAvatarURL(Avatar);    new Vue({        el: &#39;#app&#39;,        components: { SmartAvatar }    })&lt;/script&gt;&lt;/html&gt;</code></pre><p><code>withAvatarURL</code>函数接收一个内部组件，然后返回一个高阶函数，在这个例子中，内部组件就是<code>Avatar</code>，然后我们可以接收一个用户名，再通过用户名查询用户头像URL显示到页面上。</p><p><code>this.$attrs</code>用于获取组件所有属性，这是2.4之后才支持的功能，上面代码我们把高阶组件设置的属性传递给原始组件（在这个项目中没有体现意义）。</p><h3 id="vs-mixin"><a href="#vs-mixin" class="headerlink" title="vs mixin"></a>vs mixin</h3><p>在上面案例的场景中，其实用minxin也是可以实现的，但是使用高阶组件有以下优势：</p><ol><li><strong>重用性</strong>。因为minxin对原组件具有侵入性，这会导致原来组件的可重用性降低，而高阶组件不会，高阶组件对原组件只是一个调用关系，并没有修改原来组件任何内容。</li><li><strong>可测试性</strong>。因为高阶组件只是一个嵌套关系，在组件测试的时候，可以单独的测试原始组件和高阶组件。</li><li><strong>层级问题</strong>。高阶组件也有他的弊端，如果你高阶组件嵌套层级太深，会导致出错的时候调试困难的问题，所以到底使用高阶组件和minxin需要看实际场景。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのcomponents </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Render Function</title>
      <link href="2023/03/28/Vue-Render-Function/"/>
      <url>2023/03/28/Vue-Render-Function/</url>
      
        <content type="html"><![CDATA[<h2 id="1-渲染过程"><a href="#1-渲染过程" class="headerlink" title="1.渲染过程"></a>1.渲染过程</h2><p>Template =&gt; Render Function =&gt; Virtual DOM =&gt; Actual DOM</p><a id="more"></a><p><img src="/2023/03/28/Vue-Render-Function/renderFunc.png" alt="render process" style="transform: scale(0.5);"></p><ol><li><p>Template =&gt; Render Function</p><p>两种编译模式：</p><ul><li>把模板直接传入Vue实例，Vue执行完整的编译，打包时连同编译器打包，压缩后约30KB</li><li>使用Vue CLI构建项目，用到webpack与vue-loader，vue-loader会预编译，压缩后约20KB</li></ul></li><li><p>Render Function =&gt; Virtual DOM</p><p>渲染函数返回虚拟DOM</p></li><li><p>Virtual DOM =&gt; Actual DOM</p><p>Vue基于虚拟DOM生成真实DOM</p></li></ol><h2 id="2-虚拟DOM"><a href="#2-虚拟DOM" class="headerlink" title="2.虚拟DOM"></a>2.虚拟DOM</h2><p><img src="/2023/03/28/Vue-Render-Function/VirtualDOM.png" alt="Virtual DOM" style="transform: scale(0.5);"></p><p>真实DOM的节点与虚拟DOM的节点是一一对应的，虚拟DOM使用一个JS对象来表示真实DOM的一个Node，而操作JS对象远比操作DOM节点更加简单。</p><p>数据或视图发生变化时，Vue会比较变化前后虚拟DOM的不同点，<strong>根据虚拟DOM的不同点来更新真实DOM</strong>。</p><p>使用Vue Template Explorer可以查看<strong>渲染函数</strong>（查看Vue是如何转换虚拟DOM的）。</p><p><a href="https://template-explorer.vuejs.org/" target="_blank" rel="noopener">https://template-explorer.vuejs.org/</a></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;quickFixIndent&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;wrapper&quot;&gt;  &lt;header&gt;    &lt;textarea placeholder=&quot;before&quot; id=&quot;before&quot;&gt;&lt;/textarea&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;input id=&quot;number&quot; type=&quot;text&quot; placeholder=&quot;indent number&quot; value=&quot;2&quot;&gt;    &lt;button onclick=&quot;solve()&quot;&gt;Get!&lt;/button&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;textarea placeholder=&quot;after&quot; id=&quot;after&quot;&gt;&lt;/textarea&gt;  &lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="lang-js">import { createCommentVNode as _createCommentVNode, createElementVNode as _createElementVNode, Fragment as _Fragment, openBlock as _openBlock, createElementBlock as _createElementBlock } from &quot;vue&quot;export function render(_ctx, _cache, $props, $setup, $data, $options) {  return (_openBlock(), _createElementBlock(_Fragment, null, [    _createCommentVNode(&quot;DOCTYPE html&quot;),    _createElementVNode(&quot;html&quot;, { lang: &quot;en&quot; }, [      _createElementVNode(&quot;head&quot;, null, [        _createElementVNode(&quot;meta&quot;, { charset: &quot;UTF-8&quot; }),        _createElementVNode(&quot;title&quot;, null, &quot;quickFixIndent&quot;)      ]),      _createElementVNode(&quot;body&quot;, null, [        _createElementVNode(&quot;div&quot;, { id: &quot;wrapper&quot; }, [          _createElementVNode(&quot;header&quot;, null, [            _createElementVNode(&quot;textarea&quot;, {              placeholder: &quot;before&quot;,              id: &quot;before&quot;            })          ]),          _createElementVNode(&quot;main&quot;, null, [            _createElementVNode(&quot;input&quot;, {              id: &quot;number&quot;,              type: &quot;text&quot;,              placeholder: &quot;indent number&quot;,              value: &quot;2&quot;            }),            _createElementVNode(&quot;button&quot;, { onclick: &quot;solve()&quot; }, &quot;Get!&quot;)          ]),          _createElementVNode(&quot;footer&quot;, null, [            _createElementVNode(&quot;textarea&quot;, {              placeholder: &quot;after&quot;,              id: &quot;after&quot;            })          ])        ])      ])    ])  ], 2112 /* STABLE_FRAGMENT, DEV_ROOT_FRAGMENT */))}// Check the console for the AST</code></pre><h2 id="3-渲染函数API"><a href="#3-渲染函数API" class="headerlink" title="3.渲染函数API"></a>3.渲染函数API</h2><p><img src="/2023/03/28/Vue-Render-Function/renderFuncAPI.png" alt="Render Function API" style="transform: scale(0.5);"></p><p>上图是调用一个渲染函数例子，<code>render</code>函数接收一个参数<code>h</code>， <code>h</code>只是一种约定的简写表示超脚本（HyperScript），他没有什么特殊意义，只是就像超文本我们叫HTML一样，只是方便书写的表示形式而已。</p><p><code>h</code>函数接受三个参数，第一个是元素类型；第二是参数对象例如表示元素的attr属性，DOM属性之类的；第三个属性表示一些子节点，你可以调用h函数生成更多子节点。</p><p><img src="/2023/03/28/Vue-Render-Function/hCase.png" alt="h case" style="transform: scale(0.5);"></p><p>第二个参数是可以省略的，第三参数很灵活可以是数组(表示子元素)、单纯的文本(表示标签)以及组件变量名(表示组件)。</p><h2 id="4-动态渲染标签"><a href="#4-动态渲染标签" class="headerlink" title="4.动态渲染标签"></a>4.动态渲染标签</h2><p>编写一个组件，组件根据<code>tags</code>属性在页面上输入相应的HTML标签</p><ol><li><p>使用<code>document.createElement</code></p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;example :tags=&quot;[&#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;]&quot;&gt;&lt;/example&gt;    &lt;/div&gt;&lt;/body&gt;&lt;template id=&quot;example&quot;&gt;    &lt;div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    Vue.component(&#39;example&#39;, {        template: &quot;#example&quot;,        props: {            tags: {                type: Array,                default() {                    return [];                }            }        },        mounted() {            console.log(&quot;mounted&quot;);            console.log(this.$el);            console.log(this.tags);            this.tags.forEach((tag, index)=&gt; {                let element = document.createElement(tag);                element.innerHTML = index;                this.$el.appendChild(element);            });        }    });    new Vue({el: &#39;#app&#39;});&lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><ol><li><p>使用component标签</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;example :tags=&quot;[&#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;]&quot;&gt;&lt;/example&gt;    &lt;/div&gt;&lt;/body&gt;&lt;template id=&quot;example&quot;&gt;    &lt;div&gt;        &lt;component v-for=&quot;(tag, index) in tags&quot; :is=&quot;tag&quot;&gt;{{index}}&lt;/component&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    Vue.component(&#39;example&#39;, {        template: &quot;#example&quot;,        props: {            tags: {                type: Array,                default() {                    return [];                }            }        }    });    new Vue({el: &#39;#app&#39;});&lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><ol><li><p>使用渲染函数</p><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;动态渲染标签&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;example :tags=&quot;[&#39;h1&#39;, &#39;h2&#39;, &#39;h3&#39;]&quot;&gt;&lt;/example&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    Vue.component(&#39;example&#39;, {        props: [&#39;tags&#39;],        render(h) {            return h(&#39;div&#39;, this.tags.map((tag, i) =&gt; h(tag, i)))        }    })    new Vue({ el: &#39;#app&#39; })&lt;/script&gt;&lt;/html&gt;</code></pre></li></ol><p>效果：</p><p><img src="/2023/03/28/Vue-Render-Function/DynamicRenderTag.png" alt="DynamicRenderTag" style="transform: scale(0.5);"></p><h2 id="5-动态渲染组件"><a href="#5-动态渲染组件" class="headerlink" title="5.动态渲染组件"></a>5.动态渲染组件</h2><pre><code class="lang-html">&lt;div id=&quot;demo_4_6&quot;&gt;    &lt;example :ok=&quot;ok&quot;&gt;&lt;/example&gt;    &lt;button @click=&quot;ok = !ok&quot;&gt;toggle&lt;/button&gt;&lt;/div&gt;</code></pre><pre><code class="lang-js">const Foo = {    render(h) {        return h(&#39;div&#39;, &#39;foo&#39;)    }}const Bar = {    render(h) {        return h(&#39;div&#39;, &#39;bar&#39;)    }}Vue.component(&#39;example&#39;, {    props: [&#39;ok&#39;],    render(h) {        return h(this.ok ? Foo : Bar)    }})new Vue({ el: &#39;#demo_4_6&#39;, data: { ok: true } })</code></pre><h2 id="6-渲染函数与响应系统"><a href="#6-渲染函数与响应系统" class="headerlink" title="6.渲染函数与响应系统"></a>6.渲染函数与响应系统</h2><p><img src="/2023/03/28/Vue-Render-Function/RenderFuncAndReactivity.png" alt="RenderFuncAndReactivity" style="transform: scale(0.5);"></p><p>上图是Vue的响应性系统和渲染系统的运行流程，可以看到每个组件有自己的渲染函数，这个渲染函数实际上是运行在我们之前封装的<code>autorun</code>函数中的，组件开始渲染时会把属性收集到依赖项中，当调用属性的setter方法，会触发<code>watcher</code>执行重新渲染，因为渲染函数放在<code>autorun</code>函数中，所以每当data数据发生变化，就会重新渲染。</p><p>每个组件都有自己独立的循环渲染系统，组件只负责自己的依赖项，这一特性对于你拥有大型组件树时是一个优势，你的数据可以在任何地方改变，因为系统知道数据与组件的对应关系，不会造成过度渲染问题，这一架构优势可以让我们摆脱一些优化工作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> VueのRenderFunc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue Plugin</title>
      <link href="2023/03/27/Vue-Plugin/"/>
      <url>2023/03/27/Vue-Plugin/</url>
      
        <content type="html"><![CDATA[<h2 id="1-插件简介"><a href="#1-插件简介" class="headerlink" title="1.插件简介"></a>1.插件简介</h2><p>插件本质是一个普通函数，第一个参数是Vue，第二个参数是可选参数叫<code>options</code></p><pre><code class="lang-js">function (Vue, options) {  //...插件代码}</code></pre><a id="more"></a><p>插件往往结合<code>vue.mixin(options)</code>使用，<code>mixin</code>本质上是把重复的代码片段混入到Vue组件中，供组件复用逻辑。但是<code>vue.mixin</code>是一个全局api，它会应用到所有实例，所以不要在这个API做疯狂的事情。</p><p>使用<code>vue.mixin</code>更好的办法是使用插件包裹，因为插件会自动删除，而且就算多次调用<code>Vue.use</code>应用同一个插件，它会防止重复应用，但是<code>vue.mixin</code>就不行了。另外使用<code>Vue.use</code>会让代码更好理解，可以清楚知道应用使用了哪些插件。</p><h2 id="2-options属性"><a href="#2-options属性" class="headerlink" title="2.$.options属性"></a>2.$.options属性</h2><p>很多人可能不太清楚<code>$.options</code>属性，其实每个组件都有<code>$.options</code>属性它表示实例组件的配置项，配置项可以是组件自身的配置也可以是继承过来的配置项或者是<code>vue.mixin</code>混入的。</p><h2 id="3-编写一个插件"><a href="#3-编写一个插件" class="headerlink" title="3.编写一个插件"></a>3.编写一个插件</h2><p>插件实现的功能：每个组件在created之后，监听检查某些数据是否合规，若不合规打印出不合规提示信息。</p><p>src/plugins/check.js</p><pre><code class="lang-js">export default {    install: (Vue, options) =&gt; {        Vue.mixin({            created() {                const rules = this.$options.rules;                if(rules) {                    Object.keys(rules).forEach((key) =&gt; {                        const rule = rules[key];                        this.$watch(key, (newValue) =&gt; {                            const valid = rule.validate(newValue);                            if(!valid) {                                console.log(rule.message);                            }                        })                    })                }            }        })    }}</code></pre><p>src/main.js</p><pre><code class="lang-js">import Vue from &#39;vue&#39;;import App from &#39;./App.vue&#39;;import router from &#39;./router&#39;;import store from &#39;./store&#39;;import check from &#39;./plugins/check&#39;;Vue.config.productionTip = false;Vue.use(check);new Vue({  router,  store,  render: function (h) { return h(App) }}).$mount(&#39;#app&#39;);</code></pre><p>src/App.vue</p><pre><code class="lang-html">&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;nav&gt;      &lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;      &lt;input type=&quot;checkbox&quot; value=&quot;Sunny&quot; v-model=&quot;people&quot;&gt;Sunny      &lt;input type=&quot;checkbox&quot; value=&quot;Tiffany&quot; v-model=&quot;people&quot;&gt;Tiffany      &lt;input type=&quot;checkbox&quot; value=&quot;Jessica&quot; v-model=&quot;people&quot;&gt;Jessica      &lt;h2&gt;你的偶像有：{{ people }}&lt;/h2&gt;      &lt;router-link to=&quot;/&quot;&gt;Home&lt;/router-link&gt; |      &lt;router-link to=&quot;/about&quot;&gt;About&lt;/router-link&gt;    &lt;/nav&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><pre><code class="lang-js">&lt;script&gt;export default {  name: &quot;App&quot;,  data() {    return {      name: &quot;fireworks99&quot;,      people: []    };  },  rules: {    name: {      validate: value =&gt; value.indexOf(&quot;99&quot;) !== -1,      message: &quot;Must include 99&quot;    },    people: {      validate: value =&gt; value.length &lt; 3,      message: &quot;Number of idols must be less than 3&quot;    }  }}&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> VueのPlugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mini Data Observer</title>
      <link href="2023/03/22/Mini-Data-Observer/"/>
      <url>2023/03/22/Mini-Data-Observer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>响应性的实现</p><p>Angular：脏值检测</p><p>Vue：依赖跟踪</p></blockquote><a id="more"></a><h1 id="1-A-gt-B"><a href="#1-A-gt-B" class="headerlink" title="1. A =&gt; B"></a>1. A =&gt; B</h1><blockquote><p>B = A * 10，B依赖A，B的响应性的实现方法，是在A的set方法中传入一个改变B的方法。（这个方法解释了B对A的依赖）</p></blockquote><pre><code class="lang-js">let a = 1;let b = a * 10;function setA(v) {  a = v;  updateB();}function updateB() {  b = a * 10;}setA(2);console.log(b);//20</code></pre><h1 id="2-监听A的变更"><a href="#2-监听A的变更" class="headerlink" title="2.监听A的变更"></a>2.监听A的变更</h1><blockquote><p>ES5的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>提供监听属性变更的功能(指set方法)</p></blockquote><pre><code class="lang-js">const state = {  a: 0};let b;function updateB() {  b = state.a * 10;}let internalValue = state.a;Object.defineProperty(state, &quot;a&quot;, {  get() {    return internalValue;  },  set(v) {    internalValue = v;    updateB();  }})state.a = 2;console.log(b);//20</code></pre><h1 id="3-收集依赖"><a href="#3-收集依赖" class="headerlink" title="3.收集依赖"></a>3.收集依赖</h1><blockquote><p>前面都是假定依赖A的变量只有B，且这是已知的。</p><p>而实际业务中，依赖A的变量随着代码的编写会逐渐增多，这就要求系统能够动态维护<strong>所有依赖A的变量对于A的依赖关系</strong>，以便在A发生变更时按照每个依赖关系修改每个依赖项。</p></blockquote><p>需要实现一个依赖跟踪类<code>Dep</code>，类里有一个叫<code>depend</code>方法，该方法用于收集依赖项；另外还有一个<code>notify</code>方法，该方法用于触发依赖项的执行，也就是说只要在之前使用<code>depend</code>方法收集的依赖项，当调用<code>notfiy</code>方法时会被触发执行。</p><pre><code class="lang-js">window.Dep = class Dep {  constructor () {    // 存放依赖关系    this.subscribers = new Set()  }    // 新增依赖关系  depend () {    if (activeUpdate) {      this.subscribers.add(activeUpdate)    }  }    // 所有依赖项，按照依赖关系执行更新操作  notify () {    this.subscribers.forEach(sub =&gt; sub())  }}let activeUpdate = null//新增依赖关系（后面详细解释）function autorun (update) {  const wrappedUpdate = () =&gt; {    activeUpdate = wrappedUpdate    update()    activeUpdate = null  }  wrappedUpdate()}</code></pre><h1 id="4-合并2、3步"><a href="#4-合并2、3步" class="headerlink" title="4.合并2、3步"></a>4.合并2、3步</h1><h2 id="①-实现"><a href="#①-实现" class="headerlink" title="①.实现"></a>①.实现</h2><pre><code class="lang-js">class Dep {  constructor () {    this.subscribers = new Set()  }  depend () {    if (activeUpdate) {      this.subscribers.add(activeUpdate)    }  }  notify () {    this.subscribers.forEach(sub =&gt; sub())  }}function observe (obj) {  Object.keys(obj).forEach(key =&gt; {    let internalValue = obj[key]    const dep = new Dep()    Object.defineProperty(obj, key, {      get () {        dep.depend()        return internalValue      },      set (newVal) {        const changed = internalValue !== newVal        internalValue = newVal        if (changed) {          dep.notify()        }      }    })  })  return obj}let activeUpdate = nullfunction autorun (update) {  const wrappedUpdate = () =&gt; {    activeUpdate = wrappedUpdate    update()    activeUpdate = null  }  wrappedUpdate()}</code></pre><h2 id="②-使用"><a href="#②-使用" class="headerlink" title="②.使用"></a>②.使用</h2><pre><code class="lang-js">//情景模拟{  const state = {    count: 1  };  observe(state);  let foo = 1;  let fire = 1;  autorun(() =&gt; {    foo = state.count * 10;    console.log(&quot;state.count is &quot; + state.count);    console.log(&quot;foo is &quot; + foo);    console.log(&quot;fire is &quot; + fire);  });  /**   * ①控制台打印：   * state.count is 1   * foo is 10   * fire is 1   */  state.count++;  /**   * ②控制台打印：   * state.count is 2   * foo is 20   * fire is 1   */  autorun(() =&gt; {    fire = state.count + 100;    console.log(&quot;state.count is &quot; + state.count);    console.log(&quot;foo is &quot; + foo);    console.log(&quot;fire is &quot; + fire);  });  /**   * ③控制台打印：   * state.count is 2   * foo is 20   * fire is 102   */  state.count++;  /**   * ③控制台打印：   * state.count is 3   * foo is 30   * fire is 102   * state.count is 3   * foo is 30   * fire is 103   */}</code></pre><p>autorun这个方法的参数是一个function，这个function里面执行了updata方法，而update方法是按照依赖关系更新依赖项，这一操作势必会访问A，既然访问A，势必调用getter，既然调用getter，势必调用<code>dep.depend</code>来新增依赖关系。所以autorun这个方法是用来<strong>新增依赖关系</strong>的。</p><h2 id="③-补充"><a href="#③-补充" class="headerlink" title="③.补充"></a>③.补充</h2><p>上面说到”update方法是按照依赖关系更新依赖项，这一操作势必会访问A，既然访问A，势必调用getter”，接下来验证一下：</p><pre><code class="lang-js">const state = {  count: 0}let value = state.count;Object.defineProperty(state, &quot;count&quot;, {  get() {    console.log(value);    return value;  }})let foo = 0;// 执行下面这一句// 会执行get方法打印state.count的值// 即打印 0foo = state.count + 1;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのreactivity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Global Object</title>
      <link href="2022/12/02/JavaScript-Global-Object/"/>
      <url>2022/12/02/JavaScript-Global-Object/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript-Global-Objects"><a href="#JavaScript-Global-Objects" class="headerlink" title="JavaScript Global Objects"></a>JavaScript Global Objects</h1><blockquote><p>全局对象，是指存在于全局作用域中的对象。</p><p>狭义上的全局对象是指<strong>唯一核心全局对象</strong></p><p>广义上的全局对象包括唯一核心全局对象的成员：<strong>标准内置对象</strong></p></blockquote><a id="more"></a><ul><li><p>唯一核心全局对象</p><ul><li><p>Web浏览器</p><ul><li>①.通常情况下：Window对象</li><li>②.Worker(后台任务)：WorkerGlobalScope对象</li></ul><p>web 浏览器中，脚本创建的<strong>全局变量</strong>作为该<strong>全局对象的成员</strong>被创建</p><p><code>var a = 1;</code>     =&gt;     <code>a === window.a</code>    is true (var is ok, let is not)</p><p><code>function run(){}</code>    =&gt;    <code>run === window.run</code>    is true</p></li></ul></li></ul><ul><li><p>Node.js</p><ul><li>③.Global对象</li></ul></li></ul><ul><li><p>标准内置对象</p><ul><li><p>值：Infinity / NaN / <strong>undefined</strong> / globalThis</p></li><li><p>函数：<strong>parseInt()</strong> / <strong>eval()</strong> / isNaN() / …… </p></li><li><p>基本对象：Object / Function / Boolean / Symbol</p></li><li><p>错误对象：<strong>Error</strong> / ReferenceError / TypeError / ……</p></li><li><p>数字对象：Number / BigInt / <strong>Math</strong></p></li><li><p>日期对象：<strong>Date</strong></p></li><li><p>字符串：String / RegExp</p></li><li>可索引的集合对象：<strong>Array</strong> / ……</li><li>使用键的集合对象：Map / Set / WeakMap / WeakSet</li><li>结构化数据：<strong>JSON</strong> / DataView / ……</li><li>控制抽象对象：<strong>Promise</strong> / ……</li><li>反射：Reflect / Proxy</li><li>国际化：Intl / ……</li><li>WebAssembly：WebAssembly/……</li><li>其他：arguments</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同一局域网下两主机通信</title>
      <link href="2022/10/10/%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E4%B8%A4%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/"/>
      <url>2022/10/10/%E5%90%8C%E4%B8%80%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%8B%E4%B8%A4%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我有两台主机A与B，他俩连接了同一个网络，我在B主机上开启了一个<strong>本地服务</strong>，比如说localhost:5500/index.html，两主机屏幕尺寸不一样，所以想在A主机上看看该网页样式怎么样，故查出B主机的内网IP(10.2.205.108)，在A主机浏览器中输入10.2.205.108:5500/index.html，即可访问。</p><p>部分原理如下：</p></blockquote><a id="more"></a><h2 id="1-过程"><a href="#1-过程" class="headerlink" title="1.过程"></a>1.过程</h2><ol><li>A主机的浏览器中输入10.2.205.108:5500/index.html，路由器检测到是私有IP，就不向外转发了。</li><li>A主机查找本机ARP表，看看IP为10.2.205.108的主机的MAC地址是啥，若找到了，直接转发帧。</li><li>若没找到，发起广播，询问目标主机的MAC地址，并告知自己的IP与MAC地址。</li><li>广播帧的目标主机收到帧后予以响应，非目标主机不响应。</li><li>过程中交换机记录帧转发表，两主机记录各自的ARP表。</li></ol><p><img src="/2022/10/10/同一局域网下两主机通信/request.png" alt="request"></p><p><img src="/2022/10/10/同一局域网下两主机通信/response.png" alt="responce"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.postMessage</title>
      <link href="2022/10/09/window-postMessage/"/>
      <url>2022/10/09/window-postMessage/</url>
      
        <content type="html"><![CDATA[<blockquote><p>window.postMessage()方法可以安全地实现<strong>跨域通信</strong>。</p><p>何为<strong>跨域</strong>？</p><p><strong>同源</strong>：如果两个URL的协议(protocol，如ftp、http)、主机(host，如blog.csdn.net)、端口号(port，如80、5500)三者都相同，那么这两个URL是同源。否则两者的通信需要跨域。</p><p>值得注意的是，域(domain)、源(origin)两者不是一回儿事，比如<code>https://blog.csdn.net</code>，其域<code>document.domain</code>为<code>csdn.net</code>，而其源之主机<code>window.location.host</code>为<code>blog.csdn.net</code>。</p></blockquote><a id="more"></a><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1.用法"></a>1.用法</h2><p>发送消息的页面：</p><pre><code class="lang-js">targetWindow.postMessage(data, targetOrigin, [transfer]);</code></pre><p>接收消息的页面</p><pre><code class="lang-js">window.addEventListener(&quot;message&quot;, function(e) {    xxx = e.source;    xxx = e.data;})</code></pre><p><code>window.addEventListener(&quot;message&quot;, function(e) {})</code></p><p>等效于</p><p><code>window.onmessage = function(e) {}</code></p><h2 id="2-应用"><a href="#2-应用" class="headerlink" title="2.应用"></a>2.应用</h2><p>发送消息的页面</p><p><code>file:///Users/xxx/xxx/daily/postMessage/postMessage.html</code></p><pre><code class="lang-html">&lt;body&gt;    &lt;textarea name=&quot;text&quot; id=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;    &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt;    &lt;!-- &lt;a href=&quot;http://127.0.0.1:5500/daily/postMessage/onMessage.html&quot; target=&quot;_blank&quot;&gt;打开接收页面&lt;/a&gt; --&gt;    &lt;a href=&quot;javascript:window.open(&#39;http://127.0.0.1:5500/daily/postMessage/onMessage.html&#39;)&quot;&gt;打开接收页面&lt;/a&gt;    &lt;script&gt;        let text = document.getElementById(&quot;text&quot;);        let btn = document.getElementById(&quot;btn&quot;);        let msgPage = null;        btn.onclick = function () {            msgPage &amp;&amp; msgPage.postMessage(text.value, &#39;*&#39;);        }        window.addEventListener(&quot;message&quot;, function(e) {            msgPage = e.source;            document.title = e.data;            text.value = e.data;        })    &lt;/script&gt;&lt;/body&gt;</code></pre><p>接受消息的页面</p><p><code>http://127.0.0.1:5500/daily/postMessage/onMessage.html</code></p><pre><code class="lang-html">&lt;body&gt;    &lt;textarea name=&quot;text&quot; id=&quot;text&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;    &lt;button id=&quot;btn&quot;&gt;发送&lt;/button&gt;    &lt;script&gt;        console.log(window.opener);        opener &amp;&amp; opener.postMessage(&quot;新页面打开成功&quot;, &#39;*&#39;);        let text = document.getElementById(&quot;text&quot;);        let btn = document.getElementById(&quot;btn&quot;);        btn.onclick = function () {            opener &amp;&amp; opener.postMessage(text.value, &#39;*&#39;);        }        window.addEventListener(&quot;message&quot;, function(e) {            document.title = e.data;            text.value = e.data;        })    &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>关于<code>window.opener</code>：返回打开当前窗口的那个窗口的引用，例如：在 window A 中打开了 window B，B.opener 返回 A.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Web APIのWindow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue filters</title>
      <link href="2022/09/28/Vue-filters/"/>
      <url>2022/09/28/Vue-filters/</url>
      
        <content type="html"><![CDATA[<blockquote><p>过滤器的作用：格式化数据。（不修改原数据，只是对数据进行加工，并返回加工后的数据）</p></blockquote><a id="more"></a><h2 id="1-应用位置"><a href="#1-应用位置" class="headerlink" title="1. 应用位置"></a>1. 应用位置</h2><h3 id="①-双花括号插值里"><a href="#①-双花括号插值里" class="headerlink" title="①. 双花括号插值里"></a>①. 双花括号插值里</h3><h3 id="②-v-bind表达式（很少用）"><a href="#②-v-bind表达式（很少用）" class="headerlink" title="②. v-bind表达式（很少用）"></a>②. v-bind表达式（很少用）</h3><pre><code class="lang-html">&lt;body&gt;  &lt;div id=&quot;app&quot;&gt;    {{message}}    &lt;br&gt;    {{message | capitalize}}  &lt;/div&gt;  &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const app = new Vue({      el: &quot;#app&quot;,      data: {        message: &quot;hello world!&quot;,        numString: 500      },      filters: {        capitalize: function(value) {          if(!value) return &quot;&quot;;          value = value.toString();          return value.charAt(0).toUpperCase() + value.slice(1);        }      }    })  &lt;/script&gt;&lt;/body&gt;</code></pre><pre><code class="lang-shell">hello worldHello world</code></pre><h2 id="2-作用范围"><a href="#2-作用范围" class="headerlink" title="2. 作用范围"></a>2. 作用范围</h2><h3 id="①-全局"><a href="#①-全局" class="headerlink" title="①.全局"></a>①.全局</h3><pre><code class="lang-js">Vue.filter(&#39;capitalize&#39;, function (value) {  if (!value) return &#39;&#39;  value = value.toString()  return value.charAt(0).toUpperCase() + value.slice(1)})new Vue({  // ...})</code></pre><h3 id="②-组件内"><a href="#②-组件内" class="headerlink" title="②.组件内"></a>②.组件内</h3><pre><code class="lang-js">filters: {  capitalize: function (value) {    if (!value) return &#39;&#39;    value = value.toString()    return value.charAt(0).toUpperCase() + value.slice(1)  }}</code></pre><p>Stack Overflow：I’m definitely doing something wrong but after multiples hours of Google, I can’t find why! </p>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのfilters </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Note 2022.09.07 Accessor property</title>
      <link href="2022/09/07/JavaScript-Note-2022-09-07-Accessor-property/"/>
      <url>2022/09/07/JavaScript-Note-2022-09-07-Accessor-property/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于JS对象的<strong>访问器</strong>属性（Accessor property）（JS对象<strong>属性的getter与setter</strong>）</p></blockquote><a id="more"></a><h2 id="1-认识访问器属性"><a href="#1-认识访问器属性" class="headerlink" title="1.认识访问器属性"></a>1.认识访问器属性</h2><pre><code class="lang-js">{    {      let person = {        firstName: &quot;Hello&quot;,        lastName: &quot;World&quot;,        fullName() {          return this.firstName + &quot; &quot; + this.lastName;        }      }      console.log(&quot;------------------------ 2 ------------------------&quot;);      console.log(person.fullName);      /**       *       * ƒ fullName() {       *         return this.firstName + &quot; &quot; + this.lastName;       *       }       *       */      console.log(person.fullName());    }    // fullName是个函数，需要调用才能得到值    // 但我想将其设为像firstName、lastName这样的普通属性，想直接通过person.fullName得到值    // 就像是Vue中的computed与methods似的，现在想将methods改写为computed    /**     * 为什么使用 Getter 和 Setter？     * 它提供了更简洁的语法     * 它允许属性和方法的语法相同     * 它可以确保更好的数据质量(我猜是说Vue的computed之于methods)     * 有利于后台工作     */    {      let person = {        firstName: &quot;Hello&quot;,        lastName: &quot;World&quot;,        get fullName() {          return this.firstName + &quot; &quot; + this.lastName;        }      }      console.log(&quot;------------------------ 3 ------------------------&quot;);      console.log(person.fullName);      // console.log(person.fullName());//Uncaught TypeError: person.fullName is not a function      // fullName 不是函数了！      // 从外表看，访问器属性(accessor property)看起来就像一个普通属性。这就是访问器属性的设计思想。      person.fullName = &quot;Captain America&quot;;//不报错，但它是无效的！      console.log(person.fullName);//Hello World      for(let key in person) {        console.log(key + &quot;: &quot; + person[key]);      }      // firstName: Hello      // lastName: World      // fullName: Hello World    }  }  {    let person = {      firstName: &quot;Hello&quot;,      lastName: &quot;World&quot;,      get fullName() {        return this.firstName + &quot; &quot; + this.lastName;      },      set fullName(value) {        //Destructuring Assignment 解构 -&gt; 赋值        [this.firstName, this.lastName] = value.split(&quot; &quot;);      }    }    console.log(&quot;------------------------ 4 ------------------------&quot;);    console.log(person.fullName);//Hello World    person.fullName = &quot;Captain America&quot;;    console.log(person.fullName);//Captain America  }  {    {      let person = {        firstName: &quot;Hello&quot;,        lastName: &quot;World&quot;,      }      Object.defineProperty(person, &#39;fullName&#39;, {        get() {          return this.firstName + &quot; &quot; + this.lastName;        },        set(value) {          [this.firstName, this.lastName] = value.split(&quot; &quot;);        }      })      console.log(&quot;------------------------ 5 ------------------------&quot;);      console.log(person.fullName);//Hello World      person.fullName = &quot;Captain America&quot;;      console.log(person.fullName);//Captain America      for(let key in person) {        console.log(key + &quot;: &quot; + person[key]);      }      // firstName: Captain      // lastName: America      // 通过 Object.defineProperty 定义的属性还是有些特殊的：for循环访问不到...........    }  }</code></pre><h2 id="2-访问器属性的实用之处"><a href="#2-访问器属性的实用之处" class="headerlink" title="2.访问器属性的实用之处"></a>2.访问器属性的实用之处</h2><h3 id="①-限制属性的访问-get-与修改-set"><a href="#①-限制属性的访问-get-与修改-set" class="headerlink" title="①.限制属性的访问(get)与修改(set)"></a>①.限制属性的访问(get)与修改(set)</h3><pre><code class="lang-js">{  //实用之处①：限制访问(get)与修改(set)  let user = &quot;visitor&quot;;  let person = {    firstName: &quot;Hello&quot;,    lastName: &quot;World&quot;,    get fullName() {      if(user === &quot;visitor&quot;) {        alert(&quot;Access Denied!&quot;);        return ;      }      return this.firstName + &quot; &quot; + this.lastName;    },    set fullName(value) {      if(value.length &lt; 6) {        alert(&quot;The value is too short!&quot;);        return;      }      [this.firstName, this.lastName] = value.split(&quot; &quot;);    }  }  console.log(&quot;------------------------ 6 ------------------------&quot;);  console.log(person.fullName);//alert(&quot;Access Denied!&quot;);  user = &quot;admin&quot;;  console.log(person.fullName);//Hello World  person.fullName = &quot;123&quot;;  console.log(person.fullName);//alert(&quot;The value is too short!&quot;);  person.fullName = &quot;Captain America&quot;;  console.log(person.fullName);//Captain America}</code></pre><h3 id="②-让代码向过去兼容（Backward-Compatibility）"><a href="#②-让代码向过去兼容（Backward-Compatibility）" class="headerlink" title="②.让代码向过去兼容（Backward Compatibility）"></a>②.让代码向过去兼容（Backward Compatibility）</h3><pre><code class="lang-js">{  //前人：过去的人     向前兼容：向未来兼容  //后人；将来的人     向后兼容：向过去兼容  //实用之处②：向后(过去)兼容(Backward Compatibility)  {    console.log(&quot;------------------------ 7 ------------------------&quot;);    //从前的代码    function Person(name, age) {      this.name = name;      this.age = age;    }    let Mike = new Person(&quot;Mike&quot;, 22);    //从前某个文件某处代码    console.log(&quot;Mike&#39;s age is &quot; + Mike.age);//Mike&#39;s age is 22  }  {    //某一天部分代码重构了    function Person(name, birthday) {      this.name = name;      this.birthday = birthday;      Object.defineProperty(this, &quot;age&quot;, {        get() {          let todayYear = 2022;          return todayYear - this.birthday;        }      });    }    let Mike = new Person(&quot;Mike&quot;, 2000);    //从前某个文件某处代码    console.log(&quot;Mike&#39;s age is &quot; + Mike.age);//Mike&#39;s age is 22    //老代码仍然能够正常跑！！！  }}</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>JAVASCRIPT.INFO，Property getters and setters，<a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener">https://zh.javascript.info/promise-basics</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Note 2022.09.02</title>
      <link href="2022/09/02/JavaScript-Note-2022-09-02/"/>
      <url>2022/09/02/JavaScript-Note-2022-09-02/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于JavaScript中的Promise的认识</p></blockquote><a id="more"></a><h2 id="1-Promise的诞生"><a href="#1-Promise的诞生" class="headerlink" title="1.Promise的诞生"></a>1.Promise的诞生</h2><blockquote><p>Promise是ES6新增的一个类，能够让开发者更<strong>优雅</strong>地写<strong>复杂的异步任务</strong>。</p></blockquote><p>下面是一个层层递进的异步任务：</p><pre><code class="lang-js">setTimeout(function () {    console.log(&quot;1 minute later&quot;);    setTimeout(function () {        console.log(&quot;1+3 minutes later&quot;);        setTimeout(function () {            console.log(&quot;1+3+5 minutes later&quot;);        }, 5000);    }, 3000);}, 1000);</code></pre><p>上述代码是一种<strong>嵌套格式</strong>，深层<strong>缩进</strong>，既不美观又难以阅读。</p><p>于是为解决这一问题，Promise应运而生。</p><pre><code class="lang-js">new Promise(function (resolve) {  setTimeout(function () {    console.log(&quot;1 second later&quot;);    resolve();  }, 1000);}).then(function () {  setTimeout(function () {    console.log(&quot;2 second later&quot;);  }, 1000);}).then(function () {  setTimeout(function () {    console.log(&quot;3 second later&quot;);  }, 1000);})</code></pre><p>上述代码是一种<strong>顺序格式</strong>，浅层缩进，美观易阅读。</p><h2 id="2-Promise的内部属性"><a href="#2-Promise的内部属性" class="headerlink" title="2.Promise的内部属性"></a>2.Promise的内部属性</h2><p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p><ul><li><code>state</code> —— 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled/resolved&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li><li><code>result</code> —— 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>Promise 对象的 <code>state</code> 和 <code>result</code> 属性都是内部的。我们无法直接访问它们。但我们可以对它们使用 <code>.then</code>/<code>.catch</code>/<code>.finally</code> 方法。 </p><h3 id="①-state"><a href="#①-state" class="headerlink" title="①.state"></a>①.state</h3><p>Promise有两种<strong>state</strong>：<strong><em>pending</em></strong>与<strong><em>settled</em></strong>，其中settled又包含<strong><em>fulfilled</em></strong>与<strong><em>rejected</em></strong>。</p><p><img src="/2022/09/02/JavaScript-Note-2022-09-02/promise_state.png" alt="promise state"></p><h3 id="②-result"><a href="#②-result" class="headerlink" title="②.result"></a>②.result</h3><p>Promise有三种<strong>result</strong>：undefined、value、error。</p><p><img src="/2022/09/02/JavaScript-Note-2022-09-02/promise-resolve-reject.svg" alt="promise_result"></p><p>补充：</p><ul><li>Promise构造函数中，不调用resolve与reject，则首个then不会执行。</li><li>Promise构造函数中，只调用二者之一便执行那个函数。</li><li>Promise构造函数中，<strong>两者都调用，只执行首个被调用的</strong>。<ul><li>原因：调用首个之后Promise的状态被更改了，<strong>任何状态的更改都是最终的</strong> 。</li></ul></li></ul><h2 id="3-Promise的构造函数"><a href="#3-Promise的构造函数" class="headerlink" title="3.Promise的构造函数"></a>3.Promise的构造函数</h2><pre><code class="lang-js">let promise = new Promise(function(resolve, reject) {    setTimeout(function () {        //doSth...        resolve(&quot;1 second later.&quot;);    }, 1000);}).then(function(value) {    console.log(value);}, function(error) {    console.log(error);})</code></pre><p>Promise构造函数只有一个参数，是一个函数，被称为executor（执行器 /  起始函数）。</p><p><code>resolve/reject</code> 只需要<strong>一个参数（或不包含任何参数）</strong>，并且将<strong>忽略额外的参数</strong>。 </p><p>补充（执行器立马执行）：</p><pre><code class="lang-js">let p = new Promise((resolve, reject) =&gt; {  console.log(1);  resolve();})p.then(() =&gt; console.log(3))console.log(2);</code></pre><blockquote><p>new Promise()的时候，Promise的执行器就会立马执行！<br>但是调用resolve()会触发异步操作，传入的then()方法的函数会被添加到 任务队列 并异步执行。<br>且这里的任务队列指的是“微任务队列”(Microtask queue)。</p><p>上述代码输出顺序为1 -&gt; 2 -&gt; 3。</p></blockquote><p>补充（执行器参数名可任意取）：</p><pre><code class="lang-js">let p = new Promise(function (a, b) {  setTimeout(function () {    b(&quot;Hello&quot;);                         //6 error: Hello  },1000);}).then(function (result) {  console.log(&quot;6 result: &quot; + result);}, function (error) {  console.log(&quot;6 error: &quot; + error);})let q = new Promise(function (reject, resolve) {  setTimeout(function () {    resolve(&quot;Hello&quot;);                  //6 error: Hello  },1000);}).then(function (result) {  console.log(&quot;6 result: &quot; + result);}, function (error) {  console.log(&quot;6 error: &quot; + error);})</code></pre><blockquote><p>执行器函数 参数的名字和实际调用的 resolve() 和 reject() 无关，关键在于顺序</p><p>第一个参数对应then中第一个函数</p><p>第二个参数对应then中第二个函数</p></blockquote><h2 id="4-Promise的三个方法"><a href="#4-Promise的三个方法" class="headerlink" title="4.Promise的三个方法"></a>4.Promise的三个方法</h2><p>Promise 类有 <code>.then()</code> <code>.catch()</code> 和 <code>.finally()</code> 三个方法 。</p><pre><code class="lang-js">new Promise(function (resolve, reject) {    var a = 0;    var b = 1;    if (b == 0) reject(&quot;Divide zero&quot;);    else resolve(a / b);}).then(function (value) {    console.log(&quot;a / b = &quot; + value);}).catch(function (err) {    console.log(err);}).finally(function () {    console.log(&quot;End&quot;);});</code></pre><blockquote><p>a / b = 0</p><p>End</p><p><code>.catch(func)</code> 调用 等效于<code>.then(null, func)</code>  </p></blockquote><p>补充（then、catch、finally是<strong>有顺序的</strong>）：</p><pre><code class="lang-js">new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; resolve(&quot;value&quot;), 2000)})  .finally(() =&gt; alert(&quot;Promise ready&quot;)) // 先触发  .then(result =&gt; alert(result)); // &lt;-- .then 显示 &quot;value&quot;</code></pre><blockquote><p>Promise ready</p><p>value</p><p>这里<code>finally</code>早于<code>then</code>执行，毕竟 <code>finally</code> 并不意味着处理一个 promise 的结果。无论结果是什么，它都是进行常规清理的地方。 </p></blockquote><h2 id="5-Promise-vs-callback"><a href="#5-Promise-vs-callback" class="headerlink" title="5.Promise vs callback"></a>5.Promise vs callback</h2><div class="table-container"><table><thead><tr><th></th><th>Promise</th><th>callback</th></tr></thead><tbody><tr><td>代码逻辑上</td><td>顺其自然：拿到结果再思考如何处理</td><td>尚未开始就得先考虑好拿到结果后如何处理</td></tr><tr><td>多层异步时</td><td>顺序格式：缩进简单，赏心悦目</td><td>嵌套格式：层层缩进，混乱无序</td></tr></tbody></table></div><h2 id="6-Promise-chain"><a href="#6-Promise-chain" class="headerlink" title="6.Promise chain"></a>6.Promise chain</h2><pre><code class="lang-js">new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(1), 1000); // (*)}).then(function(result) { // (**)  alert(result); // 1  return result * 2;}).then(function(result) { // (***)  alert(result); // 2  return result * 2;}).then(function(result) {  alert(result); // 4  return result * 2;});</code></pre><p><img src="/2022/09/02/JavaScript-Note-2022-09-02/promise-then-chain.svg" alt="chain 1"></p><pre><code class="lang-js">let promise = new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(1), 1000);});promise.then(function(result) {  alert(result); // 1  return result * 2;});promise.then(function(result) {  alert(result); // 1  return result * 2;});promise.then(function(result) {  alert(result); // 1  return result * 2;});</code></pre><p><img src="/2022/09/02/JavaScript-Note-2022-09-02/promise-then-many.svg" alt="chain 2"></p><blockquote><p>new Promise()中有<code>resolve</code>或<code>reject</code>将promise改为<code>fulfilled</code>状态或<code>rejected</code>状态，首个then才会被触发。首个then返回一个promise对象，第二个then是这个promise对象的“首个then”。而第二个then以及后续then也能够被触发说明返回的这个promise对象并非<code>pending</code>状态，而是<code>fulfilled</code>状态或<code>rejected</code>状态。</p></blockquote><p>Promise.prototype.then()的返回值：</p><p>当一个Promise完成（fulfilled）或者失败（rejected）时，返回函数将被异步调用（由当前的线程循环来调度完成）。具体的返回值依据以下规则返回。如果 <code>then</code> 中的回调函数：</p><ul><li>返回了一个值，那么 <code>then</code> 返回的 Promise 将会成为<strong>接受状态</strong>，并且将返回的值作为接受状态的回调函数的参数值。</li><li>没有返回任何值，那么 <code>then</code> 返回的 Promise 将会成为<strong>接受状态</strong>，并且该接受状态的回调函数的参数值为 <code>undefined</code>。</li><li>抛出一个错误，那么 <code>then</code> 返回的 Promise 将会成为<strong>拒绝状态</strong>，并且将抛出的错误作为拒绝状态的回调函数的参数值。</li><li>返回一个已经是接受状态的 Promise，那么 <code>then</code> 返回的 Promise 也会成为<strong>接受状态</strong>，并且将那个 Promise 的接受状态的回调函数的参数值作为该被返回的 Promise 的接受状态回调函数的参数值。</li><li>返回一个已经是拒绝状态的 Promise，那么 <code>then</code> 返回的 Promise 也会成为拒绝状态，并且将那个 Promise 的拒绝状态的回调函数的参数值作为该被返回的 Promise 的拒绝状态回调函数的参数值。</li><li>返回一个未定状态（<code>pending</code>）的 Promise，那么 <code>then</code> 返回 Promise 的状态也是未定的，并且它的终态与那个 Promise 的终态相同；同时，它变为终态时调用的回调函数参数与那个 Promise 变为终态时的回调函数的参数是相同的。</li></ul><h2 id="7-Promise-all"><a href="#7-Promise-all" class="headerlink" title="7.Promise.all()"></a>7.Promise.all()</h2><pre><code class="lang-js">let username = undefined;let flag = false;{  //替代Promise.all()的方案  setTimeout(() =&gt; {    username = &quot;admin&quot;;    doSth();  }, 1000);  setTimeout(() =&gt; {    flag = true;    doSth();  }, 2000);  function doSth() {    if(username &amp;&amp; flag) {      console.log(&quot;All is will.&quot;);      console.log(username);      console.log(flag);      //doSth    }  }}Promise.all([    new Promise((resolve) =&gt; {      setTimeout(() =&gt; {        username = &quot;admin&quot;;        resolve();      }, 1000);    }),    new Promise((resolve) =&gt; {      setTimeout(() =&gt; {        setTimeout(() =&gt; {          flag = true;          resolve();        })      }, 2000);    })]).then(() =&gt; {  console.log(&quot;All is will&quot;);  console.log(username);  console.log(flag);})</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>Runoob，JavaScript Promise，<a href="https://www.runoob.com/js/js-promise.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-promise.html</a></li><li>JAVASCRIPT.INFO，Promise，<a href="https://zh.javascript.info/promise-basics" target="_blank" rel="noopener">https://zh.javascript.info/promise-basics</a></li><li>JAVASCRIPT.INFO，Promise chain，<a href="https://zh.javascript.info/promise-chaining" target="_blank" rel="noopener">https://zh.javascript.info/promise-chaining</a></li><li>MDN Web Docs，Promise，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li><li>MDN Web Docs， Promise.prototype.the()，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのPromise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript Note 2022.09.01</title>
      <link href="2022/09/01/JavaScript-Note-2022-09-01/"/>
      <url>2022/09/01/JavaScript-Note-2022-09-01/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于变量提升以及“栈内存与堆内存”的那些事</p></blockquote><a id="more"></a><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="lang-javascript">var val = 12;function fun1(){  console.log(val);//undefined  var val = 20;  console.log(val);//20}fun1();</code></pre><p>JS执行过程：</p><ol><li>test.js文件嵌入到html文件中，则它本身相当于一个匿名(anonymous)函数。</li><li>浏览器读取test.js文件，开始尝试解析JS代码。</li><li>浏览器解析JS代码时，提供一个运行环境，称为<strong>全局作用域</strong>，包含<strong>全局栈内存</strong>与<strong>全局堆内存</strong>。</li><li>全局作用域出现后，（全局JS代码执行前）进行全局作用域的变量提升：<ol><li>全局变量val由var声明，所以现在（代码还未执行）它就已经被声明了，值默认为undefined。</li><li>全局函数fun1被声明，且被定义（将字符串”console.log(val);…”赋值给它）。</li></ol></li><li>全局作用域变量提升后，执行全局作用域的代码：<ol><li>为全局变量val赋值为12.</li><li>执行函数fun1。<ol><li>浏览器解析函数fun1代码时，提供函数<strong>fun1作用域</strong>，包含<strong>fun1栈内存</strong>与<strong>fun1堆内存</strong>。</li><li>fun1作用域出现后，（fun1函数JS代码执行前）进行fun1作用域的变量提升：<ol><li>局部变量val由var声明，所以现在（代码还未执行）它就已经被声明了。</li></ol></li><li>fun1作用域变量提升后，执行fun1作用域的代码：<ol><li>输出局部变量val（此时值为undefined）。</li><li>为局部变量val赋值为20。</li><li>输出局部变量val（此时值为20）。</li></ol></li></ol></li></ol></li></ol><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/1全局变量提升.png" alt="1全局变量提升"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/2执行全局代码第一句.png" alt="2执行全局代码第一句"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/3执行全局代码第二句.png" alt="3执行全局代码第二句"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/4fun1局部变量提升.png" alt="4fun1局部变量提升"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/5执行fun1代码第一句.png" alt="5执行fun1代码第一句"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/6执行fun1代码第一句结果.png" alt="6执行fun1代码第一句结果"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/7执行fun1代码第二句.png" alt="7执行fun1代码第二句"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/8执行fun1代码第三句.png" alt="8执行fun1代码第三句"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/9执行fun1代码第三句结果.png" alt="9执行fun1代码第三句结果"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/10fun1执行完毕.png" alt="10fun1执行完毕"></p><p><img src="/2022/09/01/JavaScript-Note-2022-09-01/11script执行完毕.png" alt="11script执行完毕"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのNote </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECS + Tinyproxy =&gt; static IP proxy</title>
      <link href="2022/08/02/ECS-Tinyproxy-static-IP-proxy/"/>
      <url>2022/08/02/ECS-Tinyproxy-static-IP-proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在云服务器（ECS）上开启Tinyproxy，为本地计算机做IP代理服务器。</p></blockquote><a id="more"></a><ol><li>云服务器下载Tinyproxy并修改配置，开放安全组端口。</li><li>本地开启代理。</li></ol><p><img src="/2022/08/02/ECS-Tinyproxy-static-IP-proxy/ECS+tinyproxy.png" alt="本地开启代理"></p><p><img src="/2022/08/02/ECS-Tinyproxy-static-IP-proxy/staticIPproxy.png" alt="效果"></p>]]></content>
      
      
      
        <tags>
            
            <tag> ECS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>From jQuery to MVVM &amp; virtual DOM</title>
      <link href="2022/06/11/From-jQuery-to-MVVM-virtual-DOM/"/>
      <url>2022/06/11/From-jQuery-to-MVVM-virtual-DOM/</url>
      
        <content type="html"><![CDATA[<blockquote><p>MVVM模式是因何而生的？Virtual DOM是什么？</p></blockquote><a id="more"></a><h2 id="JavaScript操作DOM"><a href="#JavaScript操作DOM" class="headerlink" title="JavaScript操作DOM"></a>JavaScript操作DOM</h2><pre><code class="lang-html">&lt;div id=&quot;js&quot;&gt;  &lt;h2&gt;JavaScript&lt;/h2&gt;  &lt;p&gt;Hello, &lt;span class=&quot;name&quot;&gt;Bart&lt;/span&gt;!&lt;/p&gt;  &lt;p&gt;You are &lt;span class=&quot;age&quot;&gt;12&lt;/span&gt;.&lt;/p&gt;  &lt;button onclick=&quot;JSModify()&quot;&gt;修改&lt;/button&gt;&lt;/div&gt;&lt;script&gt;    let name = &quot;Jessica&quot;;    let age = 33;    function JSModify(){      document.getElementById(&quot;js&quot;)          .getElementsByClassName(&quot;name&quot;)[0].innerText = name;      document.getElementById(&quot;js&quot;)          .getElementsByClassName(&quot;age&quot;)[0].innerText = age;    }&lt;/script&gt;</code></pre><h2 id="jQuery操作DOM"><a href="#jQuery操作DOM" class="headerlink" title="jQuery操作DOM"></a>jQuery操作DOM</h2><p>JavaScript是一个操作DOM的工具，jQuery让这个工具变得更好用。</p><p>假设DOM是一颗子弹，那么可以认为<code>JavaScript</code>是一把枪，用<code>JavaScript</code>这把枪发射<code>DOM</code>这颗子弹时声音太大，这是一个弊端（会引起敌人的注意），于是诞生了<code>jQuery</code>这样的消音器。<code>jQuery</code>没有创造出新的东西，但它让<code>JavaScript</code>更好用了。</p><pre><code class="lang-html">&lt;div id=&quot;jQ&quot;&gt;  &lt;h2&gt;jQuery&lt;/h2&gt;  &lt;p&gt;Hello, &lt;span class=&quot;name&quot;&gt;Bart&lt;/span&gt;!&lt;/p&gt;  &lt;p&gt;You are &lt;span class=&quot;age&quot;&gt;12&lt;/span&gt;.&lt;/p&gt;  &lt;button onclick=&quot;jQModify()&quot;&gt;修改&lt;/button&gt;&lt;/div&gt;&lt;script src=&quot;../js/jquery-3.5.1.js&quot;&gt;&lt;/script&gt;&lt;script&gt;  let name = &quot;Jessica&quot;;  let age = 33;  function jQModify(){      $(&quot;#jQ .name:first&quot;).text(name);      $(&quot;#jQ .age:first&quot;).text(age);  }&lt;/script&gt;</code></pre><h2 id="MVVM操作DOM"><a href="#MVVM操作DOM" class="headerlink" title="MVVM操作DOM"></a>MVVM操作DOM</h2><p>总结业务需求：数据(Model)发生了改变，视图(View)跟着改变。</p><p>前面两种方式都是，当数据(Model)发生变化时，<strong>手动</strong>操作DOM，改变视图(View)。</p><p>而通过业务需求可知，如果能做一个东西使得数据(Model)与视图(View)两者进行绑定，那么当一者更新了，另一者就跟着<strong>自动</strong>更新了，就<strong>省去了手动操作DOM</strong>的过程。</p><p>MVVM模式应运而生：设计一个ViewModel将Model与View进行绑定，当数据(Model)发生变化时，不再手动操作DOM，而是其自动修改DOM。</p><p>如此一来，把开发人员从<strong>“操作DOM”这一复杂繁琐的工作</strong>中拯救出来。</p><pre><code class="lang-html">&lt;div id=&quot;app&quot;&gt;  &lt;h2&gt;MVVM&lt;/h2&gt;  &lt;p&gt;Hello, &lt;span id=&quot;name&quot;&gt;{{name}}&lt;/span&gt;!&lt;/p&gt;  &lt;p&gt;You are &lt;span id=&quot;age&quot;&gt;{{age}}&lt;/span&gt;.&lt;/p&gt;  &lt;button @click=&quot;VueModify&quot;&gt;修改&lt;/button&gt;&lt;/div&gt;&lt;script src=&#39;../js/vue.js&#39;&gt;&lt;/script&gt;&lt;script&gt;  let name = &quot;Jessica&quot;;  let age = 33;  const app = new Vue({    el: &quot;#app&quot;,    data: {      name: &quot;Bart&quot;,       age: 12    },    methods: {      VueModify(){        this.name = name;        this.age = age;      }    }  });&lt;/script&gt;</code></pre><h2 id="补充：Virtual-DOM"><a href="#补充：Virtual-DOM" class="headerlink" title="补充：Virtual DOM"></a>补充：Virtual DOM</h2><p>当数据(Model)发生变化时：</p><ul><li>MVVM模式大大简化了操作DOM(来改变视图View)这一工作</li><li>另外还有一种简化操作DOM(来改变视图View)的方法，那就是：用<strong>模板引擎重新渲染整个视图</strong>替换旧视图</li></ul><p>（这里具体如何实现我不理解）</p><p>但重新构建一整个DOM Tree会很慢，而<strong>Virtual DOM</strong>解决了这一问题。</p><p>Virtual DOM 是位于 JS 与 DOM 之间的一个过渡，Virtual DOM 算法步骤如下：</p><ol><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了</li></ol><p>这样一来实现了用<strong>操作 JS 对象</strong>来替代<strong>操作DOM</strong>，会快很多。</p><p>参考链接：</p><p>[1] Liao Xue-Feng, MVVM[EB/OL]. <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072</a></p><p>[2] livoras, How to implement a Virtual DOM algorithm[EB/OL]. <a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/13</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> FE Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于浏览器渲染网页的细节</title>
      <link href="2022/04/04/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%86%E8%8A%82/"/>
      <url>2022/04/04/%E5%85%B3%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个网站通常遇到的问题有：资源加载缓慢、首次渲染时等待不重要文件的下载、无样式内容的闪烁等等。为了避免这些问题，我们需要了解浏览器渲染一个典型网页的生命周期。</p></blockquote><a id="more"></a><h1 id="DOM-Document-Object-Model"><a href="#DOM-Document-Object-Model" class="headerlink" title="DOM(Document Object Model)"></a>DOM(Document Object Model)</h1><ol><li><p>浏览器阅读HTML代码的时候，每遇到一个HTML element（诸如<code>html</code>、<code>body</code>、<code>div</code>等等）都会创建一个（被称为Node的）JavaScript对象（即该对象是Node类的实例），最终所有的HTML element被转换为JavaScript对象。</p><ul><li>不同的HTML element对应的Node对象创建自不同的类：<ul><li>div =&gt; HTMLDivElement =&gt; HTMLElement =&gt; Element =&gt; Node =&gt; EventTarget</li><li>script =&gt; HTMLScriptElement =&gt; HTMLElement =&gt; Element =&gt; Node =&gt; EventTarget</li></ul></li></ul></li><li><p>从HTML文档创建了node objects后，浏览器用这些node objects创建出一个树形结构，称为DOM Tree。</p><ul><li><p>DOM node 不一定非得是 HTML element，像comments、attribute、text（注释、属性、文本）虽然不是HTML element，但它们是DOM Tree 上独立的node。</p><p>（补充：HTML tag 里的 attribute 对应 node object 的 properties，例如<code>&lt;body id=&#39;1&#39;&gt;something&lt;/body&gt;</code> 有 <code>document.body.id=&#39;2&#39;</code>）</p></li></ul></li><li><p>JavaScript不认识DOM，因为DOM并不属于JS规范，而是high-level <strong>Web API</strong>。</p></li></ol><h1 id="CSSOM-Cascading-SS-OM"><a href="#CSSOM-Cascading-SS-OM" class="headerlink" title="CSSOM(Cascading SS OM)"></a>CSSOM(Cascading SS OM)</h1><ol><li>style priority：<code>external/embedded/inline(developer)</code> &gt; <code>user agent stylesheet(browser)</code> &gt; <code>W3C CSS standard(W3C document)</code></li><li>DOM 中，那些不会被打印到屏幕上的 elements，如<code>&lt;meta&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;title&gt;</code>等，不会出现了CSSOM里。但<code>display:none</code>的elements出现在CSSOM里，不出现在Render Tree里。</li></ol><h1 id="Render-Tree"><a href="#Render-Tree" class="headerlink" title="Render Tree"></a>Render Tree</h1><ol><li>DOM Tree + CSSOM Tree =&gt; Render Tree. 渲染树建立之前不会有任何东西被打印到屏幕上。</li><li>DOM Tree 是 incrementally 更新的，CSSOM Tree 是按“单”(sheet)更新的，Tender Tree 是随 DOM Tree incrementally 更新而 incrementally 更新的。</li><li>DOM Tree 与 CSSOM Tree 的建立是<strong>并发</strong>的。因为共用主线程，所以<strong>不并行</strong>。</li></ol><h1 id="Critical-Rendering-Path"><a href="#Critical-Rendering-Path" class="headerlink" title="Critical Rendering Path"></a>Critical Rendering Path</h1><ol><li>网页被加载，浏览器读取HTML创建DOM Tree，处理CSS(inline/embedded/external)创建CSSOM Tree，合成Render Tree。</li><li>针对Render Tree上每一个独立节点，创建layout(size of each node in pixels and position)。</li><li>为每一个<strong>elements</strong> (<em>or a sub-tree</em>) in the Render-Tree 创建一个图层，首先，用不同的线程在各自的图层里paint。这个过程称为光栅化<strong>rasterization</strong>。</li><li>将所有的图层组合(composit)起来，绘制在屏幕上。绘制的时候，每个图层又被分成许多片(tiles)，可以保证reflow与repaint更高效。</li></ol><p><img src="/2022/04/04/关于浏览器渲染网页的细节/criticalRenderingPath.png" alt="critical rendering path"></p><h1 id="HTML-parsing"><a href="#HTML-parsing" class="headerlink" title="HTML parsing"></a>HTML parsing</h1><ol><li><p>浏览器请求网页，服务器收到请求，开始发送HTML文本。浏览器收到文档中的前几行后就开始解析HTML，伴随着解析，<strong>逐步地</strong>(<strong>incrementally</strong>)建立DOM Tree，每次向DOM Tree 添加一个node。</p><p>这样不需要非得等整个HTML文档加载完毕再解析，提高效率。</p><p>如果网络很慢的话，第一次收到的HTML文本解析完，创建完DOM Tree、Render Tree，绘制在屏幕上，此时可能还未收到第二份数据。</p><p>即 HTML parsing 可以按字节处理(process content one byte at a time)。</p></li></ol><h1 id="CSS-parsing"><a href="#CSS-parsing" class="headerlink" title="CSS parsing"></a>CSS parsing</h1><ol><li>CSS parsing 不像 HTML parsing 那样可以按字节处理，因为后面的规则可能覆盖前面的规则。如果像 HTML parsing 那样处理，会频繁地发生reflow与repaint，尤其是因为CSS是级联的(cascading)，影响显得更大。</li><li>每次解析完一整个 stylesheet 才去更新 CSSOM Tree。CSSOM Tree 一旦更新完毕，随即 Render Tree 更新完毕， 随即渲染在屏幕上。</li><li>像“<strong>外部资源的请求</strong>”、“<strong>JS与用户交互</strong>”等事件是明显耗时的，HTML parsing 要等待这些事件所以称为“被阻塞”。而纵使CSS parsing 与 HTML parsing共用主线程，CSS parsing时，HTML parsing需要等待其完成，但这一过程由CPU在一瞬间完成，无所谓“等待”，称不上“阻塞”。（阻塞通常是ms级的或肉眼可见的等待）</li><li>外部CSS的加载(load/download)会阻塞Render Tree的建立，从<strong>关键渲染路径</strong>来看，纵使此时DOM Tree仍在更新，但Render Tree的更新停止了，自然不会有后续的layout与paint，此时屏幕上不会有任何东西被打印，直至CSS加载完。加载完后瞬间解析完成Render Tree的更新，计算layout，完成paint。</li><li>浏览器遇到内部CSS(embedded / inline)，会立即解析，完成Render Tree的更新，计算layout，完成paint。</li><li>script可以使用ansyc、defer属性来避免阻塞HTML parsing，CSS可以设置media来避免阻塞渲染，像<code>media=&#39;print&#39;</code>浏览器可以等待打印页面时再加载该css。</li></ol><h1 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h1><ol><li>在遇到一个新的CSS之前，Render Tree 随 DOM Tree 逐步(incremental)更新而更新，并且计算layout而后完成paint（由此可见<strong>paint也是incremental的</strong>，只不过大部分网站努力做了性能优化，使这一过程难以靠肉眼分辨）。</li><li>某时刻遇到一个新的CSS，其加载阻塞了Render Tree的更新，即阻塞了关键渲染路径，此时页面停止paint。</li><li>CSS加载完成时，瞬间解析，更新Render Tree，计算layout，完成paint，发生<strong>Flash of Unstyled Content</strong>(<em>FOUC</em>)，一定有repaint，可能有reflow。这即是建议<strong>将CSS前置于head标签内</strong>的原因（避免FOUC）。</li><li>遇到两个连续的script时，按理说应该等第一个执行完再下载第二个，但是浏览器做了优化，允许同时下载多个script，但是仍然保证执行顺序是出现顺序而非加载完成的顺序。</li></ol><h1 id="DOMContentLoaded"><a href="#DOMContentLoaded" class="headerlink" title="DOMContentLoaded"></a>DOMContentLoaded</h1><ol><li>DOM Tree构建完成时触发DOMContentLoaded事件，此时外部资源（诸如CSS、image）可能还未加载完。但是，大部分浏览器做了优化，他们等外部CSS加载完解析完即CSSOM Tree构建完才去触发DOMContentLoaded事件。</li><li>普通script（ansyc / defer不普通）会阻塞HTML parsing，自然延迟DOMContentLoaded事件的触发。而CSS阻塞普通script，也间接延迟了DOMContentLoaded事件的触发。</li></ol><h1 id="Performance-metrics"><a href="#Performance-metrics" class="headerlink" title="Performance metrics"></a>Performance metrics</h1><h2 id="FP-First-Paint"><a href="#FP-First-Paint" class="headerlink" title="FP(First Paint)"></a>FP(First Paint)</h2><h2 id="FCP-First-Contentful-Paint"><a href="#FCP-First-Contentful-Paint" class="headerlink" title="FCP(First Contentful Paint)"></a>FCP(First Contentful Paint)</h2><h2 id="FMP-first-meaningful-paint"><a href="#FMP-first-meaningful-paint" class="headerlink" title="FMP(first meaningful paint)"></a>FMP(first meaningful paint)</h2><h2 id="LCP-Largest-Contentful-Paint"><a href="#LCP-Largest-Contentful-Paint" class="headerlink" title="LCP(Largest Contentful Paint)"></a>LCP(Largest Contentful Paint)</h2><h2 id="DLC-DOMContentLoaded"><a href="#DLC-DOMContentLoaded" class="headerlink" title="DLC(DOMContentLoaded)"></a>DLC(DOMContentLoaded)</h2>]]></content>
      
      
      
        <tags>
            
            <tag> FE Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bilibiliClickProgressBar development process</title>
      <link href="2022/03/01/bilibiliClickProgressBar-development-process/"/>
      <url>2022/03/01/bilibiliClickProgressBar-development-process/</url>
      
        <content type="html"><![CDATA[<h1 id="bilibiliClickProgressBar-开发过程"><a href="#bilibiliClickProgressBar-开发过程" class="headerlink" title="bilibiliClickProgressBar 开发过程"></a>bilibiliClickProgressBar 开发过程</h1><h2 id="1-创建右键菜单"><a href="#1-创建右键菜单" class="headerlink" title="1.创建右键菜单"></a>1.创建右键菜单</h2><p>background.js中，当扩展(Extension)首次安装、升级，或chrome升级时，创建右键菜单。</p><pre><code class="lang-javascript">chrome.runtime.onInstalled.addListener(() =&gt; {  chrome.contextMenus.create({    &quot;id&quot;: &quot;addTimeTag&quot;,    &quot;title&quot;: &quot;添加时间标签&quot;,    &quot;contexts&quot;: [&quot;page&quot;],    &quot;documentUrlPatterns&quot;: [&quot;*://*.bilibili.com/*&quot;]  });});</code></pre><a id="more"></a><p>在background.js中监听右键菜单的点击，若所点击的选项是我们所创建的那个，则通知content script完成“添加时间标签”的功能。</p><pre><code class="lang-javascript">chrome.contextMenus.onClicked.addListener(function (data) {  if(data.menuItemId === &quot;addTimeTag&quot;) {    //后台脚本可以访问所有WebExtension JavaScript APIS，但是他们不能直接访问网页的内容(而 content script 可以)    // console.log(window);//undefined    callContentScript({info: &quot;background: addTimeTag&quot;}, function (res) {      console.log(res);      let notifyOptions = {        type: &quot;basic&quot;,        title: &quot;B站小助手&quot;,        iconUrl: &quot;whiteIcon.png&quot;,        message: &quot;时间标签添加成功！&quot;,        silent: true      };      chrome.notifications.create(new Date().getTime() + &quot;AddSucceedNotify&quot;, notifyOptions);    })  }})function callContentScript(msg, callback) {  chrome.tabs.query({    active: true,    currentWindow: true  }, (tabs) =&gt; {    chrome.tabs.sendMessage(tabs[0].id, msg, res =&gt; {      callback(res);    })  });}</code></pre><p>注意<code>contextMenus.onClicked</code>的监听不要写在<code>runtime.onInstalled</code>的监听里。</p><p>之所以background.js不能做而交给content script做，是因为后台脚本可以访问所有WebExtension JavaScript APIS，但是他们不能直接访问网页的内容。</p><p><img src="/2022/03/01/bilibiliClickProgressBar-development-process/BCPW.png" alt="theory"></p><h2 id="2-实现添加时间标签功能"><a href="#2-实现添加时间标签功能" class="headerlink" title="2.实现添加时间标签功能"></a>2.实现添加时间标签功能</h2><p>content script监听来自background的消息，若收到“添加时间标签”的消息，则收集Web Page上与时间标签相关的信息，将信息存入<code>chrome.storage</code>中。</p><pre><code class="lang-javascript">chrome.runtime.onMessage.addListener((request, sender, sendResponse) =&gt; {  if(request.info === &quot;background: addTimeTag&quot;) {    addTimeTag();  } else if(request.info === &quot;popup: jump&quot;) {    jump(request.url, request.pNum, request.tNum);  }  sendResponse(&quot;(content script)我滴任务完成了，啊哈哈哈~&quot;);})function addTimeTag() {  let url = &quot;https://www.bilibili.com&quot; + window.location.pathname;  let pNum = getPNum();  let title = getTitle();  let tNum = getTNum();  let timeTag1 = {&quot;url&quot;: url, &quot;pNum&quot;: pNum, &quot;title&quot;: title, &quot;tNum&quot;: tNum};  chrome.storage.sync.get([&#39;timeTagList&#39;], function(result) {    if(JSON.stringify(result) === &quot;{}&quot;) {      chrome.storage.sync.set({&quot;timeTagList&quot;: [timeTag1]}, function () {        console.log(&quot;Storage finished!&quot;);      })    } else {      result.timeTagList.push(timeTag1);      chrome.storage.sync.set({&quot;timeTagList&quot;: result.timeTagList}, function () {        console.log(&quot;Storage finished!&quot;);      })    }  });  // content scripts 得到的是一个“干净的DOM视图”， 意味着：  //   1. content scripts 不能看见页面脚本定义的javascript 变量。  //   2. 如果一个页面脚本重定义了一个DOM内置属性，content scripts将获取到这个属性的原始版本，而不是重定义版本。  // console.log(window.player);//undefined  // useWebPagesVarsFunctions();}function getPNum() {  let pNum = 1;  let div = document.getElementById(&quot;multi_page&quot;);  if(div != null) {    let lis = div.getElementsByClassName(&quot;on&quot;);    if(lis.length &gt; 0) {      let ps = lis[0].getElementsByClassName(&quot;page-num&quot;);      if(ps.length &gt; 0) {        let p = ps[0].innerHTML;        pNum = parseInt(p.substr(1));      } else {        let spans = lis[0].getElementsByTagName(&quot;span&quot;);        if(spans.length === 1) pNum = parseInt(spans[0].innerHTML);      }    }  }  return pNum;}function getTitle() {  let title;  let ts = document.getElementsByClassName(&quot;tit&quot;);  if(ts.length &gt; 0) title = ts[0].innerHTML;  else {    ts = document.getElementById(&quot;player-title&quot;);    if(ts) title = ts.innerHTML;  }  return title;}function getTNum() {  let tNum;  let times = document.getElementsByClassName(&#39;bilibili-player-video-time-now&#39;);  if(times.length &gt; 0) {    let tStr = times[0].innerHTML;    tNum = hms2s(tStr);  } else {    times = document.getElementsByClassName(&#39;squirtle-video-time-now&#39;);    if(times.length &gt; 0) {      let tStr = times[0].innerHTML;      tNum = hms2s(tStr);    }  }  return tNum;}//function: hh:mm:ss to secondfunction hms2s(hms) {  let s = hms.split(&quot;:&quot;);  let ans = 0;  for(let i = s.length - 1, j = 1; i &gt;= 0; --i, j *= 60) {    ans += parseInt(s[i]) * j;  }  return ans;}</code></pre><h2 id="3-点开popup取storage数据"><a href="#3-点开popup取storage数据" class="headerlink" title="3.点开popup取storage数据"></a>3.点开popup取storage数据</h2><pre><code class="lang-javascript">chrome.storage.sync.get([&#39;timeTagList&#39;], function(result) {  if(result !== undefined &amp;&amp; result.timeTagList !== undefined) {    for(let i = 0; i &lt; result.timeTagList.length; ++i) {      let li = document.createElement(&quot;li&quot;);      li.setAttribute(&quot;class&quot;, &quot;tag&quot;);      let stdTNum = s2hms(result.timeTagList[i].tNum);      liAppendSpan(li, &quot;url&quot;, result.timeTagList[i].url);      liAppendSpan(li, &quot;title&quot;, result.timeTagList[i].title);      liAppendSpan(li, &quot;pNum&quot;, result.timeTagList[i].pNum);      liAppendSpan(li, &quot;tNum&quot;, stdTNum);      liAppendSpan(li, &quot;close&quot;, &#39;&lt;img src=&quot;close.svg&quot;/&gt;&#39;);      ls.appendChild(li);    }  }  console.log(&quot;Caught you! timeTag.&quot;)});function liAppendSpan(li, name, value) {  let span = document.createElement(&quot;span&quot;);  span.setAttribute(&quot;class&quot;, name);  if(name === &quot;url&quot;) span.style.display = &quot;none&quot;;  span.innerHTML = value;  li.appendChild(span);}function callContentScript(msg, callback) {  chrome.tabs.query({    active: true,    currentWindow: true  }, (tabs) =&gt; {    chrome.tabs.sendMessage(tabs[0].id, msg, res =&gt; {      callback(res);    })  });}//function: second to hh:mm:ssfunction s2hms(ss) {  let s = parseInt(ss);  let hour = 0;  let min = 0;  let result;  if(s &gt;= 3600) {    hour = Math.floor(s / 3600);    min = Math.floor((s - hour * 3600) / 60);    s = (s - hour * 3600) % 60;    result = `${hour.toString().padStart(2,&#39;0&#39;)}:${min.toString().padStart(2,&#39;0&#39;)}:${s.toString().padStart(2,&#39;0&#39;)}`;  }else if (s &lt; 3600 &amp;&amp; s &gt;= 60) {    min = Math.floor(s / 60);    s = s % 60;    result = `${min.toString().padStart(2,&#39;0&#39;)}:${s.toString().padStart(2,&#39;0&#39;)}`;  }else {    result = `${min.toString().padStart(2,&#39;0&#39;)}:${s.toString().padStart(2,&#39;0&#39;)}`;  }  return result;}//function: hh:mm:ss to secondfunction hms2s(hms) {  let s = hms.split(&quot;:&quot;);  let ans = 0;  for(let i = s.length - 1, j = 1; i &gt;= 0; --i, j *= 60) {    ans += parseInt(s[i]) * j;  }  return ans;}</code></pre><h2 id="4-点击时间标签通知跳转"><a href="#4-点击时间标签通知跳转" class="headerlink" title="4.点击时间标签通知跳转"></a>4.点击时间标签通知跳转</h2><pre><code class="lang-javascript">let ls = document.getElementById(&quot;list&quot;);ls.onclick = function (e) {  e = e || window.event;  let url, pNum, tNum;  if(e.target.parentNode.className === &quot;close&quot;) {    url = e.target.parentNode.parentNode.getElementsByClassName(&quot;url&quot;)[0].innerHTML;    pNum = e.target.parentNode.parentNode.getElementsByClassName(&quot;pNum&quot;)[0].innerHTML;    tNum = e.target.parentNode.parentNode.getElementsByClassName(&quot;tNum&quot;)[0].innerHTML;    console.log(url + &quot; &quot; + pNum + &quot; &quot; + tNum);  }  if(e.target.className === &quot;tag&quot;) {    url = e.target.getElementsByClassName(&quot;url&quot;)[0].innerHTML;    pNum = e.target.getElementsByClassName(&quot;pNum&quot;)[0].innerHTML;    tNum = e.target.getElementsByClassName(&quot;tNum&quot;)[0].innerHTML;  }  else if(e.target.className === &quot;pNum&quot; ||      e.target.className === &quot;tNum&quot; ||      e.target.className === &quot;title&quot; ||      e.target.className === &quot;close&quot;) {    url = e.target.parentNode.getElementsByClassName(&quot;url&quot;)[0].innerHTML;    pNum = e.target.parentNode.getElementsByClassName(&quot;pNum&quot;)[0].innerHTML;    tNum = e.target.parentNode.getElementsByClassName(&quot;tNum&quot;)[0].innerHTML;  }  if(e.target.parentNode.className === &quot;close&quot; || e.target.className === &quot;close&quot;) {    chrome.storage.sync.get([&#39;timeTagList&#39;], function(result) {      if(result !== undefined &amp;&amp; result.timeTagList !== undefined) {        for (let i = 0; i &lt; result.timeTagList.length; i++) {          if(result.timeTagList[i].url === url &amp;&amp;              result.timeTagList[i].pNum.toString() === pNum &amp;&amp;              result.timeTagList[i].tNum.toString() === hms2s(tNum).toString()) {            result.timeTagList.splice(i, 1);            break;          }        }        chrome.storage.sync.set({&quot;timeTagList&quot;: result.timeTagList}, function () {          console.log(&quot;Remove Storage finished!&quot;);          if(e.target.parentNode.className === &quot;close&quot;) e.target.parentNode.parentNode.remove();          else e.target.parentNode.remove();        })      }    });  } else {    callContentScript({url, pNum, tNum: hms2s(tNum), info: &quot;popup: jump&quot;}, function (res) {      console.log(res);    })  }}</code></pre><h2 id="5-实现跳转"><a href="#5-实现跳转" class="headerlink" title="5.实现跳转"></a>5.实现跳转</h2><pre><code class="lang-javascript">function jump(url, pNum, tNum) {  let nowUrl = window.location.protocol + &quot;//&quot; + window.location.hostname + window.location.pathname;  let nowPNum = getPNum();  if(nowUrl === url &amp;&amp; nowPNum.toString() === pNum.toString() &amp;&amp; window.location.pathname.substr(1, 7) !== &quot;bangumi&quot;) {    sessionStorage.setItem(&quot;nextTime&quot;, tNum.toString());    useWebPagesVarsFunctions();  } else {    window.location.href = url + &quot;?p=&quot; + pNum + &quot;&amp;t=&quot; + tNum;  }}// content scripts 是运行在一个被称为 isolated world 的运行环境里，// 和页面上的脚本互不干扰，因为不在一个运行环境里，所以也无法调用页面上脚本定义的方法// 以下方法可以解决function useWebPagesVarsFunctions() {  let s = document.createElement(&#39;script&#39;);  s.src = chrome.runtime.getURL(&#39;webPage.js&#39;);  s.onload = function() {    this.remove();  };  (document.head || document.documentElement).appendChild(s);}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Chrome Extensions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My way to upload my project to github</title>
      <link href="2020/11/27/My-way-to-upload-my-project-to-github/"/>
      <url>2020/11/27/My-way-to-upload-my-project-to-github/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Upload my project to github</p></blockquote><a id="more"></a><ol><li>在github上new一个仓库，main分支重命名为master</li><li>在本地想上传的项目目录下执行<code>git init</code></li></ol><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/Web_FrontEnd/ChromeExtensions/Bilbili_Time_ALL (master)$ git remote add github https://github.com/fireworks99/bilibiliTime.gitsj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git fetch github masterremote: Enumerating objects: 4, done.remote: Counting objects: 100% (4/4), done.remote: Compressing objects: 100% (3/3), done.remote: Total 4 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (4/4), done.From github.com:fireworks99/RGB_Hexa * branch            main       -&gt; FETCH_HEAD * [new branch]      main       -&gt; github/mainsj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git merge github/mastersj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        RGB_Hexa/nothing added to commit but untracked files present (use &quot;git add&quot; to track)sj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   README.mdUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        RGB_Hexa/        demo/no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git add .sj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   README.md        new file:   RGB_Hexa/background.js        new file:   RGB_Hexa/images/icon128.png        new file:   RGB_Hexa/images/icon16.png        new file:   RGB_Hexa/images/icon32.png        new file:   RGB_Hexa/images/icon48.png        new file:   RGB_Hexa/manifest.json        new file:   RGB_Hexa/popup.html        new file:   RGB_Hexa/popup.js        new file:   demo/initial.png        new file:   demo/load_extension.png        new file:   demo/test1.png        new file:   demo/test2.pngsj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git commit -m&#39;First upload&#39;[master a4a81ef] First upload 13 files changed, 152 insertions(+) create mode 100644 RGB_Hexa/background.js create mode 100644 RGB_Hexa/images/icon128.png create mode 100644 RGB_Hexa/images/icon16.png create mode 100644 RGB_Hexa/images/icon32.png create mode 100644 RGB_Hexa/images/icon48.png create mode 100644 RGB_Hexa/manifest.json create mode 100644 RGB_Hexa/popup.html create mode 100644 RGB_Hexa/popup.js create mode 100644 demo/initial.png create mode 100644 demo/load_extension.png create mode 100644 demo/test1.png create mode 100644 demo/test2.png sj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git pushfatal: No configured push destination.Either specify the URL from the command-line or configure a remote repository using    git remote add &lt;name&gt; &lt;url&gt;and then push using the remote name    git push &lt;name&gt;sj@fireworks99 MINGW64 /e/FrontEnd/chrome_extensions (master)$ git push github masterEnumerating objects: 20, done.Counting objects: 100% (20/20), done.Delta compression using up to 4 threadsCompressing objects: 100% (18/18), done.Writing objects: 100% (18/18), 95.40 KiB | 734.00 KiB/s, done.Total 18 (delta 0), reused 0 (delta 0)To github.com:fireworks99/RGB_Hexa.git   812d257..a4a81ef  master -&gt; master</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Recursive least square</title>
      <link href="2020/11/17/Recursive-least-square/"/>
      <url>2020/11/17/Recursive-least-square/</url>
      
        <content type="html"><![CDATA[<p>给定一组样本点：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><script type="math/tex">x_1</script></th><th style="text-align:center"><script type="math/tex">x_2</script></th><th style="text-align:center">…</th><th style="text-align:center"><script type="math/tex">x_k</script></th></tr></thead><tbody><tr><td style="text-align:center"><script type="math/tex">y_1</script></td><td style="text-align:center"><script type="math/tex">y_2</script></td><td style="text-align:center">…</td><td style="text-align:center"><script type="math/tex">y_k</script></td></tr></tbody></table></div><p>求拟合函数 <script type="math/tex">G(x)</script> 使得 <script type="math/tex">\sum_{i=1}^k (G(x_i)-y_i)^2</script> 取最小值。</p><a id="more"></a><p>设 <script type="math/tex">\phi_0, \phi_1, ... \phi_n</script> 是n+1个线性无关的连续函数，<script type="math/tex">G_n</script> 是由  <script type="math/tex">\phi_i(i=0,1...n)</script> 的所有线性组合构成的集合，记 <script type="math/tex">G_n = span \{ \phi_0, \phi_1,...,\phi_n \}</script> ，<script type="math/tex">G(x)\in G_n</script> 。</p><p>将 <script type="math/tex">G(x)</script> 写成矩阵的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}G(x_1)\\ G(x_2) \\ \vdots\\ G(x_k)\end{bmatrix}=\begin{bmatrix} \phi_0(x_1) & \phi_1(x_1) & \cdots & \phi_n(x_1) \\ \phi_0(x_2) & \phi_1(x_2) & \cdots & \phi_n(x_2) \\\vdots & \vdots & \vdots & \vdots \\\phi_0(x_k) & \phi_1(x_k) & \cdots & \phi_n(x_k) \\\end{bmatrix}\begin{bmatrix}a_0\\ a_1 \\ \vdots\\ a_n\end{bmatrix}</script><p>所求的 <script type="math/tex">G(x)</script> 满足如下条件 ：</p><script type="math/tex; mode=display">\sum_{i=0}^k(\sum_{j=0}^na_j\phi_j(x_i)-y_i)\phi_h(x_i)=0,h=0,1,...,n.</script><p>以矩阵形式表示如下：</p><p>为<script type="math/tex">\Phi_k^T(\Phi_kA_k-Y_k)=0</script> (<script type="math/tex">A_k</script>表示有 <script type="math/tex">k</script> 组样本点时对应的 <script type="math/tex">n+1</script> 个参数)</p><p>其中，<script type="math/tex">\Phi_k=\begin{bmatrix} \phi_0(x_1) & \phi_1(x_1) & \cdots & \phi_n(x_1) \\ \phi_0(x_2) & \phi_1(x_2) & \cdots & \phi_n(x_2) \\\vdots & \vdots & \vdots & \vdots \\\phi_0(x_k) & \phi_1(x_k) & \cdots & \phi_n(x_k) \\\end{bmatrix}</script>， <script type="math/tex">A_k=\begin{bmatrix}a_0\\ a_1 \\ \vdots\\ a_n\end{bmatrix}</script>，<script type="math/tex">Y_k=\begin{bmatrix}y_1\\ y_2 \\ \vdots\\ y_k\end{bmatrix}</script>，</p><script type="math/tex; mode=display">A_k=(\Phi_k^T\Phi_k)^{-1}\Phi_k^TY_k</script><p>目标：<script type="math/tex">A_{k+1}= H(A_k)</script> </p><p>对 <script type="math/tex">A_k=(\Phi_k^T\Phi_k)^{-1}\Phi_k^TY_k</script> 进行推导变换：</p><p>令 <script type="math/tex">P_k=\Phi_k^T\Phi_k</script> ，<script type="math/tex">Q_k=\Phi_k^TY_k</script> ，则 <script type="math/tex">A_k=P_k^{-1}Q_k</script> .</p><script type="math/tex; mode=display">P_k=\Phi_k^T\Phi_k=\begin{bmatrix} \phi_0(x_1) & \phi_0(x_2) & \cdots & \phi_0(x_k) \\ \phi_1(x_1) & \phi_1(x_2) & \cdots & \phi_1(x_k) \\\vdots & \vdots & \vdots & \vdots \\\phi_n(x_1) & \phi_n(x_2) & \cdots & \phi_n(x_k) \\\end{bmatrix}\begin{bmatrix} \phi_0(x_1) & \phi_1(x_1) & \cdots & \phi_n(x_1) \\ \phi_0(x_2) & \phi_1(x_2) & \cdots & \phi_n(x_2) \\\vdots & \vdots & \vdots & \vdots \\\phi_0(x_k) & \phi_1(x_k) & \cdots & \phi_n(x_k) \\\end{bmatrix}</script><p>令 <script type="math/tex">\overrightarrow{\phi_i}^T=\begin{bmatrix}\phi_0(x_i)\\ \phi_1(x_i) \\ \vdots\\ \phi_n(x_i)\end{bmatrix},i=1,...k</script>. </p><script type="math/tex; mode=display">P_k=\Phi_k^T\Phi_k=\begin{bmatrix}\overrightarrow{\phi_1}^T & \overrightarrow{\phi_2}^T &\cdots & \overrightarrow{\phi_k}^T \\\end{bmatrix}\begin{bmatrix}\overrightarrow{\phi_1} \\\overrightarrow{\phi_2} \\ \vdots\\\overrightarrow{\phi_k}\end{bmatrix}=\sum_{i=1}^k\overrightarrow{\phi_i}^T\overrightarrow{\phi_i}=\sum_{i=1}^{k-1}\overrightarrow{\phi_i}^T\overrightarrow{\phi_i}+\overrightarrow{\phi_k}^T\overrightarrow{\phi_k}=P_{k-1}+\overrightarrow{\phi_k}^T\overrightarrow{\phi_k}</script><script type="math/tex; mode=display">Q_k=\Phi_k^TY_k=\begin{bmatrix}\overrightarrow{\phi_1}^T & \overrightarrow{\phi_2}^T &\cdots & \overrightarrow{\phi_k}^T \\\end{bmatrix}\begin{bmatrix}y_1\\ y_2 \\ \vdots\\ y_k\end{bmatrix}=\sum_{i=1}^k\overrightarrow{\phi_i}^Ty_i=\sum_{i=1}^{k-1}\overrightarrow{\phi_i}^Ty_i+\overrightarrow{\phi_k}^Ty_k=Q_{k-1}+\overrightarrow{\phi_k}^Ty_k</script><script type="math/tex; mode=display">A_{k-1}=P_{k-1}^{-1}Q_{k-1}         =>        Q_{k-1}=P_{k-1}A_{k-1}</script><script type="math/tex; mode=display">A_k=P_k^{-1}Q_k</script><script type="math/tex; mode=display">=P_k^{-1}(Q_{k-1}+\overrightarrow{\phi_k}^Ty_k)</script><script type="math/tex; mode=display">=P_k^{-1}(P_{k-1}A_{k-1}+\overrightarrow{\phi_k}^Ty_k)</script><script type="math/tex; mode=display">=P_k^{-1}[(P_k-\overrightarrow{\phi_k}^T\overrightarrow{\phi_k})A_{k-1}+\overrightarrow{\phi_k}^Ty_k]</script><script type="math/tex; mode=display">=A_{k-1}-P_k^{-1}\overrightarrow{\phi_k}^T\overrightarrow{\phi_k}A_{k-1}+P_k^{-1}\overrightarrow{\phi_k}^Ty_k</script><pre><code class="lang-matlab">function Ak = nafit1( A, x, xk, yk, m)Pni=inv(P(x,m));phik2phik=phi(xk,m);phi2y=phiy(xk, yk, m);Ak=A&#39;-Pni*phik2phik*A&#39;+Pni*phi2y;Ak=fliplr(Ak&#39;);endfunction phi2y = phiy(xk, yk, m)phi2y = zeros(m+1, 1);for i=0:m    phi2y(i+1)=xk^i*yk;endendfunction phik2phik = phi(xk, m)phik2phik = zeros(m+1, m+1);for i=0:m    for j=0:m        phik2phik(i+1,j+1)=xk^(i+j);    endendendfunction Pres = P(x, m)len = length(x);Pres = zeros(m+1, m+1);for k=1:len    Pres = Pres + phi(x(k), m);endend</code></pre><blockquote><p>代码的使用方法</p></blockquote><p><img src="/2020/11/17/Recursive-least-square/method.png" alt="code"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Browser&#39;s render engine and block</title>
      <link href="2020/11/03/Browser-s-render-engine-and-block/"/>
      <url>2020/11/03/Browser-s-render-engine-and-block/</url>
      
        <content type="html"><![CDATA[<h2 id="一、浏览器渲染引擎"><a href="#一、浏览器渲染引擎" class="headerlink" title="一、浏览器渲染引擎"></a>一、浏览器渲染引擎</h2><h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><ul><li><p>一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块</p><ul><li>HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树。</li><li>CSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施</li><li>Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果。</li><li>布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型</li><li>绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果</li></ul><a id="more"></a><blockquote><p>备注：文档对象模型（Document Object Model，简称DOM）</p></blockquote></li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><ul><li>浏览器渲染页面的整个过程：浏览器会从上到下解析文档。<ol><li>遇见 HTML 标记，调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。</li><li>遇见 style/link 标记 调用解析器 处理 CSS 标记并构建 CSS样式树。</li><li>遇见 script 标记 调用 javascript解析器 处理script标记，绑定事件、修改DOM树/CSS树 等</li><li>将 DOM树 与 CSS树 合并成一个渲染树。</li><li>根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖图形库）。</li><li>将各个节点绘制到屏幕上。</li></ol></li></ul><blockquote><p>以上这些模块依赖很多其他的基础模块，包括要使用到网络 存储 2D/3D图像 音频视频解码器 和 图片解码器。<br>所以渲染引擎中还会包括如何使用这些依赖模块的部分。</p></blockquote><h2 id="二、阻塞渲染"><a href="#二、阻塞渲染" class="headerlink" title="二、阻塞渲染"></a>二、阻塞渲染</h2><h4 id="1-关于css阻塞："><a href="#1-关于css阻塞：" class="headerlink" title="1.关于css阻塞："></a>1.关于css阻塞：</h4><p>声明：只有link引入的外部css才能够产生阻塞。<br>1.style标签中的样式：<br>    (1). 由html解析器进行解析；<br>    (2). 不阻塞浏览器渲染（可能会产生“闪屏现象”）；<br>    (3). 不阻塞DOM解析；</p><p>2.link引入的外部css样式（推荐使用的方式）：<br>    (1). 由CSS解析器进行解析。<br>    (2). 阻塞浏览器渲染(可以利用这种阻塞避免“闪屏现象”)。<br>    (3). 阻塞其后面的js语句的执行：</p><ul><li>原因 : 如果后面 JS 的内容是获取元素的样式 , 例如宽高等CSS控制的属性，如果不等样式解析完毕，后面的  JS 就获得了错误的信息。</li><li>但现代浏览器越发注重用户体验，对于WebKit内核的浏览器而言，仅当脚本尝试访问样式的属性，或可能受未加载的样式表影响时才会阻塞JS脚本</li></ul><p>​    (4). 不阻塞DOM的解析：</p><ul><li>原因 : DOM解析和CSS解析是两个并行的进程。浏览器解析Dom生成Dom Tree，解析CSS生成CSS Tree，最终组成 Render Tree，再渲染页面。</li></ul><p>3.优化核心理念：尽可能快的提高外部css加载速度<br>    (1).使用CDN节点进行外部资源加速。<br>    (2).对css进行压缩(利用打包工具，比如webpack,gulp等)。<br>    (3).减少http请求数，将多个css文件合并。<br>    (4).优化样式表的代码</p><h4 id="2-关于js阻塞："><a href="#2-关于js阻塞：" class="headerlink" title="2.关于js阻塞："></a>2.关于js阻塞：</h4><p>1.阻塞DOM解析:<br>        原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，<br>        那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write<br>        这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM。<br>2.阻塞页面渲染:<br>        原因：js中也可以给DOM设置样式，浏览器同样等该脚本执行完毕，再继续干活，避免做无用功。<br>3.阻塞后续js的执行:<br>    原因：维护依赖关系，例如：必须先引入jQuery再引入bootstrap</p><h4 id="3-备注"><a href="#3-备注" class="headerlink" title="3.备注"></a>3.备注</h4><p>【备注1】：css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析。</p><p>【备注2】：无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）<br>            原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，<br>            无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，<br>            由浏览器自己协调。这种做法效率很高。</p><p>【备注3】：WebKit 和 Firefox 都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会解析文档的其余部分，<br>          找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，<br>          从而提高总体速度。请注意，预解析器不会修改 DOM 树</p><blockquote><p>在上述的过程中，网页在加载和渲染过程中会触发“DOMContentloaded”和“onload”事件<br>分别是在DOM树构建（解析）完成之后，以及DOM树构建完并且网页所依赖的资源都加载完之后</p></blockquote><ul><li>上面介绍的是一个完整的渲染过程，但现代网页很多都是动态的，这意味着在渲染完成之后，由于网页的动画或者用户的交互，浏览器其实一直在不停地重复执行渲染过程，（重绘重排）。以上的数字表示的是基本顺序，这不是严格一致的，这个过程可能重复也可能交叉。</li></ul><p><img src="/2020/11/03/Browser-s-render-engine-and-block/block.png" alt="block"></p>]]></content>
      
      
      
        <tags>
            
            <tag> FE Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Browser&#39;s function and components</title>
      <link href="2020/11/03/Browser-s-function-and-components/"/>
      <url>2020/11/03/Browser-s-function-and-components/</url>
      
        <content type="html"><![CDATA[<h2 id="一-浏览器应该有的功能"><a href="#一-浏览器应该有的功能" class="headerlink" title="一.浏览器应该有的功能"></a>一.浏览器应该有的功能</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>​    浏览器通过网络模块来下载各式各样的资源，例如html文本；javascript代码；样式表；图片；音视频文件等。<br>​    网络部分本质上十分重要，因为它耗时长，而且需要安全访问互联网上的资源。</p><a id="more"></a><h3 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h3><p>​    从网络下载，或者本地获取到的资源需要有高效的机制来管理它们。<br>​    例如如何避免重复下载，资源如何缓存等</p><h3 id="网页浏览"><a href="#网页浏览" class="headerlink" title="网页浏览"></a>网页浏览</h3><p>​    这是浏览器的核心也是最基本的功能，最重要的功能。<br>​    如何将资源转变为可视化的结果。<br>​<br>多页面管理<br>插件与管理<br>账户和同步<br>安全机制<br>开发者工具<br>…<br>…</p><p>浏览器的主要功能总结起来就是一句话:将用户输入的url转变成可视化的图像。<br>        1.从url到DOM树<br>        2.从DOM树到可视化图像<br>        这两个过程之间的关系并没有那么明确,我们可以统称这两个过程为页面的<strong>渲染</strong></p><h2 id="二-浏览器的内核-渲染引擎"><a href="#二-浏览器的内核-渲染引擎" class="headerlink" title="二.浏览器的内核(渲染引擎)"></a>二.浏览器的内核(渲染引擎)</h2><p>在浏览器中有一个最重要的模块，它主要的作用是将页面转变为可视化的图像结果。<br>这个模块就是浏览器内核，通常它也被称为渲染引擎。</p><p>IE—————&gt;Trident</p><p>Safari———&gt;WebKit<br>    WebKit本身主要是由两个引擎构成的，<br>        一个正是渲染引擎“WebCore”，<br>        另一个则是javascript解释引擎“JSCore”，<br>        它们均是从KDE的渲染引擎KHTML及javascript解释引擎KJS衍生而来。</p><p>Chrome———&gt;WebKit的分支引擎——-&gt;Blink<br>     在13年发布的Chrome 28.0.1469.0版本开始，Chrome放弃Chromium引擎转<br>     而使用最新的Blink引擎（基于WebKit2——苹果公司于2010年推出的新的WebKit引擎），<br>     Blink对比上一代的引擎精简了代码、改善了DOM框架，也提升了安全性。</p><p>Opera<br>    旧版Opera 4至6版本 :Elektra排版引擎<br>    Opera7.0    :Presto渲染引擎<br>    Opera在2013年2月宣布放弃Presto:<br>                采用Chromium引擎;<br>                又转为Blink引擎;</p><p>Firefox———&gt;Gecko</p><h2 id="三-进程与线程"><a href="#三-进程与线程" class="headerlink" title="三.进程与线程"></a>三.进程与线程</h2><blockquote><p>进程: 程序的一次执行, 它占有一片独有的内存空间.是操作系统执行的基本单元。<br>    一个进程中至少有一个运行的线程: 主线程,  进程启动后自动创建<br>    一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的<br>    一个进程内的数据可以供其中的多个线程直接共享，多个进程之间的数据是不能直接共享的</p><p>线程：是进程内的一个独立执行单元,是CPU调度的最小单元。程序运行的基本单元<br>    线程池(thread pool): 保存多个线程对象的容器, 实现线程对象的反复利用</p><p>JS引擎是单线程运行的！（回忆事件轮询机制）</p></blockquote><h2 id="四-现代浏览器：多进程、多线程模型"><a href="#四-现代浏览器：多进程、多线程模型" class="headerlink" title="四.现代浏览器：多进程、多线程模型"></a>四.现代浏览器：多进程、多线程模型</h2><h3 id="1-不堪回首的过去"><a href="#1-不堪回首的过去" class="headerlink" title="1.不堪回首的过去:"></a>1.不堪回首的过去:</h3><blockquote><p>当你通过浏览器打开很多页面的时候,如果其中一个页面不响应了或者崩溃了,<br>那么随之而来的将会是更不幸的事情,你打开的所有页面都会得不到响应,<br>最让人不能忍受的是,其中的一些页面可能还包含了未保存或者未发送的信息。</p></blockquote><h3 id="2-浏览器产商如何解决"><a href="#2-浏览器产商如何解决" class="headerlink" title="2.浏览器产商如何解决"></a>2.浏览器产商如何解决</h3><p>​    采用多进程模型,该模型可以带来的好处<br>​    ①.避免因单个页面的不响应或者崩溃影响整个浏览器的稳定性<br>​    ②.当第三方插件崩溃时,也不会影响整个浏览器的稳定性<br>​    ③.安全<br>​    </p><h3 id="3-浏览器到底有些什么进程"><a href="#3-浏览器到底有些什么进程" class="headerlink" title="3.浏览器到底有些什么进程"></a>3.浏览器到底有些什么进程</h3><p>​    ①.Browser进程:<br>​        浏览器的主进程,负责浏览器界面的显示,和各个页面的管理,<br>​        浏览器中所有其他类型进程的祖先,负责其他进程的的创建和销毁<br>​        它有且只有一个!!!!!<br>​    ②.Renderer进程:<br>​        网页渲染进程,负责页面的渲染,可以有多个<br>​        当然渲染进程的数量不一定等于你开打网页的个数<br>​    ③.各种插件进程<br>​    ④.GPU进程<br>​    移动设备的浏览器可能不太一样:<br>​        Android不支持插件,所以就没有插件进程<br>​        GPU演化成了Browser进程的一个线程<br>​        Renderer进程演化成了操作系统的一个服务进程,它仍然是独立的</p><h3 id="4-每个进程内部又有很多线程"><a href="#4-每个进程内部又有很多线程" class="headerlink" title="4.每个进程内部又有很多线程"></a>4.每个进程内部又有很多线程</h3><p>​    多线程的目的主要是保持用户界面的高度响应<br>​    例如:为了不让Browser进程的UI线程被其他耗时的操作(数据库读写,本地文件读写)所阻塞,<br>​            那么我们就把这些操作放到分线程中去处理<br>​        在Renderer进程中,为了不让其他操作阻止渲染线程的高速执行,我们通常会将渲染过程【管线化】,<br>​            利用计算机的多核优势,让渲染的不同阶段在不同的线程中执行</p><p>​    </p>]]></content>
      
      
      
        <tags>
            
            <tag> FE Performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>overflow meet flex</title>
      <link href="2020/10/14/Web-overflow-meet-flex/"/>
      <url>2020/10/14/Web-overflow-meet-flex/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>如果将某个盒子设为伸缩盒(display: flex;)，要注意子元素及其后代元素是否有white-space样式修饰，它会影响flex，使其失效，甚至使子元素溢出父元素。</p></blockquote><a id="more"></a><h3 id="Test-Code"><a href="#Test-Code" class="headerlink" title="Test Code"></a>Test Code</h3><pre><code class="lang-html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;test&lt;/title&gt;  &lt;style&gt;    #father {      width: 200px;      height: 200px;      background: #bfa;      display: flex;    }    #son {      flex: 3;      height: 90%;      background: orange;    }    #daughter {      flex: 7;      height: 90%;      background: pink;    }    pre {      background: green;      /*overflow: auto;*/    }    .test {      /*white-space: pre;*/      /*white-space: nowrap;*/      white-space: normal;      /*white-space: pre-wrap;*/    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;father&quot;&gt;    &lt;div id=&quot;daughter&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;son&quot;&gt;&lt;!--      &lt;pre&gt;--&gt;&lt;!--        overflow--&gt;&lt;!--      &lt;/pre&gt;--&gt;      &lt;div class=&quot;test&quot;&gt;        responsibility        overflow overflow overflow      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p><img src="/2020/10/14/Web-overflow-meet-flex/initial.png" alt="正常时"></p><p><img src="/2020/10/14/Web-overflow-meet-flex/flex_disabled.png" alt="flex失效"></p><p><img src="/2020/10/14/Web-overflow-meet-flex/even_overflow.png" alt="甚至子元素溢出父元素"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Web杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2020/10/09/Git/"/>
      <url>2020/10/09/Git/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Learn about git(VCS)</p></blockquote><a id="more"></a><h1 id="1-建Git仓库"><a href="#1-建Git仓库" class="headerlink" title="1.建Git仓库"></a>1.建Git仓库</h1><h2 id="1-把已有的项目纳入Git管理"><a href="#1-把已有的项目纳入Git管理" class="headerlink" title="1.把已有的项目纳入Git管理"></a>1.把已有的项目纳入Git管理</h2><pre><code class="lang-shell">$ cd 项目代码所在文件夹$ git init</code></pre><h2 id="2-新建的项目直接用Git管理"><a href="#2-新建的项目直接用Git管理" class="headerlink" title="2.新建的项目直接用Git管理"></a>2.新建的项目直接用Git管理</h2><pre><code class="lang-shell">$ cd 某个文件夹$ git init your_project #会在当前路径下创建和项目名称同名的文件夹$ cd your_project</code></pre><h3 id="第1种方案的结果"><a href="#第1种方案的结果" class="headerlink" title="第1种方案的结果"></a>第1种方案的结果</h3><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ cd Project_code_is_there/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there$ git initInitialized empty Git repository in E:/FrontEnd/LearnGit/Project_code_is_there/.git/</code></pre><blockquote><p>初始化后有一个隐藏文件 <code>.git</code></p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 4drwxr-xr-x 1 sj 197121 0 10月  6 21:11 ./drwxr-xr-x 1 sj 197121 0 10月  6 21:08 ../drwxr-xr-x 1 sj 197121 0 10月  6 21:11 .git/</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --global --listuser.name=fireworks99user.email=2639237361@qq.comcore.autocrlf=false</code></pre><h3 id="local-config与global-config不同时，local-config优先级更高。"><a href="#local-config与global-config不同时，local-config优先级更高。" class="headerlink" title="local config与global config不同时，local config优先级更高。"></a>local config与global config不同时，local config优先级更高。</h3><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --global --listuser.name=fireworks99user.email=2639237361@qq.comcore.autocrlf=falsesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --local --listcore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=truesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --local user.name &#39;fire&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --local user.email &#39;zhaobaole520@gmail.com&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --local --listcore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=trueuser.name=fireuser.email=zhaobaole520@gmail.comsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ pwd/e/FrontEnd/LearnGit/Project_code_is_theresj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cd ../virtual/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/virtual$ lsreadme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/virtual$ cd ../Project_code_is_there/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp ../virtual/readme.mdcp: missing destination file operand after &#39;../virtual/readme.md&#39;Try &#39;cp --help&#39; for more information.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp ../virtual/readme.md .sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add readme&#39;On branch masterInitial commitUntracked files:        readme.mdnothing added to commit but untracked files presentsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add readme&#39;[master (root-commit) 6debbe5] Add readme 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit 6debbe50d02c2054b7693addc100a685c6a97cb9 (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readme</code></pre><h1 id="2-Git的工作方式"><a href="#2-Git的工作方式" class="headerlink" title="2.Git的工作方式"></a>2.Git的工作方式</h1><p><img src="/2020/10/09/Git/1.png" alt="git"></p><blockquote><p>git工作方式：在工作目录中修改的东西，最好通过git add先提交到暂存区，如果差不多了再通过git commit进行统一的提交。</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp ../virtual/index.html index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp -r ../virtual/images .sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        images/        index.htmlnothing added to commit but untracked files present (use &quot;git add&quot; to track)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add index.html imagessj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 21:55 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 21:55 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:55 images/-rw-r--r-- 1 sj 197121 2214 10月  6 21:54 index.html-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        new file:   images/gh-branch.png        new file:   images/gh-logo.png        new file:   index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        new file:   images/gh-branch.png        new file:   images/gh-logo.png        new file:   index.htmlUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        images/git.jpgsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add images/git.jpgsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        new file:   images/gh-branch.png        new file:   images/gh-logo.png        new file:   images/git.jpg        new file:   index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 21:55 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 21:59 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.html-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add index + logo&#39;[master 1a103f4] Add index + logo 4 files changed, 76 insertions(+) create mode 100644 images/gh-branch.png create mode 100644 images/gh-logo.png create mode 100644 images/git.jpg create mode 100644 index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit 1a103f45637ca22689a92a0f09ac438fcb327729 (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 21:55 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 22:01 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.html-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mdsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ mkdir stylessj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp ../virtual/styles/style.css  styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 22:02 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 22:01 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.html-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mddrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cd styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/styles (master)$ lsstyle.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/styles (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   ../index.htmlUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        ./no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/styles (master)$ cd ..sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 22:02 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 22:03 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.html-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mddrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   index.htmlUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        styles/no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add stylessj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        new file:   styles/style.cssChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.html        new file:   styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add style.css and modified index.html&#39;[master 887d452] Add style.css and modified index.html 2 files changed, 67 insertions(+) create mode 100644 styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit 887d45217f404f50ba646356b355ef7df842655a (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cp -r ../virtual/js/ .sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  6 22:07 ./drwxr-xr-x 1 sj 197121    0 10月  6 21:53 ../drwxr-xr-x 1 sj 197121    0 10月  6 22:06 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.htmldrwxr-xr-x 1 sj 197121    0 10月  6 22:07 js/-rw-r--r-- 1 sj 197121    0 10月  6 21:32 readme.mddrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        js/nothing added to commit but untracked files present (use &quot;git add&quot; to track)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add jssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit 887d45217f404f50ba646356b355ef7df842655a (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add js&#39;[master ddd14f3] Add js 1 file changed, 14 insertions(+) create mode 100644 js/script.jssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit ddd14f3a80df93e80982a3fd4791ec6cb193a50e (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readme</code></pre><h1 id="3-Git-文件重命名"><a href="#3-Git-文件重命名" class="headerlink" title="3.Git 文件重命名"></a>3.Git 文件重命名</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ mv readme.md readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        deleted:    readme.mdUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        readmeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rm readme.mdrm &#39;readme.md&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        renamed:    readme.md -&gt; readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git reset --hardHEAD is now at ddd14f3 Add jssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit ddd14f3a80df93e80982a3fd4791ec6cb193a50e (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git mv readme.md readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        renamed:    readme.md -&gt; readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  7 15:30 ./drwxr-xr-x 1 sj 197121    0 10月  7 15:26 ../drwxr-xr-x 1 sj 197121    0 10月  7 15:30 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.htmldrwxr-xr-x 1 sj 197121    0 10月  6 22:07 js/-rw-r--r-- 1 sj 197121    0 10月  7 15:29 readmedrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Move readme.md to readme&#39;[master d7cfccc] Move readme.md to readme 1 file changed, 0 insertions(+), 0 deletions(-) rename readme.md =&gt; readme (100%)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 15:30:54 2020 +0800    Move readme.md to readmecommit ddd14f3a80df93e80982a3fd4791ec6cb193a50eAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logo:...skipping...commit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 15:30:54 2020 +0800    Move readme.md to readmecommit ddd14f3a80df93e80982a3fd4791ec6cb193a50eAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlcommit 1a103f45637ca22689a92a0f09ac438fcb327729Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Add index + logocommit 6debbe50d02c2054b7693addc100a685c6a97cb9Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readme</code></pre><blockquote><p>原来的三步</p><p><code>mv readme.md readme</code></p><p><code>git add readme</code></p><p><code>git rm readme.md</code></p><p>只需要一步</p><p><code>git mv readme.md readme</code></p><p>命令<code>$ git reset --hard</code>：</p><p>有时候，进行了错误的提交，但是还没有push到远程分支，想要撤销本次提交，可以使用git reset –-soft/hard命令。<br>1、二者区别：</p><p>git reset –-soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可；<br>git reset -–hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，撤销的commit中所包含的更改被冲掉；</p></blockquote><h1 id="4-git-log的使用"><a href="#4-git-log的使用" class="headerlink" title="4.git log的使用"></a>4.git log的使用</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log --onelined7cfccc (HEAD -&gt; master) Move readme.md to readmeddd14f3 Add js887d452 Add style.css and modified index.html1a103f4 Add index + logo6debbe5 Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log -n4 --onelined7cfccc (HEAD -&gt; master) Move readme.md to readmeddd14f3 Add js887d452 Add style.css and modified index.html1a103f4 Add index + logosj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -v* master d7cfccc Move readme.md to readme# 新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数(branch)的 git checkout 命令：sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git checkout -b tempSwitched to a new branch &#39;temp&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ ls -altotal 13drwxr-xr-x 1 sj 197121    0 10月  7 16:06 ./drwxr-xr-x 1 sj 197121    0 10月  7 15:50 ../drwxr-xr-x 1 sj 197121    0 10月  7 16:07 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.htmldrwxr-xr-x 1 sj 197121    0 10月  6 22:07 js/-rw-r--r-- 1 sj 197121    9 10月  7 16:06 readmedrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ vi readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git commit -am&#39;Add modefied&#39;[temp b9229fb] Add modefied 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git branch -v  master d7cfccc Move readme.md to readme* temp   b9229fb Add modefied# git log 不加参数，只查看当前分支的信息sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git logcommit b9229fb1e4b5a6afafbc5da7701e803491e5ca93 (HEAD -&gt; temp)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 16:07:52 2020 +0800    Add modefiedcommit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 15:30:54 2020 +0800    Move readme.md to readmecommit ddd14f3a80df93e80982a3fd4791ec6cb193a50eAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.html# --all 查看所有分支sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git log --allcommit b9229fb1e4b5a6afafbc5da7701e803491e5ca93 (HEAD -&gt; temp)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 16:07:52 2020 +0800    Add modefiedcommit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 15:30:54 2020 +0800    Move readme.md to readmecommit ddd14f3a80df93e80982a3fd4791ec6cb193a50eAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git log --all --graph* commit b9229fb1e4b5a6afafbc5da7701e803491e5ca93 (HEAD -&gt; temp)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 16:07:52 2020 +0800||     Add modefied|* commit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 15:30:54 2020 +0800||     Move readme.md to readme|* commit ddd14f3a80df93e80982a3fd4791ec6cb193a50e| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:08:56 2020 +0800||     Add js|* commit 887d45217f404f50ba646356b355ef7df842655a| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:06:44 2020 +0800||     Add style.css and modified index.html|* commit 1a103f45637ca22689a92a0f09ac438fcb327729| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:01:32 2020 +0800||     Add index + logo|* commit 6debbe50d02c2054b7693addc100a685c6a97cb9  Author: fire &lt;zhaobaole520@gmail.com&gt;  Date:   Tue Oct 6 21:33:58 2020 +0800      Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ git log --oneline --all -n4 --graph* b9229fb (HEAD -&gt; temp) Add modefied* d7cfccc (master) Move readme.md to readme* ddd14f3 Add js* 887d452 Add style.css and modified index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (temp)$ gitk# 图形界面查看版本历史</code></pre><h1 id="5-探索-git目录"><a href="#5-探索-git目录" class="headerlink" title="5.探索.git目录"></a>5.探索.git目录</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  7 16:44 ./drwxr-xr-x 1 sj 197121    0 10月  7 16:39 ../drwxr-xr-x 1 sj 197121    0 10月  7 16:44 .git/drwxr-xr-x 1 sj 197121    0 10月  6 21:58 images/-rw-r--r-- 1 sj 197121 2260 10月  6 22:00 index.htmldrwxr-xr-x 1 sj 197121    0 10月  6 22:07 js/-rw-r--r-- 1 sj 197121    0 10月  7 16:44 readmedrwxr-xr-x 1 sj 197121    0 10月  6 22:03 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cd .git/# .git目录sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ ls -altotal 23drwxr-xr-x 1 sj 197121   0 10月  7 16:44 ./drwxr-xr-x 1 sj 197121   0 10月  7 16:44 ../-rw-r--r-- 1 sj 197121  13 10月  7 16:07 COMMIT_EDITMSG-rw-r--r-- 1 sj 197121 182 10月  6 21:25 config-rw-r--r-- 1 sj 197121  73 10月  6 21:11 description-rw-r--r-- 1 sj 197121 298 10月  7 16:28 gitk.cache-rw-r--r-- 1 sj 197121  23 10月  7 16:44 HEADdrwxr-xr-x 1 sj 197121   0 10月  6 21:11 hooks/-rw-r--r-- 1 sj 197121 722 10月  7 16:44 indexdrwxr-xr-x 1 sj 197121   0 10月  6 21:11 info/drwxr-xr-x 1 sj 197121   0 10月  6 21:33 logs/drwxr-xr-x 1 sj 197121   0 10月  7 16:07 objects/-rw-r--r-- 1 sj 197121  41 10月  7 15:29 ORIG_HEADdrwxr-xr-x 1 sj 197121   0 10月  6 21:11 refs/# HEAD是一个引用，指向 refs/heads/master# 说明当前Git仓库正在工作的分支是mastersj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ cat HEADref: refs/heads/mastersj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ git branch -av* master d7cfccc Move readme.md to readme  temp   b9229fb Add modefied# config配置文件，local&gt;global，所以这里记录了local的配置# 直接修改文件内容中user.name为fire1 与 命令$ git config --local user.name &#39;fire1&#39;是一样的sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ cat config[core]        repositoryformatversion = 0        filemode = false        bare = false        logallrefupdates = true        symlinks = false        ignorecase = true[user]        name = fire        email = zhaobaole520@gmail.comsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ cd refssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs (GIT_DIR!)$ ls -altotal 4drwxr-xr-x 1 sj 197121 0 10月  6 21:11 ./drwxr-xr-x 1 sj 197121 0 10月  7 16:44 ../drwxr-xr-x 1 sj 197121 0 10月  7 16:07 heads/drwxr-xr-x 1 sj 197121 0 10月  6 21:11 tags/# 一个项目里可以有很多tags，标签，又称“里程碑”sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs (GIT_DIR!)$ cd heads/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs/heads (GIT_DIR$ ls -altotal 2drwxr-xr-x 1 sj 197121  0 10月  7 16:07 ./drwxr-xr-x 1 sj 197121  0 10月  6 21:11 ../-rw-r--r-- 1 sj 197121 41 10月  7 15:30 master-rw-r--r-- 1 sj 197121 41 10月  7 16:07 tempsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs/heads (GIT_DIR!)$ cat masterd7cfccc0f65bbbe3d8c24a6f21838c772150060c# 上面的hash值代表git仓库存放的一个对象# $ git cat-file -t d7cfccc0f65bbbe3# 上述命令查看文件类型 -t(type) hash值只指出前面一小部分就行,只要这部分没有与其他对象前部分hash值重复。sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs/heads (GIT_DIR!)$ git cat-file -t d7cfccc0f65bbbe3commit# 是commit类型sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs/heads (GIT_DIR!)$ git branch -av* master d7cfccc Move readme.md to readme  temp   b9229fb Add modefied# 可见master指向了d7cfccc0f65bbbe3d8c24a6f21838c772150060c这个commit对象sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/refs (GIT_DIR!)$ cd ..sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git (GIT_DIR!)$ cd objects/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects (GIT_DIR!)$ ls -altotal 8drwxr-xr-x 1 sj 197121 0 10月  7 16:07 ./drwxr-xr-x 1 sj 197121 0 10月  7 16:44 ../drwxr-xr-x 1 sj 197121 0 10月  7 15:30 13/drwxr-xr-x 1 sj 197121 0 10月  6 22:01 1a/drwxr-xr-x 1 sj 197121 0 10月  6 21:55 1f/drwxr-xr-x 1 sj 197121 0 10月  6 21:33 23/drwxr-xr-x 1 sj 197121 0 10月  7 16:07 42/drwxr-xr-x 1 sj 197121 0 10月  6 21:32 4b/drwxr-xr-x 1 sj 197121 0 10月  6 22:06 50/drwxr-xr-x 1 sj 197121 0 10月  6 22:05 5c/drwxr-xr-x 1 sj 197121 0 10月  6 21:33 6d/drwxr-xr-x 1 sj 197121 0 10月  6 22:06 88/drwxr-xr-x 1 sj 197121 0 10月  6 22:08 97/drwxr-xr-x 1 sj 197121 0 10月  6 21:59 9c/drwxr-xr-x 1 sj 197121 0 10月  6 22:05 9d/drwxr-xr-x 1 sj 197121 0 10月  6 22:01 a0/drwxr-xr-x 1 sj 197121 0 10月  6 22:08 ae/drwxr-xr-x 1 sj 197121 0 10月  6 22:01 b0/drwxr-xr-x 1 sj 197121 0 10月  7 16:07 b9/drwxr-xr-x 1 sj 197121 0 10月  6 21:55 c2/drwxr-xr-x 1 sj 197121 0 10月  6 22:08 c5/drwxr-xr-x 1 sj 197121 0 10月  6 21:55 cb/drwxr-xr-x 1 sj 197121 0 10月  7 15:30 d7/drwxr-xr-x 1 sj 197121 0 10月  7 16:07 db/drwxr-xr-x 1 sj 197121 0 10月  6 22:08 dd/drwxr-xr-x 1 sj 197121 0 10月  6 22:06 de/drwxr-xr-x 1 sj 197121 0 10月  6 21:33 e6/drwxr-xr-x 1 sj 197121 0 10月  6 21:11 info/drwxr-xr-x 1 sj 197121 0 10月  6 21:11 pack/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects (GIT_DIR!)$ cd e6sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/e6 (GIT_DIR!)$ ls -altotal 5drwxr-xr-x 1 sj 197121  0 10月  6 21:33 ./drwxr-xr-x 1 sj 197121  0 10月  7 16:07 ../-r--r--r-- 1 sj 197121 15 10月  7 15:28 9de29bb2d1d6434b8b29ae775ad8c2e48c5391sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/e6 (GIT_DIR!)$ git cat-file -t e69de29bb2d1d6434b8b29ae775ad8c2e48c5391blob# 类型为blob：文件对象sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/e6 (GIT_DIR!)$ git cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391# -p 查看内容（这里没有输出，所以没有内容）sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/e6 (GIT_DIR!)$ cd ..sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects (GIT_DIR!)$ cd 13sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/13 (GIT_DIR!)$ ls -altotal 5drwxr-xr-x 1 sj 197121   0 10月  7 15:30 ./drwxr-xr-x 1 sj 197121   0 10月  7 16:07 ../-r--r--r-- 1 sj 197121 176 10月  7 15:30 78caffa8c4f214e537299288bc08d3a1defaa3sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/13 (GIT_DIR!)$ git cat-file -t 1378caffa8c4f214e537299288bc08d3a1defaa3tree# 类型为treesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there/.git/objects/13 (GIT_DIR!)$ git cat-file -p 1378caffa8c4f214e537299288bc08d3a1defaa3040000 tree a0cc15dc64dd3332ad023955f6f84c786ef3f507    images100644 blob 9dfbc09a91fdaad19875c1e359859438b16b4899    index.html040000 tree 978a2b1ba7c0f07f9758f234b0b7959fe31a2e93    js100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    readme040000 tree deca7330feed3ffb6a545bc41ca1b36a9660b3b6    styles</code></pre><h1 id="6-commit-tree-blob之间的关系"><a href="#6-commit-tree-blob之间的关系" class="headerlink" title="6.commit/tree/blob之间的关系"></a>6.commit/tree/blob之间的关系</h1><p><img src="/2020/10/09/Git/2.png" alt="relationship"></p><h1 id="7-小练习：数一数tree的个数"><a href="#7-小练习：数一数tree的个数" class="headerlink" title="7.小练习：数一数tree的个数"></a>7.小练习：数一数tree的个数</h1><p><img src="/2020/10/09/Git/3.png" alt="numbers of tree"></p><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ pwd/e/FrontEnd/LearnGitsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ git init watch_git_objectsInitialized empty Git repository in E:/FrontEnd/LearnGit/watch_git_objects/.git/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ cd watch_git_objects/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ ls -altotal 4drwxr-xr-x 1 sj 197121 0 10月  7 18:47 ./drwxr-xr-x 1 sj 197121 0 10月  7 18:47 ../drwxr-xr-x 1 sj 197121 0 10月  7 18:47 .git/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ mkdir doc# git并不理会空的文件夹sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use &quot;git add&quot; to track)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ cd docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects/doc (master)$ echo &quot;Hello, world!&quot; &gt; readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects/doc (master)$ cd ..sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git statusOn branch masterNo commits yetUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        doc/nothing added to commit but untracked files present (use &quot;git add&quot; to track)# doc尚未加入暂存区，.git/object目录下没有f(file)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ find .git/objects -type fsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git add docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git statusOn branch masterNo commits yetChanges to be committed:  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)        new file:   doc/readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ find .git/objects -type f.git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51bsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -t af5626b4a114blobsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -p af5626b4a114Hello, world!sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git commit -m&#39;Add readme&#39;[master (root-commit) c92b8bb] Add readme 1 file changed, 1 insertion(+) create mode 100644 doc/readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ find .git/objects -type f.git/objects/6c/c12deb1d5d15beaa283ce0c552c4710a3a2048.git/objects/8a/c93ed17177cbe3c263c29c877a93ffcbc4869b.git/objects/af/5626b4a114abcb82d63db7c8082c3c4756e51b.git/objects/c9/2b8bb5b4c6a713eeda0150d13c7e3c192830f9sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -t 6cc12deb1d5d15treesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -p 6cc12deb1d5d15040000 tree 8ac93ed17177cbe3c263c29c877a93ffcbc4869b    docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -t 8ac93ed17177cbe3ctreesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -p 8ac93ed17177cbe3c100644 blob af5626b4a114abcb82d63db7c8082c3c4756e51b    readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -t af5626b4a114blobsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -p af5626b4a114Hello, world!sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -t c92b8bb5b4c6a71commitsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git cat-file -p c92b8bb5b4c6a71tree 6cc12deb1d5d15beaa283ce0c552c4710a3a2048author fireworks99 &lt;2639237361@qq.com&gt; 1602068156 +0800committer fireworks99 &lt;2639237361@qq.com&gt; 1602068156 +0800Add readme</code></pre><h1 id="8-分离头指针"><a href="#8-分离头指针" class="headerlink" title="8.分离头指针"></a>8.分离头指针</h1><blockquote><p>分离头指针：(头指针HEAD未指向一个有名分支，或者说指向一个临时无名分支)</p><p>就像java一样，一个引用指向一个new出来的对象，这个对象只被这一个引用所指，当这个引用指向其他对象时，这个对象就被java的垃圾回收机制回收了。</p><p>所以当头指针指回有名分支时，要考虑要不要给刚才的无名分支起名字，起名字后就不会被回收了。</p></blockquote><pre><code class="lang-shell">$git checkout masterWarning: you are Leaving 1 commit behind, not connected to anyof your branches:    3d473ld Backgroud to greenIf you want to keep it by creating a new branch, this may be a good time to do so with:    git branch &lt;new-branch-name&gt; 3d4731dSwitched to branch &#39;master&#39;</code></pre><blockquote><p>头指针指向某个分支（中的某次提交——commit），所以本质上 HEAD-&gt;commit</p></blockquote><h1 id="9-删除分支"><a href="#9-删除分支" class="headerlink" title="9.删除分支"></a>9.删除分支</h1><p><code>$ git branch -d branchName</code>若不行且风险可控<code>$ git branch -D branchName</code></p><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git branch -av* master c92b8bb Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git checkout -b temporary c92b8bbSwitched to a new branch &#39;temporary&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (temporary)$ gitksj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (temporary)$ git branch -av  master    c92b8bb Add readme* temporary c92b8bb Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (temporary)$ git branch -d temporaryerror: Cannot delete branch &#39;temporary&#39; checked out at &#39;E:/FrontEnd/LearnGit/watch_git_objects&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (temporary)$ git checkout -b masterfatal: A branch named &#39;master&#39; already exists.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (temporary)$ git checkout masterSwitched to branch &#39;master&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git branch -d temporaryDeleted branch temporary (was c92b8bb).</code></pre><h1 id="10-修改commit的message"><a href="#10-修改commit的message" class="headerlink" title="10.修改commit的message"></a>10.修改commit的message</h1><blockquote><p>1.修改最新commit的message</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git log -1commit c92b8bb5b4c6a713eeda0150d13c7e3c192830f9 (HEAD -&gt; master)Author: fireworks99 &lt;2639237361@qq.com&gt;Date:   Wed Oct 7 18:55:56 2020 +0800    Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git commit --amend[master 2312de3] Add file readme Date: Wed Oct 7 18:55:56 2020 +0800 1 file changed, 1 insertion(+) create mode 100644 doc/readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/watch_git_objects (master)$ git log -1commit 2312de39f062b5bafc413578335241e7aac859bc (HEAD -&gt; master)Author: fireworks99 &lt;2639237361@qq.com&gt;Date:   Wed Oct 7 18:55:56 2020 +0800    Add file readme</code></pre><blockquote><p>2.修改之前commit的message</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master d7cfccc Move readme.md to readme  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log -3commit d7cfccc0f65bbbe3d8c24a6f21838c772150060c (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Wed Oct 7 15:30:54 2020 +0800    Move readme.md to readmecommit ddd14f3a80df93e80982a3fd4791ec6cb193a50eAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:08:56 2020 +0800    Add jscommit 887d45217f404f50ba646356b355ef7df842655aAuthor: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:06:44 2020 +0800    Add style.css and modified index.html# 假设要修改 &#39;Add js&#39; 为 &#39;Add a js&#39;# 这里的hash要填其parent的hashsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rebase -i 887d45217f404f50[detached HEAD 4678291] Add a js Date: Tue Oct 6 22:08:56 2020 +0800 1 file changed, 14 insertions(+) create mode 100644 js/script.jsSuccessfully rebased and updated refs/heads/master.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master 9ee801d Move readme.md to readme  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log -n3 --graph* commit 9ee801d013de3f1c10c711d18077bdf629194502 (HEAD -&gt; master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 15:30:54 2020 +0800||     Move readme.md to readme|* commit 4678291e3b7c7ee4f2e23946269593f21ffc3b2a| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:08:56 2020 +0800||     Add a js|* commit 887d45217f404f50ba646356b355ef7df842655a| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:06:44 2020 +0800||     Add style.css and modified index.html</code></pre><p><img src="/2020/10/09/Git/4.png" alt="modify message"></p><p><img src="/2020/10/09/Git/5.png" alt="modify message"></p><p><img src="/2020/10/09/Git/6.png" alt="modify message"></p><blockquote><p>上述为交互页面</p></blockquote><h1 id="11-合并连续多个commit为一个"><a href="#11-合并连续多个commit为一个" class="headerlink" title="11.合并连续多个commit为一个"></a>11.合并连续多个commit为一个</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master 9ee801d Move readme.md to readme  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log --graph* commit 9ee801d013de3f1c10c711d18077bdf629194502 (HEAD -&gt; master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 15:30:54 2020 +0800||     Move readme.md to readme|* commit 4678291e3b7c7ee4f2e23946269593f21ffc3b2a| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:08:56 2020 +0800||     Add a js|* commit 887d45217f404f50ba646356b355ef7df842655a| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:06:44 2020 +0800||     Add style.css and modified index.html|* commit 1a103f45637ca22689a92a0f09ac438fcb327729| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:01:32 2020 +0800||     Add index + logo|* commit 6debbe50d02c2054b7693addc100a685c6a97cb9  Author: fire &lt;zhaobaole520@gmail.com&gt;  Date:   Tue Oct 6 21:33:58 2020 +0800      Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rebase -i 6debbe50d02c2054b7693a[detached HEAD 42b3280] Create a complate web page Date: Tue Oct 6 22:01:32 2020 +0800 6 files changed, 157 insertions(+) create mode 100644 images/gh-branch.png create mode 100644 images/gh-logo.png create mode 100644 images/git.jpg create mode 100644 index.html create mode 100644 js/script.js create mode 100644 styles/style.cssSuccessfully rebased and updated refs/heads/master.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log --graph* commit c1cf8ef864de629cc9b77353dbe683b575563155 (HEAD -&gt; master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 15:30:54 2020 +0800||     Move readme.md to readme|* commit 42b328065b9dd94a4c3242cc81d301342ccdf317| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:01:32 2020 +0800||     Create a complate web page||     Add index + logo||     Add style.css and modified index.html||     Add a js|* commit 6debbe50d02c2054b7693addc100a685c6a97cb9  Author: fire &lt;zhaobaole520@gmail.com&gt;  Date:   Tue Oct 6 21:33:58 2020 +0800      Add readme</code></pre><p><img src="/2020/10/09/Git/7.png" alt="merge"></p><blockquote><p>合并前三个，必须pick其中一个</p></blockquote><p><img src="/2020/10/09/Git/8.png" alt="merge"></p><p><img src="/2020/10/09/Git/9.png" alt="merge"></p><h1 id="12-合并不连续多个commit"><a href="#12-合并不连续多个commit" class="headerlink" title="12.合并不连续多个commit"></a>12.合并不连续多个commit</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log --graph* commit c1cf8ef864de629cc9b77353dbe683b575563155 (HEAD -&gt; master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Wed Oct 7 15:30:54 2020 +0800||     Move readme.md to readme|* commit 42b328065b9dd94a4c3242cc81d301342ccdf317| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:01:32 2020 +0800||     Create a complate web page||     Add index + logo||     Add style.css and modified index.html||     Add a js|* commit 6debbe50d02c2054b7693addc100a685c6a97cb9  Author: fire &lt;zhaobaole520@gmail.com&gt;  Date:   Tue Oct 6 21:33:58 2020 +0800      Add readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rebase -i 6debbe50d02c2054binteractive rebase in progress; onto 6debbe5Last command done (1 command done):   pick 6debbe5Next commands to do (2 remaining commands):   squash c1cf8ef Move readme.md to readme   pick 42b3280 Create a complate web pageYou are currently rebasing branch &#39;master&#39; on &#39;6debbe5&#39;.nothing to commit, working tree cleanThe previous cherry-pick is now empty, possibly due to conflict resolution.If you wish to commit it anyway, use:    git commit --allow-emptyOtherwise, please use &#39;git reset&#39;Could not apply 6debbe5...sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master|REBASE-i 1/3)$ git statusinteractive rebase in progress; onto 6debbe5Last command done (1 command done):   pick 6debbe5Next commands to do (2 remaining commands):   squash c1cf8ef Move readme.md to readme   pick 42b3280 Create a complate web page  (use &quot;git rebase --edit-todo&quot; to view and edit)You are currently rebasing branch &#39;master&#39; on &#39;6debbe5&#39;.  (all conflicts fixed: run &quot;git rebase --continue&quot;)nothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master|REBASE-i 1/3)$ git rebase --continue[detached HEAD bdbfdd9] Add readme.md Date: Tue Oct 6 21:33:58 2020 +0800 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 readmeSuccessfully rebased and updated refs/heads/master.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git log --graph* commit b53ed32f94f5c09c3639c1163fa7ddfcda07dd60 (HEAD -&gt; master)| Author: fire &lt;zhaobaole520@gmail.com&gt;| Date:   Tue Oct 6 22:01:32 2020 +0800||     Create a complate web page||     Add index + logo||     Add style.css and modified index.html||     Add a js|* commit bdbfdd9713d8c61dc27b95110650d38113e37e99  Author: fire &lt;zhaobaole520@gmail.com&gt;  Date:   Tue Oct 6 21:33:58 2020 +0800      Add readme.md      Add readme      Move readme.md to readme</code></pre><p><img src="/2020/10/09/Git/10.png" alt="merge"></p><p><img src="/2020/10/09/Git/11.png" alt="merge"></p><h1 id="13-比较暂存区和HEAD两者所含文件的差异"><a href="#13-比较暂存区和HEAD两者所含文件的差异" class="headerlink" title="13.比较暂存区和HEAD两者所含文件的差异"></a>13.比较暂存区和HEAD两者所含文件的差异</h1><blockquote><p>命令：<code>$ git diff --cached</code>比较 <strong>暂存区</strong>与<strong>HEAD所含文件</strong>的差异</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masternothing to commit, working tree clean# 说明工作区、暂存区、HEAD是一致的sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff --cacheddiff --git a/index.html b/index.htmlindex 9dfbc09..d9cd4db 100644--- a/index.html+++ b/index.html@@ -49,6 +49,7 @@                &lt;div class=&quot;panel&quot;&gt;                        &lt;h3&gt;Once You Become a Contributor...&lt;/h3&gt;                        &lt;ol&gt;+                         &lt;li&gt;add&lt;/li&gt;                          &lt;li&gt;Clone Admin&#39;s (Your Partner) New Repository&lt;/li&gt;                          &lt;li&gt;Create a New Branch for this Repository&lt;/li&gt;                          &lt;li&gt;Make Some Change to Your New Branch&lt;/li&gt;@@ -74,4 +75,4 @@         &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;-&lt;/html&gt;\ No newline at end of file+&lt;/html&gt;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git commit -m&#39;Add the first git commmand with config&#39;[master 1720a74] Add the first git commmand with config 1 file changed, 2 insertions(+), 1 deletion(-)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git logcommit 1720a74980a99b3d536fb37d0c330342d1088e3f (HEAD -&gt; master)Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Thu Oct 8 09:01:08 2020 +0800    Add the first git commmand with configcommit b53ed32f94f5c09c3639c1163fa7ddfcda07dd60Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 22:01:32 2020 +0800    Create a complate web page    Add index + logo    Add style.css and modified index.html    Add a jscommit bdbfdd9713d8c61dc27b95110650d38113e37e99Author: fire &lt;zhaobaole520@gmail.com&gt;Date:   Tue Oct 6 21:33:58 2020 +0800    Add readme.md    Add readme    Move readme.md to readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff --cached# 现在已经无差异sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)</code></pre><h1 id="14-比较工作区与暂存区两者所含文件的差异"><a href="#14-比较工作区与暂存区两者所含文件的差异" class="headerlink" title="14.比较工作区与暂存区两者所含文件的差异"></a>14.比较工作区与暂存区两者所含文件的差异</h1><blockquote><p>命令<code>git diff</code>后可跟<code>-- filename1 filename2 ...</code>查看具体文件的差异</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  8 08:58 ./drwxr-xr-x 1 sj 197121    0 10月  8 09:05 ../drwxr-xr-x 1 sj 197121    0 10月  8 09:01 .git/drwxr-xr-x 1 sj 197121    0 10月  8 08:45 images/-rw-r--r-- 1 sj 197121 2279 10月  8 08:58 index.htmldrwxr-xr-x 1 sj 197121    0 10月  8 08:45 js/-rw-r--r-- 1 sj 197121    0 10月  8 08:44 readmedrwxr-xr-x 1 sj 197121    0 10月  8 08:45 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diffdiff --git a/styles/style.css b/styles/style.cssindex 5c6165b..6769d56 100644--- a/styles/style.css+++ b/styles/style.css@@ -1,7 +1,7 @@ body{        background-color: #1D2031;     font-family: &#39;Ubuntu&#39;, sans-serif;-    color: white;+    color: black; } body a{@@ -63,4 +63,4 @@ div.accordion.active, div.accordion:hover { div.panel {     padding: 0 18px 0 0;     display: none;-}\ No newline at end of file+}# index.html修改后添加到暂存区了，所以两者在index.html上无差异，在css文件上有差异</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff -- readme# 两者在readme文件上无差异sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff -- styles/style.cssdiff --git a/styles/style.css b/styles/style.cssindex 5c6165b..6769d56 100644--- a/styles/style.css+++ b/styles/style.css@@ -1,7 +1,7 @@ body{        background-color: #1D2031;     font-family: &#39;Ubuntu&#39;, sans-serif;-    color: white;+    color: black; } body a{@@ -63,4 +63,4 @@ div.accordion.active, div.accordion:hover { div.panel {     padding: 0 18px 0 0;     display: none;-}\ No newline at end of file+}sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff -- styles/style.css readmediff --git a/styles/style.css b/styles/style.cssindex 5c6165b..6769d56 100644--- a/styles/style.css+++ b/styles/style.css@@ -1,7 +1,7 @@ body{        background-color: #1D2031;     font-family: &#39;Ubuntu&#39;, sans-serif;-    color: white;+    color: black; } body a{@@ -63,4 +63,4 @@ div.accordion.active, div.accordion:hover { div.panel {     padding: 0 18px 0 0;     display: none;-}\ No newline at end of file+}</code></pre><h1 id="15-Git的工作方式-理解二"><a href="#15-Git的工作方式-理解二" class="headerlink" title="15.Git的工作方式(理解二)"></a>15.Git的工作方式(理解二)</h1><p><img src="/2020/10/09/Git/Git.png" alt="Git"></p><blockquote><p>设置暂存区可以区分出哪些文件是改动过的，哪些未改动过</p></blockquote><h1 id="16-Git的工作方式（菜鸟教程）"><a href="#16-Git的工作方式（菜鸟教程）" class="headerlink" title="16.Git的工作方式（菜鸟教程）"></a>16.Git的工作方式（菜鸟教程）</h1><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p><img src="/2020/10/09/Git/runoob.jpg" alt="runoob"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <strong>git rm —cached \<file\></file\></strong> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <strong>git checkout .</strong> 或者 <strong>git checkout — \<file\></file\></strong> 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <strong>git checkout HEAD .</strong> 或者 <strong>git checkout HEAD \<file\></file\></strong> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h1 id="17-Git-clone项目"><a href="#17-Git-clone项目" class="headerlink" title="17.Git clone项目"></a>17.Git clone项目</h1><blockquote><p>git clone 时，可以用不同的协议，包括 ssh, git, https 等，其中最常用的是 ssh，因为速度较快，还可以配置公钥免输入密码。各种写法如下：</p></blockquote><pre><code class="lang-shell">$ git clone git@github.com:fsliurujie/test.git         --SSH协议$ git clone git://github.com/fsliurujie/test.git          --GIT协议$ git clone https://github.com/fsliurujie/test.git      --HTTPS协议</code></pre><h1 id="18-Git-基本操作"><a href="#18-Git-基本操作" class="headerlink" title="18.Git 基本操作"></a>18.Git 基本操作</h1><blockquote><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>本章将对有关创建与提交你的项目快照的命令作介绍。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong></p></blockquote><p><img src="/2020/10/09/Git/runoob1.jpg" alt="runoob"></p><ul><li><p>workspace：工作区</p></li><li><p>staging area：暂存区/缓存区</p></li><li><p>local repository：或本地仓库</p></li><li><p>remote repository：远程仓库</p></li></ul><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git init</code></td><td style="text-align:left">初始化仓库</td></tr><tr><td style="text-align:left"><code>git clone</code></td><td style="text-align:left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table></div><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git add</code></td><td style="text-align:left">添加文件到仓库</td></tr><tr><td style="text-align:left"><code>git status</code></td><td style="text-align:left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td style="text-align:left"><code>git diff</code></td><td style="text-align:left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td style="text-align:left"><code>git commit</code></td><td style="text-align:left">提交暂存区到本地仓库。</td></tr><tr><td style="text-align:left"><code>git reset</code></td><td style="text-align:left">回退版本。</td></tr><tr><td style="text-align:left"><code>git rm</code></td><td style="text-align:left">删除工作区文件。</td></tr><tr><td style="text-align:left"><code>git mv</code></td><td style="text-align:left">移动或重命名工作区文件。</td></tr></tbody></table></div><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git log</code></td><td style="text-align:left">查看历史提交记录</td></tr><tr><td style="text-align:left"><code>git blame &lt;file&gt;</code></td><td style="text-align:left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table></div><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><div class="table-container"><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>git remote</code></td><td style="text-align:left">远程仓库操作</td></tr><tr><td style="text-align:left"><code>git fetch</code></td><td style="text-align:left">从远程获取代码库</td></tr><tr><td style="text-align:left"><code>git pull</code></td><td style="text-align:left">下载远程代码并合并</td></tr><tr><td style="text-align:left"><code>git push</code></td><td style="text-align:left">上传远程代码并合并</td></tr></tbody></table></div><h1 id="19-Git-分支管理"><a href="#19-Git-分支管理" class="headerlink" title="19.Git 分支管理"></a>19.Git 分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。</p><p>有人把 Git 的分支模型称为<strong>必杀技特性</strong>，而正是因为它，将 <strong>Git</strong> 从版本控制系统家族里区分出来。</p><p>创建分支命令：</p><pre><code class="lang-shell">git branch (branchname)</code></pre><p>切换分支命令:</p><pre><code class="lang-shell">git checkout (branchname)</code></pre><blockquote><p>当你切换分支的时候，Git 会用<strong>该分支的最后提交的快照</strong>替换你的<strong>工作目录</strong>的内容！ 所以多个分支不需要多个目录。</p></blockquote><p>合并分支命令:</p><pre><code class="lang-shell">git merge</code></pre><p>你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>删除分支命令：</p><pre><code class="lang-shell">git branch -d branchName</code></pre><h1 id="20-Git-查看提交历史"><a href="#20-Git-查看提交历史" class="headerlink" title="20.Git 查看提交历史"></a>20.Git 查看提交历史</h1><p>Git 提交历史一般常用两个命令：</p><ul><li><strong>git log</strong> - 查看历史提交记录。</li><li><strong>git blame \<file\></file\></strong> - 以列表形式查看指定文件的历史修改记录。</li></ul><h3 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h3><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><pre><code class="lang-shell">$ git blame &lt;file&gt;</code></pre><p>git blame 命令是以列表形式显示修改记录，如下实例：</p><pre><code class="lang-shell">$ git blame README ^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) # Runoob Git 测试db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) # 菜鸟教程</code></pre><h1 id="21-Git-标签"><a href="#21-Git-标签" class="headerlink" title="21.Git 标签"></a>21.Git 标签</h1><p>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以使用 git tag 给它打上标签。</p><p>比如说，我们想为我们的 runoob 项目发布一个”1.0”版本。 我们可以用 git tag -a v1.0 命令给最新一次提交打上（HEAD）”v1.0”的标签。</p><p>-a 选项意为”创建一个带注解的标签”。 不用 -a 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 我推荐一直创建带注解的标签。</p><pre><code class="lang-shell">$ git tag -a v1.0</code></pre><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 git log —decorate 时，我们可以看到我们的标签了：</p><pre><code class="lang-shell">*   d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;|\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 第一次版本提交</code></pre><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><pre><code class="lang-shell">$ git tag -a v0.9 85fc7e7$ git log --oneline --decorate --graph*   d5e9fc2 (HEAD -&gt; master) Merge branch &#39;change_site&#39;|\  | * 7774248 (change_site) changed the runoob.php* | c68142b 修改代码|/  * c1501a2 removed test.txt、add runoob.php* 3e92c19 add test.txt* 3b58100 (tag: v0.9) 第一次版本提交</code></pre><p>如果我们要查看所有标签可以使用以下命令：</p><pre><code class="lang-shell">$ git tagv0.9v1.0</code></pre><p>指定标签信息命令：</p><pre><code class="lang-shell">git tag -a &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><p>PGP签名标签命令：</p><pre><code class="lang-shell">git tag -s &lt;tagname&gt; -m &quot;runoob.com标签&quot;</code></pre><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。</p><p>所以，标签也是版本库的一个快照。</p><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><blockquote><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p></blockquote><p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。</p><h1 id="22-git-reset-修改暂存区"><a href="#22-git-reset-修改暂存区" class="headerlink" title="22.git reset(修改暂存区)"></a>22.git reset(修改暂存区)</h1><p>git reset 命令用于回退版本，可以指定退回某一次提交的版本。</p><p>git reset 命令语法格式如下：</p><pre><code class="lang-shell">git reset [--soft | --mixed | --hard] [HEAD]</code></pre><p><strong>—mixed</strong> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。</p><pre><code class="lang-shell">git reset  [HEAD] [-- file1 file2 ...]</code></pre><p>实例：</p><pre><code class="lang-shell">$ git reset HEAD^            # 回退所有内容到上一个版本  $ git reset HEAD^ hello.php  # 回退 hello.php 文件的版本到上一个版本  $ git  reset  052e           # 回退到指定版本</code></pre><p><strong>—soft</strong> 参数用于回退到某个版本：</p><pre><code class="lang-shell">git reset --soft HEAD</code></pre><p>实例：</p><pre><code class="lang-shell"> $ git reset --soft HEAD~3 # 回退上上上一个版本</code></pre><p><strong>—hard</strong> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交：</p><pre><code class="lang-shell">git reset --hard HEAD</code></pre><p>实例：</p><pre><code class="lang-shell">$ git reset –hard HEAD~3  # 回退上上上一个版本$ git reset –hard bae128  # 回退到某个版本回退点之前的所有信息。(删除之前的所有commit)$ git reset --hard origin/master    # 将本地的状态回退到和远程的一样</code></pre><p><strong>注意：</strong>谨慎使用 –hard 参数，它会删除回退点之前的所有信息。</p><p><strong>HEAD 说明：</strong></p><ul><li><p>HEAD 表示当前版本</p></li><li><p>HEAD^ 上一个版本</p></li><li><p>HEAD^^ 上上一个版本</p></li><li><p>HEAD^^^ 上上上一个版本</p></li></ul><ul><li>以此类推…</li></ul><p>可以使用 ～数字表示</p><ul><li>HEAD~0 表示当前版本</li><li>HEAD~1 上一个版本</li><li>HEAD^2 上上一个版本</li><li>HEAD^3 上上上一个版本</li><li>以此类推…</li></ul><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.htmlChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readme        modified:   styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add readme styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.html        modified:   readme        modified:   styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git reset HEADUnstaged changes after reset:M       index.htmlM       readmeM       styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   index.html        modified:   readme        modified:   styles/style.cssno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff --cachedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)</code></pre><blockquote><p>简而言之，执行 <code>git reset HEAD</code> 以取消</p><p><strong>之前 git add 添加，但不希望包含在下一提交快照中</strong></p><p>的缓存。</p></blockquote><h1 id="23-git-checkout-修改工作区"><a href="#23-git-checkout-修改工作区" class="headerlink" title="23.git checkout(修改工作区)"></a>23.git checkout(修改工作区)</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   index.html        modified:   readme        modified:   styles/style.cssno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git add index.html# 将较为满意的index.html提交到暂存区了sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi index.html# 在工作区再次修改了index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diffdiff --git a/index.html b/index.htmlindex d68781d..ea8a473 100644--- a/index.html+++ b/index.html@@ -50,7 +50,7 @@                        &lt;h3&gt;Once You Become a Contributor...&lt;/h3&gt;                        &lt;ol&gt;                          &lt;li&gt;add&lt;/li&gt;-                         &lt;li&gt;bare repo&lt;/li&gt;+                         &lt;li&gt;bare&lt;/li&gt;                          &lt;li&gt;Clone Admin&#39;s (Your Partner) New Repository&lt;/li&gt;                          &lt;li&gt;Create a New Branch for this Repository&lt;/li&gt;                          &lt;li&gt;Make Some Change to Your New Branch&lt;/li&gt;# 工作区index.html 与 暂存区index.html 不一样sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.htmlChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   index.html        modified:   readme        modified:   styles/style.csssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git checkout -- index.html# 将工作区index.html恢复为暂存区的index.html的样子# 之所以用“恢复”这个词，是因为暂存区的index.html本就是由工作区那个index.html添加过来的# 也就是说，是工作区之前的index.html# 将一个事物变为它之前曾有的模样，称为“恢复”sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff index.html</code></pre><blockquote><p>修改文件是在<strong>工作区</strong>修改，<strong>暂存区</strong>就是一个临时的存储空间，存储修改过的较为满意的文件，待此次改动整体完成后提交到<strong>版本库</strong>。</p></blockquote><h1 id="24-认识工作区与暂存区"><a href="#24-认识工作区与暂存区" class="headerlink" title="24.认识工作区与暂存区"></a>24.认识工作区与暂存区</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   index.htmlChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readme        modified:   styles/style.css</code></pre><p><img src="/2020/10/09/Git/12.png" alt="recognize"></p><h1 id="25-查看不同commit的差异"><a href="#25-查看不同commit的差异" class="headerlink" title="25.查看不同commit的差异"></a>25.查看不同commit的差异</h1><blockquote><p><code>git diff commit1 commit2 [-- file1 file2 ...]</code></p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff master tempdiff --git a/index.html b/index.htmlindex d9cd4db..9dfbc09 100644--- a/index.html+++ b/index.html@@ -49,7 +49,6 @@                &lt;div class=&quot;panel&quot;&gt;                        &lt;h3&gt;Once You Become a Contributor...&lt;/h3&gt;                        &lt;ol&gt;-                         &lt;li&gt;add&lt;/li&gt;                          &lt;li&gt;Clone Admin&#39;s (Your Partner) New Repository&lt;/li&gt;                          &lt;li&gt;Create a New Branch for this Repository&lt;/li&gt;                          &lt;li&gt;Make Some Change to Your New Branch&lt;/li&gt;@@ -75,4 +74,4 @@         &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;-&lt;/html&gt;+&lt;/html&gt;\ No newline at end of filediff --git a/readme b/readmeindex e69de29..db84973 100644--- a/readme+++ b/readme@@ -0,0 +1 @@+modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff master temp -- index.htmldiff --git a/index.html b/index.htmlindex d9cd4db..9dfbc09 100644--- a/index.html+++ b/index.html@@ -49,7 +49,6 @@                &lt;div class=&quot;panel&quot;&gt;                        &lt;h3&gt;Once You Become a Contributor...&lt;/h3&gt;                        &lt;ol&gt;-                         &lt;li&gt;add&lt;/li&gt;                          &lt;li&gt;Clone Admin&#39;s (Your Partner) New Repository&lt;/li&gt;                          &lt;li&gt;Create a New Branch for this Repository&lt;/li&gt;                          &lt;li&gt;Make Some Change to Your New Branch&lt;/li&gt;@@ -75,4 +74,4 @@         &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;-&lt;/html&gt;+&lt;/html&gt;\ No newline at end of filesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git diff 1720a74 b9229fb -- index.htmldiff --git a/index.html b/index.htmlindex d9cd4db..9dfbc09 100644--- a/index.html+++ b/index.html@@ -49,7 +49,6 @@                &lt;div class=&quot;panel&quot;&gt;                        &lt;h3&gt;Once You Become a Contributor...&lt;/h3&gt;                        &lt;ol&gt;-                         &lt;li&gt;add&lt;/li&gt;                          &lt;li&gt;Clone Admin&#39;s (Your Partner) New Repository&lt;/li&gt;                          &lt;li&gt;Create a New Branch for this Repository&lt;/li&gt;                          &lt;li&gt;Make Some Change to Your New Branch&lt;/li&gt;@@ -75,4 +74,4 @@         &lt;script src=&quot;js/script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;-&lt;/html&gt;+&lt;/html&gt;\ No newline at end of file</code></pre><h1 id="26-删除文件"><a href="#26-删除文件" class="headerlink" title="26.删除文件"></a>26.删除文件</h1><p><code>$ git rm filename</code></p><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  8 15:22 ./drwxr-xr-x 1 sj 197121    0 10月  8 15:17 ../drwxr-xr-x 1 sj 197121    0 10月  8 15:22 .git/drwxr-xr-x 1 sj 197121    0 10月  8 08:45 images/-rw-r--r-- 1 sj 197121 2279 10月  8 15:22 index.htmldrwxr-xr-x 1 sj 197121    0 10月  8 08:45 js/-rw-r--r-- 1 sj 197121    0 10月  8 15:22 readmedrwxr-xr-x 1 sj 197121    0 10月  8 15:22 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ rm readme# 修改了工作区中的内容（但没将修改添加到暂存区，但此次修改是一项“删除”操作）sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        deleted:    readmeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rm readmerm &#39;readme&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        deleted:    readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git reset --hard HEADHEAD is now at 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  8 15:23 ./drwxr-xr-x 1 sj 197121    0 10月  8 15:17 ../drwxr-xr-x 1 sj 197121    0 10月  8 15:23 .git/drwxr-xr-x 1 sj 197121    0 10月  8 08:45 images/-rw-r--r-- 1 sj 197121 2279 10月  8 15:22 index.htmldrwxr-xr-x 1 sj 197121    0 10月  8 08:45 js/-rw-r--r-- 1 sj 197121    0 10月  8 15:23 readmedrwxr-xr-x 1 sj 197121    0 10月  8 15:22 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git rm readmerm &#39;readme&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        deleted:    readme</code></pre><h1 id="27-暂存“修改”"><a href="#27-暂存“修改”" class="headerlink" title="27.暂存“修改”"></a>27.暂存“修改”</h1><blockquote><p>stash 藏匿</p><p>将“修改”放在一个类似堆栈的地方，使工作区保持干净，去做更急的修改，完后再取出继续。</p></blockquote><pre><code class="lang-shell">$ git stash apply      # 复制 栈顶首元素 到工作区$ git stash pop        # 弹出 栈顶首元素 到工作区</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masternothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readmeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stashSaved working directory and index state WIP on master: 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash liststash@{0}: WIP on master: 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masternothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash applyOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readmeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash liststash@{0}: WIP on master: 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git reset --hard HEADHEAD is now at 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masternothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash liststash@{0}: WIP on master: 1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash popOn branch masterChanges not staged for commit:  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)        modified:   readmeno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)Dropped refs/stash@{0} (952831ccd94b1e354bc3b91caf57ffe8a64377da)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git stash listsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)</code></pre><h1 id="28-文件-gitignore"><a href="#28-文件-gitignore" class="headerlink" title="28.文件.gitignore"></a>28.文件.gitignore</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 12drwxr-xr-x 1 sj 197121    0 10月  8 16:16 ./drwxr-xr-x 1 sj 197121    0 10月  8 16:06 ../drwxr-xr-x 1 sj 197121    0 10月  8 16:16 .git/drwxr-xr-x 1 sj 197121    0 10月  8 08:45 images/-rw-r--r-- 1 sj 197121 2279 10月  8 15:22 index.htmldrwxr-xr-x 1 sj 197121    0 10月  8 08:45 js/-rw-r--r-- 1 sj 197121    0 10月  8 16:16 readmedrwxr-xr-x 1 sj 197121    0 10月  8 15:22 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ mkdir docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ echo &#39;hi&#39; &gt; doc/readhimsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        doc/nothing added to commit but untracked files present (use &quot;git add&quot; to track)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi .gitignore# .gitignore 内容为 docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        .gitignorenothing added to commit but untracked files present (use &quot;git add&quot; to track)# 可见git忽略了doc这个文件夹sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi .gitignore# .gitignore 内容为 doc/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        .gitignorenothing added to commit but untracked files present (use &quot;git add&quot; to track)# 可见git也是忽略了doc这个文件夹sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ rm -rf doc# 删除了doc文件夹sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ echo &#39;I am a file&#39; &gt; doc# 新建了doc文件sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ ls -altotal 14drwxr-xr-x 1 sj 197121    0 10月  8 16:20 ./drwxr-xr-x 1 sj 197121    0 10月  8 16:06 ../drwxr-xr-x 1 sj 197121    0 10月  8 16:18 .git/-rw-r--r-- 1 sj 197121    5 10月  8 16:18 .gitignore-rw-r--r-- 1 sj 197121   12 10月  8 16:20 docdrwxr-xr-x 1 sj 197121    0 10月  8 08:45 images/-rw-r--r-- 1 sj 197121 2279 10月  8 15:22 index.htmldrwxr-xr-x 1 sj 197121    0 10月  8 08:45 js/-rw-r--r-- 1 sj 197121    0 10月  8 16:16 readmedrwxr-xr-x 1 sj 197121    0 10月  8 15:22 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cat .gitignoredoc/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        .gitignore        docnothing added to commit but untracked files present (use &quot;git add&quot; to track)# git没有忽略doc文件，因为.gitignore里是doc/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ vi .gitignore# 改回 docsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git statusOn branch masterUntracked files:  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        .gitignorenothing added to commit but untracked files present (use &quot;git add&quot; to track)# 忽略了doc文件</code></pre><blockquote><p>总结：<code>.gitignore</code>文件写<code>doc</code>时，会忽略doc文件与doc文件夹，但若是写<code>doc/</code>，只忽略doc文件夹。</p></blockquote><h1 id="29-Git的备份"><a href="#29-Git的备份" class="headerlink" title="29.Git的备份"></a>29.Git的备份</h1><blockquote><p>备份：将数据从此处传输到彼处。</p><p>传输用到一些传输协议。</p></blockquote><p><img src="/2020/10/09/Git/13.png" alt="Protocol[ˈprəʊtəkɒl]"></p><blockquote><p>哑协议与智能协议：<br>直观区别：哑协议传输进度不可见；智能协议传输进度可见。<br>传输速度：智能协议(压缩了)比哑协议传输速度快。</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol$ pwd/e/FrontEnd/LearnGit/protocol# --bare在这里是指克隆不带工作区的裸仓库sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol$ git clone --bare /e/FrontEnd/LearnGit/Project_code_is_there/.git ya.gitCloning into bare repository &#39;ya.git&#39;...done.# 哑协议传输进度不可见sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol$ git clone --bare file:///e/FrontEnd/LearnGit/Project_code_is_there/.git zhineng.gitCloning into bare repository &#39;zhineng.git&#39;...remote: Enumerating objects: 30, done.remote: Counting objects: 100% (30/30), done.remote: Compressing objects: 100% (24/24), done.remote: Total 30 (delta 6), reused 0 (delta 0)Receiving objects: 100% (30/30), 26.02 KiB | 1.45 MiB/s, done.Resolving deltas: 100% (6/6), done.# 智能协议传输进度可见</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote -vzhineng E:/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng E:/FrontEnd/LearnGit/protocol/zhineng.git (push)zhineng01       file:///e/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng01       file:///e/FrontEnd/LearnGit/protocol/zhineng.git (push)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote rm zhineng zhineng01usage: git remote remove &lt;name&gt;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote -vzhineng E:/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng E:/FrontEnd/LearnGit/protocol/zhineng.git (push)zhineng01       file:///e/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng01       file:///e/FrontEnd/LearnGit/protocol/zhineng.git (push)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote rm zhinengsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote rm zhineng01sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote -vsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote add zhineng file:///e/FrontEnd/LearnGit/protocol/zhineng.gitsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefied  zbl    1720a74 Add the first git commmand with config</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol/zhineng.git (BARE:master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefied  zbl    1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol/zhineng.git (BARE:master)$ git branch -d zblDeleted branch zbl (was 1720a74).sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol/zhineng.git (BARE:master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol/zhineng.git (BARE:master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefiedsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/protocol/zhineng.git (BARE:master)$ git branch -av* master 1720a74 Add the first git commmand with config  temp   b9229fb Add modefied  zbl    1720a74 Add the first git commmand with config</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git push zhinengfatal: The current branch master has no upstream branch.To push the current branch and set the remote as upstream, use    git push --set-upstream zhineng mastersj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git push --set-upstream zhineng masterEverything up-to-dateBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;zhineng&#39;.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git push --set-upstream zhineng zblTotal 0 (delta 0), reused 0 (delta 0)To file:///e/FrontEnd/LearnGit/protocol/zhineng.git * [new branch]      zbl -&gt; zblBranch &#39;zbl&#39; set up to track remote branch &#39;zbl&#39; from &#39;zhineng&#39;.</code></pre><h1 id="30-一点发现"><a href="#30-一点发现" class="headerlink" title="30.一点发现"></a>30.一点发现</h1><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cd ~/.sshsj@fireworks99 MINGW64 ~/.ssh$ ls -altotal 33drwxr-xr-x 1 sj 197121    0 9月   9  2019 ./drwxr-xr-x 1 sj 197121    0 10月  8 17:58 ../-rw-r--r-- 1 sj 197121 1823 9月   9  2019 id_rsa-rw-r--r-- 1 sj 197121  399 9月   9  2019 id_rsa.pub-rw-r--r-- 1 sj 197121 1197 10月  9  2019 known_hostssj@fireworks99 MINGW64 ~/.ssh$ pwd/c/Users/sj/.ssh</code></pre><blockquote><p>所以说 <code>~</code>代表当前用户根目录，即<code>/c/Users/sj</code></p></blockquote><h1 id="31-本地仓库同步到github"><a href="#31-本地仓库同步到github" class="headerlink" title="31.本地仓库同步到github"></a>31.本地仓库同步到github</h1><blockquote><p>git remote add [仓库标识名] [仓库地址]</p><p>git push [仓库标识名] [—all / branchName]</p><p>git fetch [仓库标识名] [—all / branchName]</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote -vzhineng file:///e/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng file:///e/FrontEnd/LearnGit/protocol/zhineng.git (push)# zhineng 是本地的远端仓库sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote add github git@github.com:fireworks99/Project_code_is_there.git# 这里的&#39;github&#39;只是一个同&#39;zhineng&#39;一样的仓库名，它代表了它后面那个地址sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git remote -vgithub  git@github.com:fireworks99/Project_code_is_there.git (fetch)github  git@github.com:fireworks99/Project_code_is_there.git (push)zhineng file:///e/FrontEnd/LearnGit/protocol/zhineng.git (fetch)zhineng file:///e/FrontEnd/LearnGit/protocol/zhineng.git (push)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git push github --allEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 4 threadsCompressing objects: 100% (24/24), done.Writing objects: 100% (30/30), 26.02 KiB | 1.86 MiB/s, done.Total 30 (delta 6), reused 0 (delta 0)remote: Resolving deltas: 100% (6/6), done.To github.com:fireworks99/Project_code_is_there.git * [new branch]      master -&gt; master * [new branch]      temp -&gt; temp * [new branch]      zbl -&gt; zblsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ gitk --allsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git fetch github mainremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:fireworks99/Project_code_is_there * branch            main       -&gt; FETCH_HEAD * [new branch]      main       -&gt; github/mainsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ gitk --allsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master                 1720a74 Add the first git commmand with config  temp                   b9229fb Add modefied  zbl                    1720a74 Add the first git commmand with config  remotes/github/main    9d57f1f Initial commit  remotes/github/master  1720a74 Add the first git commmand with config  remotes/github/temp    b9229fb Add modefied  remotes/github/zbl     1720a74 Add the first git commmand with config  remotes/zhineng/master 1720a74 Add the first git commmand with config  remotes/zhineng/zbl    1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git merge github/mainfatal: refusing to merge unrelated historiessj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git merge --allow-unrelated-histories github/mainMerge made by the &#39;recursive&#39; strategy. LICENSE | 21 +++++++++++++++++++++ 1 file changed, 21 insertions(+) create mode 100644 LICENSEsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ gitk --allsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git push github masterEnumerating objects: 4, done.Counting objects: 100% (4/4), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 308 bytes | 308.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   1720a74..9065e0f  master -&gt; mastersj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ gitk --all</code></pre><h1 id="32-多个git客户端工作在同一分支上"><a href="#32-多个git客户端工作在同一分支上" class="headerlink" title="32.多个git客户端工作在同一分支上"></a>32.多个git客户端工作在同一分支上</h1><h3 id="1-不同人修改了不同文件-fast-forward"><a href="#1-不同人修改了不同文件-fast-forward" class="headerlink" title="(1)不同人修改了不同文件(fast-forward)"></a>(1)不同人修改了不同文件(fast-forward)</h3><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ cd ..sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ git clone git@github.com:fireworks99/Project_code_is_there.git Project_code_is_there_02Cloning into &#39;Project_code_is_there_02&#39;...remote: Enumerating objects: 35, done.remote: Counting objects: 100% (35/35), done.remote: Compressing objects: 100% (21/21), done.remote: Total 35 (delta 7), reused 32 (delta 7), pack-reused 0Receiving objects: 100% (35/35), 27.44 KiB | 121.00 KiB/s, done.Resolving deltas: 100% (7/7), done.# 另一个开发人员fireworks99克隆同一个项目(Project_code_is_there)到自己本地sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ ls -altotal 112drwxr-xr-x 1 sj 197121     0 10月  9 10:01 ./drwxr-xr-x 1 sj 197121     0 9月  30 19:42 ../-rw-r--r-- 1 sj 197121 91237 10月  9 09:46 Git.mddrwxr-xr-x 1 sj 197121     0 10月  8 16:40 img/drwxr-xr-x 1 sj 197121     0 10月  9 09:17 Project_code_is_there/drwxr-xr-x 1 sj 197121     0 10月  9 10:02 Project_code_is_there_02/drwxr-xr-x 1 sj 197121     0 10月  8 17:44 protocol/drwxr-xr-x 1 sj 197121     0 10月  6 21:54 virtual/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit$ cd Project_code_is_there_02/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (master)$ git config --add --local user.name &#39;fireworks99&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (master)$ git config --add --local user.email &#39;2639237361@qq.com&#39;# fireworks99自己的git中的configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (master)$ git config --local -lcore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=trueremote.origin.url=git@github.com:fireworks99/Project_code_is_there.gitremote.origin.fetch=+refs/heads/*:refs/remotes/origin/*branch.master.remote=originbranch.master.merge=refs/heads/masteruser.name=fireworks99user.email=2639237361@qq.comsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (master)$ git branch -av* master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (master)$ git checkout -b features/add_git_commands origin/features/add_git_commandsSwitched to a new branch &#39;features/add_git_commands&#39;Branch &#39;features/add_git_commands&#39; set up to track remote branch &#39;features/add_git_commands&#39; from &#39;origin&#39;.# 基于远端 origin/features/add_git_commands 分支# 创建# 本地分支 features/add_git_commands# 并切换到此分支上# 这里git会把两者关联到一起，以后git push都不用带参数，含默认值sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git branch -av* features/add_git_commands                9065e0f Merge remote-tracking branch &#39;github/main&#39;  master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ vi readme# 在工作区修改了readme文件sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git add -u# 工作区修改的文件添加到暂存区sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git statusOn branch features/add_git_commandsYour branch is up to date with &#39;origin/features/add_git_commands&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        modified:   readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git commit -m&#39;Modified readme&#39;[features/add_git_commands fc5c038] Modified readme 1 file changed, 1 insertion(+)# 暂存区的内容提交到本地版本库sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 281 bytes | 40.00 KiB/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   9065e0f..fc5c038  features/add_git_commands -&gt; features/add_git_commands# 本地版本库push到项目版本库# 另一个开发人员fire也要修改此项目内容(index.html)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git config --local -lcore.repositoryformatversion=0core.filemode=falsecore.bare=falsecore.logallrefupdates=truecore.symlinks=falsecore.ignorecase=trueuser.name=fireuser.email=zhaobaole520@gmail.comremote.zhineng.url=file:///e/FrontEnd/LearnGit/protocol/zhineng.gitremote.zhineng.fetch=+refs/heads/*:refs/remotes/zhineng/*branch.master.remote=zhinengbranch.master.merge=refs/heads/masterbranch.zbl.remote=zhinengbranch.zbl.merge=refs/heads/zblremote.github.url=git@github.com:fireworks99/Project_code_is_there.gitremote.github.fetch=+refs/heads/*:refs/remotes/github/*sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master                 9065e0f [ahead 2] Merge remote-tracking branch &#39;github/main&#39;  temp                   b9229fb Add modefied  zbl                    1720a74 Add the first git commmand with config  remotes/github/main    9d57f1f Initial commit  remotes/github/master  9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/github/temp    b9229fb Add modefied  remotes/github/zbl     1720a74 Add the first git commmand with config  remotes/zhineng/master 1720a74 Add the first git commmand with config  remotes/zhineng/zbl    1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git fetch githubremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (1/1), done.Unpacking objects: 100% (3/3), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0From github.com:fireworks99/Project_code_is_there * [new branch]      features/add_git_commands -&gt; github/features/add_git_commands# 把该项目新建的分支fetch一下,作用如下：# 1.创建并更新本地远程分支(remotes/github/features/add_git_commands)# 2.设定当前分支的 FETCH_HEAD(为远程服务器的features/add_git_commands分支)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git branch -av* master                                   9065e0f [ahead 2] Merge remote-tracking branch &#39;github/main&#39;  temp                                     b9229fb Add modefied  zbl                                      1720a74 Add the first git commmand with config  remotes/github/features/add_git_commands fc5c038 Modified readme  remotes/github/main                      9d57f1f Initial commit  remotes/github/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/github/temp                      b9229fb Add modefied  remotes/github/zbl                       1720a74 Add the first git commmand with config  remotes/zhineng/master                   1720a74 Add the first git commmand with config  remotes/zhineng/zbl                      1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (master)$ git checkout -b features/add_git_commands github/features/add_git_commandsSwitched to a new branch &#39;features/add_git_commands&#39;Branch &#39;features/add_git_commands&#39; set up to track remote branch &#39;features/add_git_commands&#39; from &#39;github&#39;.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git branch -av* features/add_git_commands                fc5c038 Modified readme  master                                   9065e0f [ahead 2] Merge remote-tracking branch &#39;github/main&#39;  temp                                     b9229fb Add modefied  zbl                                      1720a74 Add the first git commmand with config  remotes/github/features/add_git_commands fc5c038 Modified readme  remotes/github/main                      9d57f1f Initial commit  remotes/github/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/github/temp                      b9229fb Add modefied  remotes/github/zbl                       1720a74 Add the first git commmand with config  remotes/zhineng/master                   1720a74 Add the first git commmand with config  remotes/zhineng/zbl                      1720a74 Add the first git commmand with config# 这里可以看到# 本地的add_git_commands分支后面对应的hash值# 与# 远端的add_git_commands分支后面对应的hash值# 相同(皆为fc5c038)，说明他们指向相同的东西# 此时fireworks99执行push是没问题的sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git add -usj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git commit -m&#39;Modified index.html&#39;[features/add_git_commands 318cfc4] Modified index.html 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ gitk --all</code></pre><p><img src="/2020/10/09/Git/14.png" alt="now gitk"></p><blockquote><p>本地的 fast-forward 的commit (Modified readme的那次commit) </p><p>与</p><p>远端的 fast-forward 的commit (Modified readme的那次commit) </p><p>一致</p></blockquote><pre><code class="lang-shell"># 此时fireworks99执行push是没问题的，但倘若在此之前fire有新的push了：sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ vi readmesj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git add -usj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git commit -m&#39;Modified readme agein&#39;[features/add_git_commands 228e8d3] Modified readme agein 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 294 bytes | 98.00 KiB/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   fc5c038..228e8d3  features/add_git_commands -&gt; features/add_git_commands# 最后一行我们看到 fast-forward 的commit的hash 由 fc5c038 变为 228e8d3</code></pre><blockquote><p>再看fireworks99视角：</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git branch -av* features/add_git_commands                318cfc4 [ahead 1] Modified index.html  master                                   9065e0f [ahead 2] Merge remote-tracking branch &#39;github/main&#39;  temp                                     b9229fb Add modefied  zbl                                      1720a74 Add the first git commmand with config  remotes/github/features/add_git_commands fc5c038 Modified readme  remotes/github/main                      9d57f1f Initial commit  remotes/github/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/github/temp                      b9229fb Add modefied  remotes/github/zbl                       1720a74 Add the first git commmand with config  remotes/zhineng/master                   1720a74 Add the first git commmand with config  remotes/zhineng/zbl                      1720a74 Add the first git commmand with config# 本地的 fast-forward 的commit 还是Modified readme的那次(fc5c038)# 他不知道 fire 提交了新的修改sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ gitk --all</code></pre><p><img src="/2020/10/09/Git/15.png" alt="now gitk"></p><blockquote><p>本地的 fast-forward 的commit (Modified readme的那次commit) </p><p>与</p><p>远端的 fast-forward 的commit (Modified readme agein 的那次commit) </p><p>不一致</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git push githubTo github.com:fireworks99/Project_code_is_there.git ! [rejected]        features/add_git_commands -&gt; features/add_git_commands (fetch first)error: failed to push some refs to &#39;git@github.com:fireworks99/Project_code_is_there.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.# git push 报错</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git fetch githubremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:fireworks99/Project_code_is_there   fc5c038..228e8d3  features/add_git_commands -&gt; github/features/add_git_commands# 开发人员fireworks99再次fetch的时候发现fast-forward的commit变更了sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git branch -av* features/add_git_commands                318cfc4 [ahead 1, behind 1] Modified index.html  master                                   9065e0f [ahead 2] Merge remote-tracking branch &#39;github/main&#39;  temp                                     b9229fb Add modefied  zbl                                      1720a74 Add the first git commmand with config  remotes/github/features/add_git_commands 228e8d3 Modified readme agein  remotes/github/main                      9d57f1f Initial commit  remotes/github/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/github/temp                      b9229fb Add modefied  remotes/github/zbl                       1720a74 Add the first git commmand with config  remotes/zhineng/master                   1720a74 Add the first git commmand with config  remotes/zhineng/zbl                      1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git merge github/features/add_git_commandsMerge made by the &#39;recursive&#39; strategy. readme | 1 + 1 file changed, 1 insertion(+)# 合并sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ vi readme# 这里，fire对readme的两次修改我都看到了sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git push githubEnumerating objects: 9, done.Counting objects: 100% (8/8), done.Delta compression using up to 4 threadsCompressing objects: 100% (5/5), done.Writing objects: 100% (5/5), 567 bytes | 141.00 KiB/s, done.Total 5 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), completed with 2 local objects.To github.com:fireworks99/Project_code_is_there.git   228e8d3..56e46e0  features/add_git_commands -&gt; features/add_git_commands# 此时# 本地的 fast-forward 的commit (Modified readme again)# 与# 远端的 fast-forward 的commit (Modified readme again)# 一致# 再次push就没问题了</code></pre><h3 id="2-不同人修改了同文件不同区域-merge"><a href="#2-不同人修改了同文件不同区域-merge" class="headerlink" title="(2)不同人修改了同文件不同区域(merge)"></a>(2)不同人修改了同文件不同区域(merge)</h3><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git branch -av* features/add_git_commands                228e8d3 Modified readme agein  master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 228e8d3 Modified readme agein  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pullremote: Enumerating objects: 9, done.remote: Counting objects: 100% (8/8), done.remote: Compressing objects: 100% (2/2), done.remote: Total 5 (delta 3), reused 5 (delta 3), pack-reused 0Unpacking objects: 100% (5/5), done.From github.com:fireworks99/Project_code_is_there   228e8d3..56e46e0  features/add_git_commands -&gt; origin/features/add_git_commandsUpdating 228e8d3..56e46e0Fast-forward index.html | 1 + 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git branch -av* features/add_git_commands                56e46e0 Merge remote-tracking branch &#39;github/features/add_git_commands&#39; into features/add_git_commands  master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 56e46e0 Merge remote-tracking branch &#39;github/features/add_git_commands&#39; into features/add_git_commands  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with config</code></pre><blockquote><p>开始两人都修改了index.html</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git commit -am&#39;Add non fast-forward command&#39;[features/add_git_commands c01bad1] Add non fast-forward command 1 file changed, 1 insertion(+)</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git commit -m&#39;Add commit command&#39;On branch features/add_git_commandsYour branch is up to date with &#39;github/features/add_git_commands&#39;.Changes not staged for commit:        modified:   index.htmlno changes added to commitsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git commit -am&#39;Add commit command&#39;[features/add_git_commands 3d073bf] Add commit command 1 file changed, 1 insertion(+)</code></pre><blockquote><p>fire先push了</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git push githubEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 295 bytes | 42.00 KiB/s, done.Total 3 (delta 2), reused 0 (delta 0)remote: Resolving deltas: 100% (2/2), completed with 2 local objects.To github.com:fireworks99/Project_code_is_there.git   56e46e0..3d073bf  features/add_git_commands -&gt; features/add_git_commands</code></pre><blockquote><p>fireworks99去push时遭拒</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushTo github.com:fireworks99/Project_code_is_there.git ! [rejected]        features/add_git_commands -&gt; features/add_git_commands (fetch first)error: failed to push some refs to &#39;git@github.com:fireworks99/Project_code_is_there.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code></pre><blockquote><p>fireworks99两个选择</p><p>(1)git pull</p><p>(2)git fetch + merge</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git fetchremote: Enumerating objects: 5, done.remote: Counting objects: 100% (5/5), done.remote: Compressing objects: 100% (1/1), done.remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0Unpacking objects: 100% (3/3), done.From github.com:fireworks99/Project_code_is_there   56e46e0..3d073bf  features/add_git_commands -&gt; origin/features/add_git_commandssj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git branch -av* features/add_git_commands                c01bad1 [ahead 1, behind 1] Add non fast-forward command  master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 3d073bf Add commit command  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with config# c01bad1 [ahead 1, behind 1] 是说当前的工作分支比远端多一个commit同时又少一个commit</code></pre><blockquote><p>$ git merge origin/features/add_git_commands 即可</p></blockquote><h3 id="3-不同人修改了同文件同一区域-conflict"><a href="#3-不同人修改了同文件同一区域-conflict" class="headerlink" title="(3)不同人修改了同文件同一区域(conflict)"></a>(3)不同人修改了同文件同一区域(conflict)</h3><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git merge origin/features/add_git_commandsAuto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result.</code></pre><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git statusOn branch features/add_git_commandsYour branch and &#39;origin/features/add_git_commands&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)        both modified:   index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git commit -am&#39;Resolved conflict by hand&#39;[features/add_git_commands 1aa6467] Resolved conflict by handsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git statusOn branch features/add_git_commandsYour branch is ahead of &#39;origin/features/add_git_commands&#39; by 2 commits.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ gitk --allsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushEnumerating objects: 10, done.Counting objects: 100% (10/10), done.Delta compression using up to 4 threadsCompressing objects: 100% (6/6), done.Writing objects: 100% (6/6), 586 bytes | 48.00 KiB/s, done.Total 6 (delta 4), reused 0 (delta 0)remote: Resolving deltas: 100% (4/4), completed with 2 local objects.To github.com:fireworks99/Project_code_is_there.git   3d073bf..1aa6467  features/add_git_commands -&gt; features/add_git_commands</code></pre><p><img src="/2020/10/09/Git/16.png" alt="index.html"></p><p><img src="/2020/10/09/Git/17.png" alt="index.html"></p><p><img src="/2020/10/09/Git/18.png" alt="gitk"></p><blockquote><p>总结：手动修改冲突处即可。（与同事商量确认保留还是增删）</p></blockquote><h3 id="4-一人改文件名一人改内容-git-pull"><a href="#4-一人改文件名一人改内容-git-pull" class="headerlink" title="(4)一人改文件名一人改内容(git pull)"></a>(4)一人改文件名一人改内容(git pull)</h3><pre><code class="lang-shell">git pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。$ git pull origin next:master# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。$ git pull origin next# 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。$ git fetch origin$ git merge origin/next# 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。# Git也允许手动建立追踪关系。git branch --set-upstream master origin/next# 上面命令指定master分支追踪origin/next分支。# 如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。$ git pull origin# 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。# 如果当前分支只有一个追踪分支，连远程主机名都可以省略。</code></pre><blockquote><p>fireworks99 修改文件名</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git pullremote: Enumerating objects: 10, done.remote: Counting objects: 100% (10/10), done.remote: Compressing objects: 100% (2/2), done.remote: Total 6 (delta 4), reused 6 (delta 4), pack-reused 0Unpacking objects: 100% (6/6), done.From github.com:fireworks99/Project_code_is_there   3d073bf..1aa6467  features/add_git_commands -&gt; github/features/add_git_commandsUpdating 3d073bf..1aa6467Fast-forward index.html | 1 + 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git mv index.html index.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git statusOn branch features/add_git_commandsYour branch is up to date with &#39;github/features/add_git_commands&#39;.Changes to be committed:  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)        renamed:    index.html -&gt; index.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git commit -am&#39;Mv index.html to index.htm&#39;[features/add_git_commands 55718cb] Mv index.html to index.htm 1 file changed, 0 insertions(+), 0 deletions(-) rename index.html =&gt; index.htm (100%)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git push githubEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 226 bytes | 32.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   1aa6467..55718cb  features/add_git_commands -&gt; features/add_git_commands</code></pre><blockquote><p>fire修改文件内容</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pullAlready up to date.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ vi index.htmlsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git commit -am&#39;Modified index.html add empty li tag&#39;[features/add_git_commands 8255c38] Modified index.html add empty li tag 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushTo github.com:fireworks99/Project_code_is_there.git ! [rejected]        features/add_git_commands -&gt; features/add_git_commands (fetch first)error: failed to push some refs to &#39;git@github.com:fireworks99/Project_code_is_there.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pullremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (1/1), done.Unpacking objects: 100% (2/2), done.remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0From github.com:fireworks99/Project_code_is_there   1aa6467..55718cb  features/add_git_commands -&gt; origin/features/add_git_commandsMerge made by the &#39;recursive&#39; strategy. index.html =&gt; index.htm | 0 1 file changed, 0 insertions(+), 0 deletions(-) rename index.html =&gt; index.htm (100%) # git pull很智能，一步到位。sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_comma$ ls -altotal 21drwxr-xr-x 1 sj 197121    0 10月  9 14:26 ./drwxr-xr-x 1 sj 197121    0 10月  9 14:11 ../drwxr-xr-x 1 sj 197121    0 10月  9 14:27 .git/drwxr-xr-x 1 sj 197121    0 10月  9 10:02 images/-rw-r--r-- 1 sj 197121 2367 10月  9 14:26 index.htmdrwxr-xr-x 1 sj 197121    0 10月  9 10:02 js/-rw-r--r-- 1 sj 197121 1068 10月  9 10:02 LICENSE-rw-r--r-- 1 sj 197121   33 10月  9 11:00 readmedrwxr-xr-x 1 sj 197121    0 10月  9 10:02 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ vi index.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushEnumerating objects: 8, done.Counting objects: 100% (8/8), done.Delta compression using up to 4 threadsCompressing objects: 100% (5/5), done.Writing objects: 100% (5/5), 611 bytes | 61.00 KiB/s, done.Total 5 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), completed with 2 local objects.To github.com:fireworks99/Project_code_is_there.git   55718cb..a8d3780  features/add_git_commands -&gt; features/add_git_commands</code></pre><h3 id="5-两人将同一个文件改为不同的文件名"><a href="#5-两人将同一个文件改为不同的文件名" class="headerlink" title="(5)两人将同一个文件改为不同的文件名"></a>(5)两人将同一个文件改为不同的文件名</h3><blockquote><p>fireworks99 将 index.htm改为index1.htm，并更早提交。</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git pullremote: Enumerating objects: 8, done.remote: Counting objects: 100% (8/8), done.remote: Compressing objects: 100% (2/2), done.remote: Total 5 (delta 3), reused 5 (delta 3), pack-reused 0Unpacking objects: 100% (5/5), done.From github.com:fireworks99/Project_code_is_there   55718cb..a8d3780  features/add_git_commands -&gt; github/features/add_git_commandsUpdating 55718cb..a8d3780Fast-forward index.htm | 1 + 1 file changed, 1 insertion(+)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git mv index.htm index1.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git commit -am &#39;Mv index to index1&#39;[features/add_git_commands 7fc9418] Mv index to index1 1 file changed, 0 insertions(+), 0 deletions(-) rename index.htm =&gt; index1.htm (100%)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there (features/add_git_commands)$ git push githubEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 4 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 227 bytes | 28.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   a8d3780..7fc9418  features/add_git_commands -&gt; features/add_git_commands</code></pre><blockquote><p>fire将index.htm修改为index2.htm，后提交。</p></blockquote><pre><code class="lang-shell">sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pullAlready up to date.sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git mv index.htm index2.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git commit -am &#39;Mv index to index2&#39;[features/add_git_commands a765e76] Mv index to index2 1 file changed, 0 insertions(+), 0 deletions(-) rename index.htm =&gt; index2.htm (100%)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushTo github.com:fireworks99/Project_code_is_there.git ! [rejected]        features/add_git_commands -&gt; features/add_git_commands (fetch first)error: failed to push some refs to &#39;git@github.com:fireworks99/Project_code_is_there.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.# 遭拒绝sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pullremote: Enumerating objects: 3, done.remote: Counting objects: 100% (3/3), done.remote: Compressing objects: 100% (1/1), done.remote: Total 2 (delta 1), reused 2 (delta 1), pack-reused 0Unpacking objects: 100% (2/2), done.From github.com:fireworks99/Project_code_is_there   a8d3780..7fc9418  features/add_git_commands -&gt; origin/features/add_git_commandsCONFLICT (rename/rename): Rename &quot;index.htm&quot;-&gt;&quot;index2.htm&quot; in branch &quot;HEAD&quot; rename &quot;index.htm&quot;-&gt;&quot;index1.htm&quot; in &quot;7fc941898258649d0a407e79532d5437aff389d7&quot;Automatic merge failed; fix conflicts and then commit the result.# pull的时候发送合并冲突(让开发人员自己解决)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ ls -altotal 25drwxr-xr-x 1 sj 197121    0 10月  9 14:56 ./drwxr-xr-x 1 sj 197121    0 10月  9 14:11 ../drwxr-xr-x 1 sj 197121    0 10月  9 14:56 .git/drwxr-xr-x 1 sj 197121    0 10月  9 10:02 images/-rw-r--r-- 1 sj 197121 2367 10月  9 14:56 index1.htm-rw-r--r-- 1 sj 197121 2367 10月  9 14:56 index2.htmdrwxr-xr-x 1 sj 197121    0 10月  9 10:02 js/-rw-r--r-- 1 sj 197121 1068 10月  9 10:02 LICENSE-rw-r--r-- 1 sj 197121   33 10月  9 11:00 readmedrwxr-xr-x 1 sj 197121    0 10月  9 10:02 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ diff index1.htm index2.htm# 两文件无差别sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git statusOn branch features/add_git_commandsYour branch and &#39;origin/features/add_git_commands&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)        both deleted:    index.htm        added by them:   index1.htm        added by us:     index2.htmno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git rm index.htmindex.htm: needs mergerm &#39;index.htm&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git statusOn branch features/add_git_commandsYour branch and &#39;origin/features/add_git_commands&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)        added by them:   index1.htm        added by us:     index2.htmno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git add index1.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git statusOn branch features/add_git_commandsYour branch and &#39;origin/features/add_git_commands&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)You have unmerged paths.  (fix conflicts and run &quot;git commit&quot;)  (use &quot;git merge --abort&quot; to abort the merge)Changes to be committed:        new file:   index1.htmUnmerged paths:  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)        added by us:     index2.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git rm index2.htmindex2.htm: needs mergerm &#39;index2.htm&#39;sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git statusOn branch features/add_git_commandsYour branch and &#39;origin/features/add_git_commands&#39; have diverged,and have 1 and 1 different commits each, respectively.  (use &quot;git pull&quot; to merge the remote branch into yours)All conflicts fixed but you are still merging.  (use &quot;git commit&quot; to conclude merge)Changes to be committed:        renamed:    index2.htm -&gt; index1.htmsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ ls -altotal 21drwxr-xr-x 1 sj 197121    0 10月  9 15:00 ./drwxr-xr-x 1 sj 197121    0 10月  9 14:11 ../drwxr-xr-x 1 sj 197121    0 10月  9 15:00 .git/drwxr-xr-x 1 sj 197121    0 10月  9 10:02 images/-rw-r--r-- 1 sj 197121 2367 10月  9 14:56 index1.htmdrwxr-xr-x 1 sj 197121    0 10月  9 10:02 js/-rw-r--r-- 1 sj 197121 1068 10月  9 10:02 LICENSE-rw-r--r-- 1 sj 197121   33 10月  9 11:00 readmedrwxr-xr-x 1 sj 197121    0 10月  9 10:02 styles/sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands|MERGING)$ git commit -am &#39;Decide to mv index to index1&#39;[features/add_git_commands 0abb8e7] Decide to mv index to index1sj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git statusOn branch features/add_git_commandsYour branch is ahead of &#39;origin/features/add_git_commands&#39; by 2 commits.  (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree cleansj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ gitk --allsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git branch -av* features/add_git_commands                0abb8e7 [ahead 2] Decide to mv index to index1  master                                   9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/HEAD                      -&gt; origin/master  remotes/origin/features/add_git_commands 7fc9418 Mv index to index1  remotes/origin/main                      9d57f1f Initial commit  remotes/origin/master                    9065e0f Merge remote-tracking branch &#39;github/main&#39;  remotes/origin/temp                      b9229fb Add modefied  remotes/origin/zbl                       1720a74 Add the first git commmand with configsj@fireworks99 MINGW64 /e/FrontEnd/LearnGit/Project_code_is_there_02 (features/add_git_commands)$ git pushEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (3/3), 418 bytes | 46.00 KiB/s, done.Total 3 (delta 1), reused 0 (delta 0)remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:fireworks99/Project_code_is_there.git   7fc9418..0abb8e7  features/add_git_commands -&gt; features/add_git_commands</code></pre><p><img src="/2020/10/09/Git/19.png" alt="gitk"></p><h3 id="6-禁止向集成分支执行变更历史的操作"><a href="#6-禁止向集成分支执行变更历史的操作" class="headerlink" title="(6)禁止向集成分支执行变更历史的操作"></a>(6)禁止向集成分支执行变更历史的操作</h3><blockquote><p>就是不要动别人的<strong>分支</strong>，你要修改，就在最新的commit之上提交你的commit(在集成主线上commit)。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark capture Ethernet message</title>
      <link href="2020/10/03/WireShark-capture-Ethernet-message/"/>
      <url>2020/10/03/WireShark-capture-Ethernet-message/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>用Wireshark捕捉以太网报文并分析其结构</p></blockquote><a id="more"></a><h3 id="报文的封装"><a href="#报文的封装" class="headerlink" title="报文的封装"></a>报文的封装</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/message_packing.png" alt="图1 报文封装过程"></p><h3 id="我打开超星网站，提交了登录请求，用Wireshark进行捕捉。"><a href="#我打开超星网站，提交了登录请求，用Wireshark进行捕捉。" class="headerlink" title="我打开超星网站，提交了登录请求，用Wireshark进行捕捉。"></a>我打开超星网站，提交了登录请求，用Wireshark进行捕捉。</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/wireshark_capture.png" alt="请求 Package List面板"></p><blockquote><p> 捕捉到了这个请求及其响应</p><p>我们看请求</p></blockquote><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Analyze1.png" alt="请求 Package Details面板"></p><ul><li>第1行(物理层)：这是捕获的38个帧，共373个字节，因每个字节含8个二进制位，故总共<code>373 * 8 = 2984</code>个bit位。</li><li>第2行(链路层)：以太网V2标准，6字节源地址，6字节目的地址。(以太网MAC帧中目的地址在前，源地址在后)。</li><li>第3行(网络层)：IPV4，6字节源地址，6字节物理地址。</li><li>第4行(运输层)：TCP，2字节(16位)源端口号，2字节(16位)目的端口号，4字节(32位)序号，4字节(32位)确认序号。</li><li>第6行(应用层)：HTTP</li></ul><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/wireshark3.png" alt="请求 Package Byte面板"></p><ul><li>行前的数字代表本行第一个字节在总数据流中算第几个字节(从0开始算)</li><li>每两位16进制代表一个字节，可验证总字节数：(0710H)=(368D)，最后一个字节是372，因为是从0开始计数，所以总共373个字节。</li><li>右边是对左边每个字节的ASKII码翻译，比如<code>4c -&gt; 76 -&gt; L</code></li></ul><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/ASKII.jpg" alt="ASKII"></p><h3 id="以太网V2的MAC帧格式"><a href="#以太网V2的MAC帧格式" class="headerlink" title="以太网V2的MAC帧格式"></a>以太网V2的MAC帧格式</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Ethernet_MAC1.png" alt="图2 以太网MAC帧的格式"></p><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/EthernetMAC2.png" alt="图3 以太网MAC帧的格式(2)"></p><h3 id="分析以太网MAC帧的结构"><a href="#分析以太网MAC帧的结构" class="headerlink" title="分析以太网MAC帧的结构"></a>分析以太网MAC帧的结构</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Analyze_Ethernet.png" alt="Ethernet MAC frame"></p><blockquote><p>选中Package Details面板链路层对应的第2行，下面Package Byte面板跟着选中了前14个字节，这14个字节对应以太网MAC帧的前14个字节(由图2、图3可知)：前六个字节是目的地址，接下来六个字节是源地址，接下来两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据交给上一层的这个协议。0x8000代表上层使用的是IP数据报)</p><p>这14个字节后面紧跟的就是IP数据报了</p></blockquote><h3 id="网络层-IP报头"><a href="#网络层-IP报头" class="headerlink" title="网络层 IP报头"></a>网络层 IP报头</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/IP.png" alt="图4 网络层IP报头"></p><h3 id="分析IP数据报的结构"><a href="#分析IP数据报的结构" class="headerlink" title="分析IP数据报的结构"></a>分析IP数据报的结构</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Analyze_IP.png" alt="IP structure"></p><blockquote><p>选中Package Details面板网络层对应的第3行，下面Package Byte面板跟着选中了20个字节，这20个字节对应的IP数据报前20个字节(由图4可知)：最后8个字节中，前四个对应源IP地址，后四个对应目的IP地址。</p></blockquote><h3 id="传输层-UDP报头"><a href="#传输层-UDP报头" class="headerlink" title="传输层 UDP报头"></a>传输层 UDP报头</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/UDP.png" alt="图5 传输层UDP报头"></p><h3 id="传输层-TCP报头"><a href="#传输层-TCP报头" class="headerlink" title="传输层 TCP报头"></a>传输层 TCP报头</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/TCP.png" alt="图6 传输层TCP报头"></p><h3 id="分析TCP段结构"><a href="#分析TCP段结构" class="headerlink" title="分析TCP段结构"></a>分析TCP段结构</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Analyze_TCP.png" alt="TCP structure"></p><blockquote><p>选中Package Details面板网络层对应的第4行，下面Package Byte面板跟着选中了20个字节，这20个字节对应的TCP段前20个字节(由图6可知)：前4个字节中，前两个对应源端口号，后两个对应目的端口号。</p></blockquote><h3 id="HTTP-Request"><a href="#HTTP-Request" class="headerlink" title="HTTP Request"></a>HTTP Request</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/HTTP_request.png" alt="图7 HTTP请求"></p><h3 id="HTTP-Response"><a href="#HTTP-Response" class="headerlink" title="HTTP Response"></a>HTTP Response</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Response.png" alt="图8 HTTP 响应"></p><h3 id="分析HTTP-Request结构"><a href="#分析HTTP-Request结构" class="headerlink" title="分析HTTP Request结构"></a>分析HTTP Request结构</h3><p><img src="/2020/10/03/WireShark-capture-Ethernet-message/Analyze_HTTP.png" alt="HTTP"></p><blockquote><p>选中Package Details面板网络层对应的第5行，下面Package Byte面板出现了另外的1981个字节！！！据图7分析，前1662个字节对应着 请求行、请求头部、空白行。后319个字节对应着请求数据，而这后319个字节就是以太网MAC帧的后319个字节。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><blockquote><p>Package Byte面板分左右两部分，左边是物理层比特流对应的16进制数据，右边是对它的ASKII翻译，ASKII码前32(0~31)个字符是控制字符，无法打印，在这里用 . 表示了(16进制表示 &lt; 20)。第128个字符编号127对应DEL，虽不是控制字符但也无法打印，所以16进制表示 &gt;= 7f 的符号也无法打印，用 . 来表示。</p><p>所以理论上我们得到左边的比特流，完全可以<strong>手动算出</strong>右边的信息。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web vue-nodejs with nginx</title>
      <link href="2020/09/27/Web-vue-nodejs-with-nginx/"/>
      <url>2020/09/27/Web-vue-nodejs-with-nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>Vue项目部署到云服务器nginx，同时上传后端nodejs文件.</p></blockquote><a id="more"></a><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h3><blockquote><p>修改ip：</p><p>本地开发时网络请求相关ip都是localhost，我在服务器端3000端口部署了nodejs做后台，前端在8081端口，如果发送localhost:3000的请求，请求的竟然是我身边的主机的localhost:3000!???(黑人问号脸.jpg).我只能把代码中网络请求的ip改为服务器对应ip。</p><p>这里记得清除浏览器缓存再测试。</p></blockquote><h3 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h3><blockquote><p>页面404：</p><p>对于项目非入口页面，在浏览器地址栏直接输网址会404，我把a标签的超链接改为监听点击事件触发函数跳转路由，好一点了，后面有进一步解决的方法。</p></blockquote><h3 id="Problem-3"><a href="#Problem-3" class="headerlink" title="Problem 3"></a>Problem 3</h3><blockquote><p>后台nodejs重定向redirect失效(404)，大概是跟 Problem 2 同样的问题，尝试<code>iframe + history.go(0)</code>，提交表单后本页面刷新，当然刷新会404(手动刷新也404)，而且这里提交文件的时候出现问题，似乎后端处理不好，简单的文本还好一些。但是刷新一定会404的。</p></blockquote><h3 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem 4"></a>Problem 4</h3><blockquote><p>修改nginx配置解决404问题</p></blockquote><pre><code>location / {    root ...    index ...    try_files $uri $uri/ /index.html; ---解决页面刷新404问题}</code></pre><blockquote><p>最后一句话：当访问uri没有的时候，尝试访问 index.html。由于vue是单页模式，所以入口都是index.html，无论访问什么连接都由vue本身接管。</p></blockquote><h3 id="Problem-5"><a href="#Problem-5" class="headerlink" title="Problem 5"></a>Problem 5</h3><blockquote><p>解决了404后，上传文件刷新页面时，后端nodejs抛异常了，似乎没收到文件，也就是说可能没收到表单，于是我又把<code>iframe+history.go(0)</code>删掉了，用原来后端的redirect，这时可行了。所以一开始专门解决404问题就可以了！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Web杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>formidable upload text and files</title>
      <link href="2020/09/23/Web-formidable-upload-text-and-files/"/>
      <url>2020/09/23/Web-formidable-upload-text-and-files/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>npm第三方库multiparty可处理文件上传的问题，我猜应该也能处理文件与文本同时上传的问题，但我先找到了formidable这个库来解决这一问题。表单属性<code>enctype=&quot;multipart/form-data&quot;</code>限制了不对字符编码，但普通文本不编码无法传输。另外补充一句<code>&lt;input&gt;</code>标签不带<code>name</code>无法获取value。</p></blockquote><a id="more"></a><h2 id="npm第三方库formidable"><a href="#npm第三方库formidable" class="headerlink" title="npm第三方库formidable"></a>npm第三方库formidable</h2><blockquote><p>formidable库用于处理上传的表单(包含文本和文件，主要是处理文件)</p></blockquote><pre><code class="lang-javascript">const formidable = require(&#39;formidable&#39;)router.post(&#39;/uploadImg&#39;, function (req, res) {  const form = new formidable.IncomingForm();  form.encoding = &quot;utf-8&quot;;  form.uploadDir = &#39;./public/img_upload&#39;;  form.parse(req, function(err, field, files) {    // console.log(field);    const oldPath = files.imgFile.path;    const newPath = oldPath + files.imgFile.name;    fs.rename(oldPath, newPath, (err)=&gt;{      if(err) throw err;    })    // res.json(files);    res.redirect(&#39;http://localhost:8080/profile?id=&#39; + field.username)  })})</code></pre><blockquote><p>当服务端全部接收完客户端用<code>post</code>方式提交的文件或图片之后，触发执行回调函数<code>function(err, field, files)</code>。</p><p>field(object) : 表单域数据</p><p>files(object) : 上传的文件、图片等文件域</p><p>上传文件的目录需要事先建好(据说)</p><p>文件上传后无后缀名，为此重命名一下</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJSのupload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Upload files to Server</title>
      <link href="2020/09/22/Web-Upload-files-to-Server/"/>
      <url>2020/09/22/Web-Upload-files-to-Server/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>通过form表单提交文件到服务器</p></blockquote><a id="more"></a><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><pre><code class="lang-html">&lt;form action=&quot;http://localhost:3000/uploadImg&quot;              method=&quot;post&quot;              enctype=&quot;multipart/form-data&quot;              class=&quot;ava_form&quot;&gt;    &lt;label class=&quot;ava_change_text&quot;&gt;头像(可更换)&lt;/label&gt;    &lt;input name=&quot;imgFile&quot; type=&quot;file&quot; accept=&quot;image/gif, image/jpeg&quot; class=&quot;ava_change_file&quot; /&gt;    &lt;input name=&quot;upload&quot; type=&quot;submit&quot; value=&quot;提交&quot;  class=&quot;ava_change_submit&quot; /&gt;&lt;/form&gt;</code></pre><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><pre><code class="lang-shell">npm i multiparty</code></pre><pre><code class="lang-javascript">const multiparty = require(&#39;multiparty&#39;)router.post(&#39;/uploadImg&#39;, function (req, res) {  const form = new multiparty.Form({    uploadDir: &#39;./public/img_upload&#39;  })  form.parse(req, function (err, fields, files) {    if(err) throw err;    else res.send(JSON.stringify(files.imgFile[0]));    // 通过form.parse生成服务器文件，这里生成的文件名字不是原来的名字，而是编码后的名字  })})</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJSのupload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FE request data(img) from BE</title>
      <link href="2020/09/22/Web-FE-request-data-img-from-BE/"/>
      <url>2020/09/22/Web-FE-request-data-img-from-BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>前端向后端请求一系列数据(文本、图片等静态资源)并展示在页面上</p></blockquote><a id="more"></a><h3 id="request-js"><a href="#request-js" class="headerlink" title="request.js"></a>request.js</h3><pre><code class="lang-javascript">import axios from &#39;axios&#39;export function request(config) {  // 1 创建实例  const instance = axios.create({    baseURL: &#39;http://localhost:3000&#39;,    timeout: 5000,    // headers: {    //   &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;,    // },  });  // 2 两类拦截器  instance.interceptors.request.use(config =&gt; {    return config  }, error =&gt; {    console.log(error);  });  instance.interceptors.response.use(res =&gt; {    return res.data  }, error =&gt; {    console.log(error);  });  //3 发送真正的网络请求  return instance(config)}</code></pre><h3 id="profile-js"><a href="#profile-js" class="headerlink" title="profile.js"></a>profile.js</h3><pre><code class="lang-javascript">import {request} from &quot;./request&quot;;export function getProfileData(username) {  return request({    url: &#39;/profile_info&#39;,    params: {      username    }  })}</code></pre><h3 id="Profile-vue"><a href="#Profile-vue" class="headerlink" title="Profile.vue"></a>Profile.vue</h3><pre><code class="lang-javascript">methods: {      getProfileData() {        getProfileData(this.id).then(res =&gt; {          console.log(res);          console.log(res[0]);          console.log(res[0].ava_pos);          console.log(url + res[0].ava_pos);          this.avatar = url + res[0].ava_pos;        })      }    },created() {      this.getProfileData()    },</code></pre><pre><code class="lang-html">&lt;div id=&quot;avatar&quot; class=&quot;center&quot;&gt;    &lt;img :src=&quot;avatar&quot; alt=&quot;avatar&quot; class=&quot;avatar center_item&quot;&gt;&lt;/div&gt;</code></pre><blockquote><p>v-bind绑定data里的avatar展示在页面上</p></blockquote><h3 id="后端profile-js"><a href="#后端profile-js" class="headerlink" title="后端profile.js"></a>后端profile.js</h3><pre><code class="lang-javascript">const connection = require(&#39;./connect&#39;)module.exports = function (username, callback) {  new Promise((resolve, reject) =&gt; {    connection.query(&#39;use blogs&#39;, function (err) {      if(err) reject(err);      else resolve(&#39;Database changed!&#39;);    })  }).then(function (info) {    console.log(info);// Database changed!    return new Promise((resolve, reject) =&gt; {      connection.query(&#39;select * from profiles where username=&quot;&#39; + username + &#39;&quot;&#39;, function (err, res) {        if(err) reject(err);        else {          resolve(&#39;Caught you!&#39;);          callback(null, res);        }      })    })  }, function (err) {    callback(&#39;Error : Maybe the database did not change : &#39; + err);    console.log(&#39;Error : Maybe the database did not change : &#39; + err);  }).then(function (res) {    console.log(res);  // Caught you!  }, function (err) {    callback(&#39;Error : Maybe select error occurred: &#39; + err)    console.log(&#39;Error : Maybe select error occurred: &#39; + err);  })}// 所有的 reject(err) 后面对应的 function(err) 都有 callback(info) info[0] === &#39;E&#39;// 所有的 resolve(info) 仅在后端打印一下成功信息。另外，最后一个 resolve 后紧跟 callback(null, res)</code></pre><h3 id="后端router-js"><a href="#后端router-js" class="headerlink" title="后端router.js"></a>后端router.js</h3><pre><code class="lang-javascript">const getProfile = require(&#39;./db/profile&#39;)router.get(&#39;/profile_info&#39;, function (req, res) {  getProfile(req.query.username, function(err, data){    if(err) res.send(err)    else res.send(data)  })})</code></pre><h3 id="profile-ini-js"><a href="#profile-ini-js" class="headerlink" title="profile_ini.js"></a>profile_ini.js</h3><pre><code class="lang-javascript">connection.query(&#39;insert into profiles(username, ava_pos)&#39; +    &#39;values(&quot;admin&quot;, &quot;/public/img_upload/avatar.jpg&quot;)&#39;, function (err) {  if(err) throw err;  console.log(&#39;Data was inserted!&#39;);})</code></pre><blockquote><p>向<code>mysql</code>存<strong>图片地址</strong>时，从 <code>/public/</code>开始，前端请求过去数据后，在图片地址前面加上<code>http://localhost:3000</code>并在后端<code>index.js</code>开放<code>/public/</code>静态资源</p></blockquote><h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><pre><code class="lang-javascript">const express = require(&#39;express&#39;)const app = express()app.use(&#39;/public/&#39;, express.static(&#39;./public/&#39;))</code></pre><blockquote><p>需要注意的是在图片地址前加上<code>localhost:3000</code>时，前面一定要加<code>http://</code>，因为这是在img标签里的src属性，如果<code>src=&quot;localhost:3000/public/img_load/avatar.jpg&quot;</code>是加载不出图片的，他会在本地找。我们平时在浏览器输入<code>localhost:3000/public/img_load/avatar.jpg</code>浏览器会为我们加上<code>http://</code>，而这里src这一属性没有这个功能</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのaxios </tag>
            
            <tag> NodeJSのstatic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Communication between components</title>
      <link href="2020/09/21/Web-Communication-between-components/"/>
      <url>2020/09/21/Web-Communication-between-components/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>不同组件之间通信(传递信息)以及父子组件之间访问data中数据</p></blockquote><a id="more"></a><h3 id="不同组件间传递信息"><a href="#不同组件间传递信息" class="headerlink" title="不同组件间传递信息"></a>不同组件间传递信息</h3><blockquote><p>1.动态路由</p><p>携带单个信息点，以路由形式<code>/home/userid</code>显示在url中</p></blockquote><p><strong>路由部分</strong></p><pre><code class="lang-javascript">{    // 动态路由 实现 携带信息(单个信息，以路由形式 且显示在url中) 跳转组件    path: &#39;/home/:id&#39;,    component: Home},</code></pre><p><strong>信源JS</strong></p><pre><code class="lang-javascript">const r = this.$router;const id = this.username;r.push(&#39;/home/&#39; + id)</code></pre><p><strong>信宿JS</strong></p><pre><code class="lang-javascript">data() {  return {      id: this.$route.params.id  }},</code></pre><p><strong>信宿html</strong></p><pre><code class="lang-html">&lt;h1&gt;Welcome, {{$route.params.id}}!&lt;/h1&gt;</code></pre><blockquote><p>2.query</p><p>携带一组信息，以query形式<code>/home?id=useri</code>显示在url中</p></blockquote><p><strong>路由部分</strong></p><pre><code class="lang-javascript">{    // 传递query对象 实现 携带信息(可大量信息，以query形式 显示在url中) 跳转组件    path: &#39;/home&#39;,    component: Home},</code></pre><p><strong>信源JS</strong></p><pre><code class="lang-javascript">const r = this.$router;const id = this.username;r.push({  path: &#39;/home&#39;,  query: {    id  }})</code></pre><p><strong>信宿JS</strong></p><pre><code class="lang-javascript">data() {  return {      id: this.$route.query.id  }},</code></pre><p><strong>信宿html</strong></p><pre><code class="lang-html">&lt;h1&gt;Welcome, {{$route.query.id}}&lt;/h1&gt;</code></pre><h3 id="父子组件互相访问data中的数据"><a href="#父子组件互相访问data中的数据" class="headerlink" title="父子组件互相访问data中的数据"></a>父子组件互相访问data中的数据</h3><pre><code class="lang-javascript">//子-&gt;父this.$parentthis.$parent.idthis.$rootthis.$root.id//父-&gt;子this.$childrenthis.$children[0]this.$children[0].idthis.$refsthis.$refs.nav_barthis.$refs.nav_bar.id</code></pre><pre><code class="lang-html">&lt;nav-bar ref=&quot;nav_bar&quot;&gt;&lt;/nav-bar&gt;</code></pre><blockquote><p>一个父组件有许多子组件，所以<code>this.$children</code>可遍历</p><p>一个子组件仅有一个活跃的父组件，所以<code>this.$parent</code>是唯一的</p></blockquote><h3 id="父子组件通信又不一样"><a href="#父子组件通信又不一样" class="headerlink" title="父子组件通信又不一样"></a>父子组件通信又不一样</h3><blockquote><p>父 -&gt; 子 props属性(properties)</p><p>子 -&gt; 父 发送事件</p><p>注意此处有 “-“与 “驼峰” <code>item-click</code>与<code>itemClick</code></p></blockquote><pre><code class="lang-html">&lt;cpn :cmovies=&quot;movies&quot; :cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;</code></pre><pre><code class="lang-javascript">props: {      //(1)类型限制      // cmovies: Array,      // cmessage: String      //(2)提供 默认值、必传值      cmessage: {        type: String,                   //这里的类型可以是自定义类型        //type: [String, Number],       多个可能的类型        default: &#39;fireworks&#39;,        required: true        //还可以添加自定义验证函数validator      },      //类型是对象或数组时，默认值必须是一个函数      cmovies: {        type: Array,        default() {          return []        }      }    }</code></pre><pre><code class="lang-javascript">// 子组件methods: {      btnClick(item) {        console.log(item.name);        //向父组件发射的事件的名称(父组件所监听的事件名称)        // this.$emit(&#39;itemClick&#39;) 这里用驼峰的话上面不行        this.$emit(&#39;item-click&#39;, item)      }    }</code></pre><pre><code class="lang-html">// 父组件 监听btnClick事件&lt;button v-for=&quot;item in categories&quot;            @click=&quot;btnClick(item)&quot;&gt;      {{item.name}}    &lt;/button&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのcomponents </tag>
            
            <tag> Vueのrouter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wait 2s to jump</title>
      <link href="2020/09/20/Web-Wait-2s-to-jump/"/>
      <url>2020/09/20/Web-Wait-2s-to-jump/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>用户注册完成后，屏幕上打印“注册成功”的信息，等待两秒后跳转到登录页面</p></blockquote><a id="more"></a><h3 id="只用一个setTimeout"><a href="#只用一个setTimeout" class="headerlink" title="只用一个setTimeout"></a>只用一个setTimeout</h3><pre><code class="lang-javascript">this.usernameV = &#39;注册成功,2s后跳转&#39;;setTimeout(function() {    this.$router.push(&#39;/login&#39;)}, 2000)</code></pre><blockquote><p>此时this已经是undefined了</p></blockquote><h3 id="试着用“同步”sleep"><a href="#试着用“同步”sleep" class="headerlink" title="试着用“同步”sleep"></a>试着用“同步”sleep</h3><pre><code class="lang-javascript">function syncSleep(time) {    const start = new Date().getTime();    while (new Date().getTime() - start &lt; time) {}  }</code></pre><pre><code class="lang-javascript">this.usernameV = &#39;注册成功,2s后跳转&#39;;syncSleep(2000)// 这里竟然也是先等2s，然后执行赋值与push(这两个操作还不知道谁先)this.$router.push(&#39;/login&#39;)</code></pre><blockquote><p>这里竟然先等2s再执行另外两个操作!!!</p></blockquote><h3 id="还是第一种方法，集中解决this问题"><a href="#还是第一种方法，集中解决this问题" class="headerlink" title="还是第一种方法，集中解决this问题"></a>还是第一种方法，集中解决this问题</h3><pre><code class="lang-javascript">this.usernameV = &#39;注册成功,2s后跳转&#39;;// 这步操作关键，在异步操作外部定义一个指向this.$router的引用const r = this.$router;new Promise((resolve, reject) =&gt; {  setTimeout(function () {    resolve()  }, 2000)}).then(function () {  r.push(&#39;/login&#39;)})</code></pre><blockquote><p>异步操作外面定义一个指向this.$router的引用，这样在异步操作里面也能用!</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのPromise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Register return the error info</title>
      <link href="2020/09/20/Web-Register-return-the-error-info/"/>
      <url>2020/09/20/Web-Register-return-the-error-info/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>注册信息错误，返回错误信息(BackEnd -&gt; FrontEnd)</p></blockquote><a id="more"></a><h3 id="BackEnd-nodejs-express"><a href="#BackEnd-nodejs-express" class="headerlink" title="BackEnd(nodejs express)"></a>BackEnd(nodejs express)</h3><pre><code class="lang-javascript">router.get(&#39;/register_process&#39;, function (req, res) {  register(req.query.username, req.query.password, function (err) {    if(err) res.send(err)  })})</code></pre><blockquote><p>通过callback函数获取错误信息，发送到此请求的客户端</p></blockquote><h3 id="FrontEnd"><a href="#FrontEnd" class="headerlink" title="FrontEnd"></a>FrontEnd</h3><blockquote><p>最开始的时候想在input标签后加after伪类元素，后来发现伪类元素是在容器内部的尾部的，而input容不下其他元素，故作罢。改为新增一个input标签用于展示错误信息。初始value设为空字符串。</p></blockquote><pre><code class="lang-javascript">getRegister() {        getRegister(this.username, this.password).then(res =&gt; {          if(res) {            this.usernameV = res;          }        })      }</code></pre><pre><code class="lang-html">&lt;input :class=&quot;{activeU: isUsernameError}&quot; type=&quot;text&quot; :value=&quot;usernameV&quot;&gt;</code></pre><blockquote><p>v-bind绑定value，将返回的错误信息(若有)设为value的值</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのv-sth </tag>
            
            <tag> Web杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS asynchronous request about MySQL</title>
      <link href="2020/09/20/Web-NodeJS-asynchronous-request-about-MySQL/"/>
      <url>2020/09/20/Web-NodeJS-asynchronous-request-about-MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>NodeJS连接mysql数据库的请求是异步操作。现有客户想要注册，NodeJS需要连接数据库，查询用户表，若用户表中无此用户名方予以注册，否则拒绝。很明显，我需要获取查询的结果之后来决定是否将注册信息写入数据库，“查询”与“写入”这两个异步操作有明显的先后顺序，需要“回调”，用ES6的Promise能更好地解决这一问题。</p></blockquote><a id="more"></a><h3 id="当我没意识到异步操作时"><a href="#当我没意识到异步操作时" class="headerlink" title="当我没意识到异步操作时"></a>当我没意识到异步操作时</h3><pre><code class="lang-javascript">const connection = require(&quot;./connect.js&quot;)module.exports = function (username, password, callback) {  connection.query(&#39;use blogs&#39;, function (err, res) {    if(err) throw err;    console.log(&quot;Database changed : &quot; + res);  })  let flag = false;  connection.query(&#39;select * from users&#39;, function (err, res) {    if(err) throw err;    let len = res.length;    for(let i = 0; i &lt; len; ++i) {      if(res[i].username === username) {        callback(&#39;The username was registered!&#39;);        flag = true;        break;      }    }  })  console.log(flag);  if(flag === false) {    const sql = &#39;insert into users(username, password) values(&quot;&#39; + username + &#39;&quot;, &quot;&#39; + password + &#39;&quot;)&#39;    connection.query(sql, function (err, res) {      if(err) throw err;      console.log(&quot;Succeed : &quot; + res);    })  }}</code></pre><blockquote><p>上述代码<code>console.log(flag)</code>最先执行，然后“写入”操作很有可能先于“查询”操作</p></blockquote><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><pre><code class="lang-javascript">const connection = require(&quot;./connect.js&quot;)module.exports = function (username, password) {  new Promise((resolve, reject) =&gt; {    connection.query(&#39;use blogs&#39;, function (err) {      if(err) reject(err);      else resolve(&#39;Database changed!&#39;)    })  }).then(function (info) {    console.log(info);// Database changed!    return  new Promise((resolve, reject) =&gt; {      connection.query(&#39;select * from users&#39;, function (err, res) {        if(err) reject(err);        else {          let flag = false          let len = res.length;          for(let i = 0; i &lt; len; ++i) {            if(res[i].username === username) {              reject(&#39;The username was registered!&#39;);              flag = true;              break;            }          }          if(flag === false) resolve();        }      })    })  }, function (err) {    console.log(&#39;Maybe the database did not change : &#39; + err);  }).then(function () {        return new Promise((resolve, reject) =&gt; {        const sql = &#39;insert into users(username, password) values(&quot;&#39; + username + &#39;&quot;, &quot;&#39; + password + &#39;&quot;)&#39;        connection.query(sql, function (err) {          if(err) reject(err);          else resolve(&#39;Insert!&#39;);        })      })  }, function (err) {    console.log(&#39;Maybe the username exists: &#39; + err);  }).then(function (info) {    if(info) console.log(info);  }, function (err) {    console.log(&#39;Maybe insert error occurred: &#39; + err);  })}</code></pre><blockquote><p>catch与then混用不太好，一个Promise对应then，但却不是简单地对应一个catch，可以多个then对应一个catch，这个catch只捕捉第一次出现的错误。所以只用then比较好。</p><p>另外如果某个Promise未被执行，它的then中的reslove()函数也会被执行，所以这里最后我判断了一下<code>if(info)</code>，如果info不是undefined认为其Promise被调用了，认为是执行成功了。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScriptのPromise </tag>
            
            <tag> NodeJSのmysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FrontEnd Vue pass info to BackEnd Nodejs</title>
      <link href="2020/09/19/Web-FrontEnd-Vue-pass-info-to-BackEnd-Nodejs/"/>
      <url>2020/09/19/Web-FrontEnd-Vue-pass-info-to-BackEnd-Nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>前端用Vue框架写一个“注册”页面，需要传递一些注册信息到后端Nodejs，以便写入MySQL完成注册。</p></blockquote><a id="more"></a><pre><code class="lang-html">&lt;input type=&quot;text&quot;                     name=&quot;usernm&quot;                     required=&quot;required&quot;                     class=&quot;border-item&quot;                     placeholder=&quot;username&quot;                     value=&quot;&quot;                     v-model=&quot;username&quot;&gt;&lt;input type=&quot;password&quot;                     name=&quot;passwd&quot;                     required=&quot;required&quot;                     class=&quot;border-item&quot;                     placeholder=&quot;password&quot;                     value=&quot;&quot;                     v-model=&quot;password&quot;&gt;</code></pre><blockquote><p>v-model实现前后端的双向绑定</p><p>而v-bind只是后端向前端的单向绑定</p></blockquote><pre><code class="lang-html">&lt;input type=&quot;submit&quot;                     name=&quot;submit&quot;                     value=&quot;Submit&quot;                     class=&quot;btn&quot;                     @click=&quot;getRegister&quot;&gt;</code></pre><blockquote><p>点击submit按钮触发getRegister()函数</p></blockquote><pre><code class="lang-javascript">import axios from &#39;axios&#39;export function request(config) {  // 1 创建实例  const instance = axios.create({    baseURL: &#39;http://localhost:3000&#39;,    timeout: 5000,    // headers: {    //   &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded;charset=UTF-8&#39;,    // },  });  // 2 两类拦截器  instance.interceptors.request.use(config =&gt; {    return config  }, error =&gt; {    console.log(error);  });  instance.interceptors.response.use(res =&gt; {    return res.data  }, error =&gt; {    console.log(error);  });  //3 发送真正的网络请求  return instance(config)}</code></pre><blockquote><p>上述为封装好的网络请求（后端NodeJS设置允许跨域访问，运行在3000端口）</p></blockquote><pre><code class="lang-javascript">import {request} from &quot;./request&quot;;export function getRegister(username, password) {  return request({    url: &#39;/register_process&#39;,    params: {      username,      password    }  })}export function getLogin(username, password) {  return request({    url: &#39;/login_process&#39;,    params: {      username,      password    }  })}</code></pre><blockquote><p>上述为封装好的getRegister请求，getRegister被调用后发出请求<code>localhost:3000/register_process</code>，后端NodeJS收到请求，进行处理</p></blockquote><pre><code class="lang-javascript">const connection = require(&quot;./connect.js&quot;)module.exports = function (username, password) {  connection.query(&#39;use blogs&#39;, function (err, res) {    if(err) throw err;    console.log(&quot;Succeed : &quot; + res);  })  const sql = &#39;insert into users(username, password) values(&quot;&#39; + username + &#39;&quot;, &quot;&#39; + password + &#39;&quot;)&#39;  connection.query(sql, function (err, res) {        if(err) {          // callback(err);          throw err;        }        console.log(&quot;Succeed : &quot; + res);      })  // callback(&#39;Succeed&#39;)}</code></pre><blockquote><p>上述为封装好的register.js将数据写入MySQL数据库</p></blockquote><pre><code class="lang-javascript">const register = require(&#39;./db/register&#39;)router.get(&#39;/register_process&#39;, function (req, res) {  // console.log(req.query.username);  // console.log(req.query.password);  register(req.query.username, req.query.password)})</code></pre><blockquote><p>express的router处理请求：调用register.js完成数据入库</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Vueのaxios </tag>
            
            <tag> Vueのv-sth </tag>
            
            <tag> NodeJSのmysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2819 Swap(Bipartite graph match)</title>
      <link href="2020/04/27/HDU-2819-Swap-Bipartite-graph-match/"/>
      <url>2020/04/27/HDU-2819-Swap-Bipartite-graph-match/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N * N的01矩阵，能否交换行列使得最终主对角线上全为1，不能的话输出-1，能的话输出方案.</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>刚开始想的时候，不明白怎么换，想着什么情况下既要换行又要换列，是那种情况的话该怎么换？越想越复杂。看了题解：</p><p>若可以，只换行可行，只换列也可行</p><p>二分图最大匹配等于n则可以</p><p>DFS(int x)时 link[i] = x；是标记列i被分配给x，是列被标记了！</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int n, mp[N][N], link[N];bool vis[N];bool DFS(int x){    for(int i = 1; i &lt;= n; ++i)        if(mp[x][i] &amp;&amp; !vis[i])        {            vis[i] = 1;            if(link[i] == -1 || DFS(link[i]))            {                link[i] = x;                return 1;            }        }    return 0;}int Match(){    int res = 0;    for(int i = 1; i &lt;= n; ++i)    {        memset(vis, 0, sizeof(vis));        if(DFS(i))            res++;    }    return res;}int main(){    while(~scanf(&quot;%d&quot;, &amp;n))    {        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                scanf(&quot;%d&quot;, &amp;mp[i][j]);        memset(link, -1, sizeof(link));        int matches = Match();        if(matches != n)        {            cout &lt;&lt; &quot;-1\n&quot;;            continue;        }        int L[N], R[N], num = 0;        for(int i = 1; i &lt;= n; ++i)            if(i != link[i])                for(int j = 1; j &lt;= n; ++j)                    if(link[j] == i)                    {                        L[num] = i, R[num] = j;                        num++, swap(link[i], link[j]);                        break;                    }        cout &lt;&lt; num &lt;&lt; &#39;\n&#39;;        for(int i = 0; i &lt; num; ++i)            printf(&quot;C %d %d\n&quot;, L[i], R[i]);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图の匈牙利算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1281 Chessboard game(Bipartite graph match)</title>
      <link href="2020/04/27/HDU-1281-Chessboard-game-Bipartite-graph-match/"/>
      <url>2020/04/27/HDU-1281-Chessboard-game-Bipartite-graph-match/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N行M列的棋盘，空白地区放棋子“車”，使彼此不能攻击到，非空白地区不影响彼此的攻击(不是“墙”)，求在放最多“車”的前提下，有几个点是“重要点”（棋子不放在这里就会减少可放棋子数）？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>同HDU 1045 Fire Net类似，解法思想(二分图匹配)也相同</p></blockquote><h3 id="方案一-较为暴力"><a href="#方案一-较为暴力" class="headerlink" title="方案一 较为暴力"></a>方案一 较为暴力</h3><blockquote><p>求完最大匹配后，将每条匹配的边撤掉再求一遍最大匹配，看是否减少，若减少则该边对应点是最要点。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;int n, m, k;bool vis[N];int mp[N][N], link[N], t_link[N];///DFS(int x): link[to] = x not link[x] = tobool DFS(int x){    for(int i = 1; i &lt;= n; ++i)        if(mp[x][i] &amp;&amp; !vis[i])        {            vis[i] = 1;            if(link[i] == -1 || DFS(link[i]))            {                link[i] = x;                return 1;            }        }    return 0;}int solve(){    int res = 0;    memset(link, -1, sizeof(link));    for(int i = 1; i &lt;= n; ++i)    {        memset(vis, 0, sizeof(vis));        if(DFS(i))            res++;    }    return res;}int main(){    int CASE = 1;    while(~scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k))    {        memset(mp, 0, sizeof(mp));        int u, v;        for(int i = 0; i &lt; k; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            mp[u][v] = 1;        }        int num = solve();        int ans = 0;        memcpy(t_link, link, sizeof(link));        for(int i = 1; i &lt;= n; ++i)            if(t_link[i] != -1)            {                mp[ t_link[i] ][i] = 0;                int t_num = solve();                if(t_num != num)                    ans++;                mp[ t_link[i] ][i] = 1;            }        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;, CASE++, ans, num);    }    return 0;}</code></pre><h3 id="方案二-小题大做"><a href="#方案二-小题大做" class="headerlink" title="方案二 小题大做"></a>方案二 小题大做</h3><blockquote><p>同HDU 4685，添加虚点，求最大匹配，缩点。</p><p>这样做麻烦些，不仅可以得到“重要点”的个数，还可以得出”重要点“是哪些</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105 * 4;const int M = 2 * N * N;const int base = 100;int n, m, k;bool love[N][N];int head[N], cnt;struct edge{    int v, pre;} e[M];void add(int u, int v){    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}bool vis[N];int girl[N], boy[N];bool DFS(int x){    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(!vis[to])        {            vis[to] = 1;            if(!girl[to] || DFS(girl[to]))            {                girl[to] = x;                boy[x] = to;                return 1;            }        }    }    return 0;}int Match(){    int res = 0;    for(int i = 1; i &lt;= n; ++i)    {        memset(vis, 0, sizeof(vis));        if(DFS(i))            res++;    }    return res;}bool inst[N];stack&lt;int&gt; st;vector&lt;int&gt; scc[N];int low[N], times[N], t, num, ltt[N];void Tarjan(int x){    st.push(x);    inst[x] = 1;    low[x] = times[x] = ++t;    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(!times[to])        {            Tarjan(to);            low[x] = min(low[x], low[to]);        }        else if(inst[to])            low[x] = min(low[x], times[to]);    }    if(low[x] == times[x])    {        ++num;        while(!st.empty())        {            int tem = st.top();            st.pop();            ltt[tem] = num;            inst[tem] = 0;            if(tem &gt; base &amp;&amp; tem &lt;= 2 * base)///This is a girl.                scc[num].push_back(tem - base);            if(tem == x)                break;        }    }}void init(){    for(int i = 0; i &lt;= num; ++i)        scc[i].clear();    cnt = t = num = 0;    while(!st.empty())        st.pop();    memset(ltt, 0, sizeof(ltt));    memset(boy, 0, sizeof(boy));    memset(girl, 0, sizeof(girl));    memset(love, 0, sizeof(love));    memset(inst, 0, sizeof(inst));    memset(head, -1, sizeof(head));    memset(times, 0, sizeof(times));}int main(){    int CASE = 1;    while(~scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k))    {        init();        int u, v;        for(int i = 0; i &lt; k; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            love[u][v] = 1;            add(u, base + v);        }        int matches = Match();        int node = 0;        for(int i = 1; i &lt;= n; ++i)            if(!boy[i])            {                ++node;                v = 2 * base + node;                boy[i] = v, girl[v] = i;                for(int j = 1; j &lt;= n; ++j)                    add(j, v);            }        for(int i = base + 1; i &lt;= base + m; ++i)            if(!girl[i])            {                ++node;                v = 2 * base + node;                girl[i] = v, boy[v] = i;                for(int j = base + 1; j &lt;= base + m; ++j)                    add(v, j);            }        for(int i = base + 1; i &lt;= base * 2 + node; ++i)            add(i, girl[i]);///Opposite edges        for(int i = 1; i &lt;= n; ++i)            if(!times[i])                Tarjan(i);        int tot, ans = 0;        for(int i = 1; i &lt;= n; ++i)        {            tot = 0;            int sz = scc[ ltt[i] ].size();            for(int j = 0; j &lt; sz; ++j)            {                v = scc[ ltt[i] ][j];                if(love[i][v])                    tot++;            }            if(tot == 1)                ans++;        }        printf(&quot;Board %d have %d important blanks for %d chessmen.\n&quot;, CASE++, ans, matches);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图の匈牙利算法 </tag>
            
            <tag> 连通图の缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2444 The Accomodation of Students(Bipartite graph color)</title>
      <link href="2020/04/26/HDU-2444-The-Accomodation-of-Students-Bipartite-graph/"/>
      <url>2020/04/26/HDU-2444-The-Accomodation-of-Students-Bipartite-graph/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个人M个相识关系，问：能否将所有人分成两拨，每一拨中的人彼此互不相识。若能，分成两拨后，能从彼此中挑出多少对相识的？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>1.判断是否是二分图（染色法）</p><p>2.二分图最大匹配</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20005;const int M = 20005;int n, m, color[N];;int head[N], cnt;struct edge{    int v, pre;} e[M];void add(int u, int v){    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}bool succeed(int x){    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(color[to] == -1)        {            color[to] = 1 - color[x];            if(!succeed(to))                return 0;        }        else if(color[to] == color[x])            return 0;    }    return 1;}bool vis[N];int link[N];bool DFS(int x){    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(!vis[to])        {            vis[to] = 1;            if(link[to] == -1 || DFS(link[to]))            {                link[to] = x;                return 1;            }        }    }    return 0;}void Match(){    int ans = 0;    memset(link, -1, sizeof(link));    for(int i = 1; i &lt;= n; ++i)    {        memset(vis, 0, sizeof(vis));        if(color[i] == 0 &amp;&amp; DFS(i))            ans++;    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        cnt = 0;        memset(head, -1, sizeof(head));        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            add(u, v), add(v, u);        }        bool flag = 0;        memset(color, -1, sizeof(color));        for(int i = 1; i &lt;= n; ++i)            if(color[i] == -1)            {                color[i] = 0;                if(!succeed(i))                {                    cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;                    flag = 1;                    break;                }            }        if(flag)            continue;        Match();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图の匈牙利算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1045 Fire Net(DFS or bipartite graph match)</title>
      <link href="2020/04/26/HDU-1045-Fire-Net-DFS-or-bipartite-graph-match/"/>
      <url>2020/04/26/HDU-1045-Fire-Net-DFS-or-bipartite-graph-match/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个地图，有空地，有墙，在空地上安排炮台，炮台会向四方攻击，但不会穿透墙壁，要避免炮台彼此攻击到，求最多能安排多少炮台？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>可以简单のDFS</p><p>另外的二分图匹配：</p><p>假设没有墙壁，为每行、每列标号，针对每个点进行建边，求最大匹配</p></blockquote><div class="table-container"><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>4</td><td>4</td><td>4</td><td>4</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table></div><blockquote><p>建边add(1, 1)add(1, 2)add(1, 3)add(1,4)add(2,1)……</p><p>在求最大匹配时，假设第一个表中的2匹配了第二个表中的3，那么相当于在第二行第三列建一座炮台，由于本行都是2，且2已经被分配，所以本行不会再被分配炮台；同理，本列都是3，且3已经被分配，所以本列不会再被分配炮台。如此限制了同行或同列不会出现两座炮台。</p><p>现在有墙，标号便可增加了，比如样例</p></blockquote><pre><code class="lang-powershell">4.X......XX......</code></pre><div class="table-container"><table><thead><tr><th>1</th><th>X</th><th>2</th><th>2</th></tr></thead><tbody><tr><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>X</td><td>X</td><td>4</td><td>4</td></tr><tr><td>5</td><td>5</td><td>5</td><td>5</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>1</th><th>X</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>1</td><td>3</td><td>5</td><td>6</td></tr><tr><td>X</td><td>X</td><td>5</td><td>6</td></tr><tr><td>2</td><td>4</td><td>5</td><td>6</td></tr></tbody></table></div><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 205;char s[N][N];int n, mat[N], idr, idc, gr[N][N], gc[N][N];bool vis[N], g[N][N];bool dfs(int u){    for (int v = 1; v &lt;= idc; v++)    {        if (vis[v] || !g[u][v])            continue;        vis[v] = 1;        if (!mat[v] || dfs(mat[v]))        {            mat[v] = u;            return 1;        }    }    return 0;}int main(){    while (scanf(&quot;%d&quot;, &amp;n), n)    {        memset(g, false, sizeof(g));        memset(gr, 0, sizeof(gr));        memset(gc, 0, sizeof(gc));        memset(mat, 0, sizeof(g));        for (int i = 0; i &lt; n; i++)            scanf(&quot;%s&quot;, s[i]);        idr = 0;        for (int i = 0; i &lt; n; i++)        {            idr++;            for (int j = 0; j &lt; n; j++)            {                if (s[i][j] == &#39;X&#39;)                {                    if (j != 0 &amp;&amp; j != n - 1)                        idr++;                    continue;                }                gr[i][j] = idr;            }        }        idc = 0;        for (int j = 0; j &lt; n; j++)        {            idc++;            for (int i = 0; i &lt; n; i++)            {                if (s[i][j] == &#39;X&#39;)                {                    if (i != 0 &amp;&amp; i != n - 1)                        idc++;                    continue;                }                gc[i][j] = idc;            }        }        for (int i = 0; i &lt; n; i++)        {            for (int j = 0; j &lt; n; j++)            {                if (s[i][j] == &#39;X&#39;)                    continue;                int u = gr[i][j], v = gc[i][j];                g[u][v] = true;            }        }        int ans = 0;        for (int i = 1; i &lt;= idr; i++)        {            memset(vis, false, sizeof(vis));            if (dfs(i))                ans++;        }        printf(&quot;%d\n&quot;, ans);    }    return 0;}</code></pre><h3 id="Code-of-DFS"><a href="#Code-of-DFS" class="headerlink" title="Code of DFS"></a>Code of DFS</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, ans;char mp[10][10];bool check(int x, int y){    if(mp[x][y] != &#39;.&#39;)        return 0;    for(int i = y - 1; i &gt;= 0; --i)        if(mp[x][i] == &#39;B&#39;)            return 0;        else if(mp[x][i] == &#39;X&#39;)            break;    for(int i = x - 1; i &gt;= 0; --i)        if(mp[i][y] == &#39;B&#39;)            return 0;        else if(mp[i][y] == &#39;X&#39;)            break;    return 1;}void DFS(int pos, int num){    if(pos == n * n)    {        ans = max(ans, num);        return ;    }    int x = pos / n, y = pos % n;    if(check(x, y))    {        mp[x][y] = &#39;B&#39;;        DFS(pos + 1, num + 1);        mp[x][y] = &#39;.&#39;;    }    DFS(pos + 1, num);    return ;}int main(){    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%s&quot;, mp[i]);        ans = 0;        DFS(0, 0);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 二分图の匈牙利算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4685 Prince and Princess(bipartite graph match and shrink nodes)</title>
      <link href="2020/04/25/HDU-4685-Prince-and-Princess-bipartite-graph-match-and-shrink-nodes/"/>
      <url>2020/04/25/HDU-4685-Prince-and-Princess-bipartite-graph-match-and-shrink-nodes/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个王子M个公主，王子只能匹配自己喜欢的公主，公主随意。给出王子对于公主的喜爱信息，求在保证最大配对数的前提下，每个王子分别可以匹配哪些公主。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>为了保证最大匹配数，先对王子进行最大匹配(二分图匹配の匈牙利算法DFS)。</p><p>在最大匹配前提下，再找各王子除了匹配到的公主外还可以匹配哪些公主</p><p>遍历王子，对于没匹配公主的每个王子：</p><p>设置一个虚点(公主)与之匹配，并让所有王子指向这一虚点</p></blockquote><p><img src="https://i.postimg.cc/9ff27vN7/I3-ZCE-6-BIKZEH-XPIBOI0-G3.png" alt="Prince"></p><blockquote><p>遍历公主，对于没匹配王子的每个公主：</p><p>设置一个虚点(王子)与之匹配，并让这一虚点指向所有公主</p></blockquote><p><img src="https://i.postimg.cc/htyhJbPp/IO-XI4-E-TJ8-V4-4-2-V4-NC.png" alt="Princess"></p><blockquote><p>针对参与匹配的所有公主(最大匹配中的+虚点中的)，建立反向边</p><p>强连通分量缩点，处在同一个强连通分量中的王子与公主，可以彼此匹配</p><p>A遍历王子，<code>love[A][B]==1</code>用来排除B是王子(保证B是公主)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2005;const int M = 2 * N * N;const int base = 500;int n, m, ans[N];bool love[N][N];int head[N], cnt;struct edge{    int v, pre;} e[M];void add(int u, int v){    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}bool vis[N];int girl[N], boy[N];bool DFS(int x){    for(int i = head[x]; ~i; i = e[i].pre)    {        int v = e[i].v;        if(!vis[v])        {            vis[v] = 1;            if(!girl[v] || DFS(girl[v]))            {                girl[v] = x;                boy[x] = v;                return 1;            }        }    }    return 0;}bool inst[N];stack&lt;int&gt; st;vector&lt;int&gt; scc[N];int low[N], times[N], t, num, ltt[N];void Tarjan(int x){    st.push(x);    inst[x] = 1;    low[x] = times[x] = ++t;    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(!times[to])        {            Tarjan(to);            low[x] = min(low[x], low[to]);        }        else if(inst[to])            low[x] = min(low[x], times[to]);    }    if(low[x] == times[x])    {        ++num;        while(!st.empty())        {            int tem = st.top();            st.pop();            ltt[tem] = num;            inst[tem] = 0;            if(tem &gt; base &amp;&amp; tem &lt;= 2 * base)///This is a girl.                scc[num].push_back(tem - base);            if(tem == x)                break;        }    }}void init(){    for(int i = 0; i &lt;= num; ++i)        scc[i].clear();    cnt = t = num = 0;    while(!st.empty())        st.pop();    memset(ltt, 0, sizeof(ltt));    memset(boy, 0, sizeof(boy));    memset(girl, 0, sizeof(girl));    memset(love, 0, sizeof(love));    memset(inst, 0, sizeof(inst));    memset(head, -1, sizeof(head));    memset(times, 0, sizeof(times));}///Prince : 1 ~ 500///Princess : 501 ~ 1000///Virtual nodes : 1001 ~ 2000int main(){    int _, CASE = 1, tot = 0, v = 0;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        init();        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tot);            while(tot--)            {                scanf(&quot;%d&quot;, &amp;v);                love[i][v] = 1;                add(i, base + v);            }        }        ///Max match        for(int i = 1; i &lt;= n; ++i)        {            memset(vis, 0, sizeof(vis));            DFS(i);        }        int node = 0;        for(int i = 1; i &lt;= n; ++i)            if(!boy[i])            {                ++node;                v = 2 * base + node;                boy[i] = v, girl[v] = i;                for(int j = 1; j &lt;= n; ++j)                    add(j, v);            }        for(int i = base + 1; i &lt;= base + m; ++i)            if(!girl[i])            {                ++node;                v = 2 * base + node;                girl[i] = v, boy[v] = i;                for(int j = base + 1; j &lt;= base + m; ++j)                    add(v, j);            }        for(int i = base + 1; i &lt;= base * 2 + node; ++i)            add(i, girl[i]);        for(int i = 1; i &lt;= n; ++i)            if(!times[i])                Tarjan(i);        printf(&quot;Case #%d:\n&quot;, CASE++);        for(int i = 1; i &lt;= n; ++i)        {            tot = 0;            int sz = scc[ ltt[i] ].size();            for(int j = 0; j &lt; sz; ++j)            {                v = scc[ ltt[i] ][j];                if(love[i][v])                    ans[tot++] = v;            }            sort(ans, ans + tot);            cout &lt;&lt; tot;            for(int j = 0; j &lt; tot; ++j)                printf(&quot; %d&quot;, ans[j]);            cout &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><h3 id="注意初始化顺序"><a href="#注意初始化顺序" class="headerlink" title="注意初始化顺序"></a>注意初始化顺序</h3><pre><code class="lang-c++">void init(){    for(int i = 0; i &lt;= num; ++i)        scc[i].clear();    cnt = t = num = 0;}</code></pre><blockquote><p>因为没注意顺序，num先初始化为0，WA几个小时。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图の匈牙利算法 </tag>
            
            <tag> 连通图の缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4635 Strongly connected(shrink nodes)</title>
      <link href="2020/04/25/HDU-4635-Strongly-connected-shrink-nodes/"/>
      <url>2020/04/25/HDU-4635-Strongly-connected-shrink-nodes/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个含有N个点M条有向边的简单图(无自环无重边)，求：在保证图是简单图且非强连通的前提下，最多可以再添加几条边？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>1.现在有N个点，0条边，可添加 N * (N - 1) 条边(保证是简单图)</p><p>2.为了保证非强连通，需要去掉一些边。最终的图<strong>环缩点</strong>后是两个大点。假设第一个大点中含有X个小点，那第二个大点中就含有(N - X)个小点，那原先他们之间的<code>2 * X*(N-X)</code>条边就要去掉一半，即答案是<code>N(N - 1) - X(N - X)</code></p><p>3.由于原图已有M条边，所以最终答案是<code>N(N - 1) - M - X(N - X)</code></p><p>4.那么<code>X(N - X)</code>在什么情况下最小呢？当二次函数处理时发现X越近0或越近N时最小，即最后的两个大点所含的小点数目之差越大越优。</p><p>5.假设原图缩点后各大点所含小点数为：2，4，8，16。那么将2做一强连通分量，剩下的4+8+16做另一强连通分量时，答案最优。所以要找缩点后内部含点数最少的强连通分量，其内部点数为X。</p><p>6.有个前提：这个强联通分量的入度或出度为0(才可以成为最后两个点之一)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100100;const int M = 2000100;const int INF = 0x3f3f3f3f;#define ll long longll n, m;int head[N], cnt;struct edge{    int u, v, pre;}e[M];void add(int u, int v){    e[cnt].u = u;    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}stack&lt;int&gt; st;bool inst[N];int low[N], times[N], t, num, ltt[N];ll nodes[N];void Tarjan(int x){    st.push(x);    inst[x] = 1;    low[x] = times[x] = ++t;    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(!times[to])        {            Tarjan(to);            low[x] = min(low[x], low[to]);        }        else if(inst[to])            low[x] = min(low[x], times[to]);    }    if(low[x] == times[x])    {        num++;        while(!st.empty())        {            int tem = st.top();            st.pop();            ltt[tem] = num;            nodes[num]++;            inst[tem] = 0;            if(tem == x)                break;        }    }}int in[N], out[N];void init(){    cnt = t = num = 0;    while(!st.empty())        st.pop();    memset(in, 0, sizeof(in));    memset(out, 0, sizeof(out));    memset(low, 0, sizeof(low));    memset(ltt, 0, sizeof(ltt));    memset(inst, 0, sizeof(inst));    memset(head, -1, sizeof(head));    memset(nodes, 0, sizeof(nodes));    memset(times, 0, sizeof(times));}int main(){    int _, p = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);        init();        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            add(u, v);        }        for(int i = 1; i &lt;= n; ++i)            if(!times[i])                Tarjan(i);        if(num == 1)        {            printf(&quot;Case %d: -1\n&quot;,p++);            continue;        }        for(int i = 0; i &lt; cnt; ++i)        {            u = ltt[ e[i].u ], v = ltt[ e[i].v ];            if(u != v)                in[v]++, out[u]++;        }        ll mmin = n;        for(int i = 1; i &lt;= num; ++i)            if(in[i] == 0 || out[i] == 0)                mmin = min(mmin, nodes[i]);        printf(&quot;Case %d: &quot;,p++);        cout &lt;&lt; n * (n - 1) - m - mmin * (n - mmin) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h3><blockquote><p>1.数组很多时，不要漏掉任意一个的初始化。</p><p>2.超过1个int数字的加减乘除(尤其乘法)记得用long long。</p></blockquote><h3 id="眼瞎写错下标Debug2小时"><a href="#眼瞎写错下标Debug2小时" class="headerlink" title="眼瞎写错下标Debug2小时"></a>眼瞎写错下标Debug2小时</h3><pre><code class="lang-c++">for(int i = 0; i &lt; cnt; ++i){    u = ltt[ e[cnt].u ], v = ltt[ e[cnt].v ];    if(u != v)        in[v]++, out[u]++;}</code></pre><blockquote><blockquote><p>眼瞎的痛</p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4612 Warm up(Bridges + Diameter of tree)</title>
      <link href="2020/04/24/HDU-4612-Warm-up-Bridges-Diameter-of-tree/"/>
      <url>2020/04/24/HDU-4612-Warm-up-Bridges-Diameter-of-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点M条无向边(可含重边)，再添加一条边，最后的桥最少有多少？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>本来想当成POJ 3694 处理，桥的数目 - (距离LCA和最大的两个叶子节点到LCA的距离和)，但两层循环求到LCA距离和会TLE！</p><p>学到了：树的直径<code>dist[ BFS( BFS(1) ) ]</code></p><p>第一次BFS返回一个叶子节点</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200005;const int M = 4200005;int n, m, Q;int cnt, tot, idx, id[N], h1[N], h2[N], low[N], times[N], num_bridges;bool bridge[M];struct edge{    int u, v, pre;} e[M];void init(){    cnt = tot = idx = num_bridges = 0;    memset(h1, -1, sizeof(h1));    memset(h2, -1, sizeof(h2));    memset(id,  0, sizeof(id));    memset(low, 0, sizeof(low));    memset(times, 0, sizeof(times));    memset(bridge, 0, sizeof(bridge));}void add(int u, int v, int head[]){    e[cnt].u = u;    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}void Tarjan(int x, int pre_e_num)///Get all bridges!{    low[x] = times[x] = ++tot;    for(int i = h1[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(i == (pre_e_num ^ 1))///Deal with repeated edges!            continue;        if(!times[to])        {            Tarjan(to, i);            low[x] = min(low[x], low[to]);            if(low[to] &gt; times[x])            {                num_bridges++;                bridge[i] = bridge[i ^ 1] = 1;            }        }        else            low[x] = min(low[x], times[to]);    }}void DFS(int x)///Shrink by bridges!{    id[x] = idx;    for(int i = h1[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(id[to] || bridge[i])///Don&#39;t go through any bridge!            continue;        DFS(to);    }}bool vis[N];int dist[N];int BFS(int x){    memset(vis, 0 ,sizeof(vis));    queue&lt;int&gt; q;    q.push(x);    vis[x] = 1, dist[x] = 0;    int now;    while(!q.empty())    {        now = q.front();        q.pop();        for(int i = h2[now]; ~i; i = e[i].pre)        {            int to = e[i].v;            if(vis[to])                continue;            dist[to] = dist[now] + 1;            q.push(to);            vis[to] = 1;        }    }    return now;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n + m))    {        init();        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            add(u, v, h1), add(v, u, h1);        }        Tarjan(1, -1);        for(int i = 1; i &lt;= n; ++i)            if(!id[i])                ++idx, DFS(i);        int number = cnt;        for(int i = 0; i &lt; number; i += 2)        {            u = e[i].u, v = e[i].v;            if(id[u] == id[v])                continue;            bridge[cnt] = 1;            add(id[u], id[v], h2);            bridge[cnt] = 1;            add(id[v], id[u], h2);        }        int diameter = dist[BFS(BFS(1))];        cout &lt;&lt; num_bridges - diameter &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3177 Redundant Paths(shrink nodes and bridges)</title>
      <link href="2020/04/24/POJ-3177-Redundant-Paths-shrink-nodes-and-bridges/"/>
      <url>2020/04/24/POJ-3177-Redundant-Paths-shrink-nodes-and-bridges/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点M条无向边，原图是连通的，现要添加一些边，使得每两点之间的路至少有两条。求最少连接几条边。</p></blockquote><a id="more"></a><h3 id="Analzye"><a href="#Analzye" class="headerlink" title="Analzye"></a>Analzye</h3><blockquote><p>先进行<strong>环缩点</strong>，缩点完后是一棵树。</p><p>连接任意两个节点，皆可成环。</p><p>然而连接叶子节点比连接非叶子节点更优(需添加的边较少)。</p><p>而且要连接的这两个叶子节点，其到LCA的距离越大越优。</p><p>因为：连接树(缩点后的图)中某两个距离LCA最大的叶子节点，形成的环再次缩点会缩到根节点里，这样就减少了两个点。若非如此，每次只减少一个点。</p><p>答案：假设有ans个叶子节点，每添一条边减少两个点，需要添加<code>ans / 2</code>条边。若ans为奇数，需要<code>(ans + 1) / 2</code>条边。两者可合并成后者。</p><p>如何求缩点后叶子节点的个数ans？</p><p>叶子节点特征：度数为1</p><p>方案：求桥，原图的桥是缩点后的树上的边。遍历原图每个点，对每个点遍历出边，若此出边为桥，则它所连接的两点所在的连通分量(缩点后的点)度数++。最后遍历每个缩点后的点，度数为1的是叶子节点。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5005;const int M = 50005;int n, m;int cnt, head[N];struct edge{    int v, pre;    bool flag;} e[M];void add(int u, int v){    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}stack&lt;int&gt; st;bool inst[N];int low[N], times[N], t;int ltt[N], num, bridges;void Tarjan(int x, int pre){    st.push(x);    inst[x] = 1;    low[x] = times[x] = ++t;    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(to == pre)            continue;        if(!times[to])        {            Tarjan(to, x);            low[x] = min(low[x], low[to]);            if(low[to] &gt; times[x])            {                bridges++;                e[i].flag = e[i ^ 1].flag = 1;            }        }        else if(inst[to])            low[x] = min(low[x], times[to]);    }    if(low[x] == times[x])    {        num++;        while(!st.empty())        {            int tem = st.top();            st.pop();            ltt[tem] = num;            inst[tem] = 0;            if(tem == x)                break;        }    }}int degrees[N];void init(){    while(!st.empty())        st.pop();    cnt = t = bridges = num = 0;    memset(ltt, 0, sizeof(ltt));    memset(low, 0, sizeof(low));    memset(times, 0, sizeof(times));    memset(inst,  0, sizeof(inst));    memset(head, -1, sizeof(head));    memset(degrees, 0, sizeof(degrees));}int main(){    int u, v;    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        init();        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            add(u, v);            add(v, u);        }        Tarjan(1, -1);///Original graph is connected.        for(int i = 1; i &lt;= n; ++i)            for(int j = head[i]; ~j; j = e[j].pre)                if(e[j].flag)                    degrees[ ltt[i] ]++;        int ans = 0;        for(int i = 1; i &lt;= num; ++i)            if(degrees[i] == 1)                ans++;        cout &lt;&lt; (ans + 1) / 2 &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h3><blockquote><p>有向图的<strong>环缩点</strong>可以是<code>Tarjan(int x)</code>，利用<code>vis[]</code>协助。</p><p>无向图的<strong>环缩点</strong>需要是<code>Tarjan(int x, int pre)</code>，避免遍历到反向边。</p><p>关于避免访问到反向边而又不错过重边：</p><p>正常情况下：</p><p><code>Tarjan(int x, int pre_edge)</code>配合<code>if(i == (pre_edge ^ 1))continue;</code></p><p>如果原图保证没有重边，可以偷懒：</p><p><code>Tarjan(int x, int pre_node)</code>配合<code>if(to == pre_node)continue;</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の缩点 </tag>
            
            <tag> 连通图の桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3694 Network(Bridges and LCA)</title>
      <link href="2020/04/08/POJ-3694-Network-Bridges-and-LCA/"/>
      <url>2020/04/08/POJ-3694-Network-Bridges-and-LCA/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出可能含有重边的无向图，求桥的初始数目。Q次添边，每次输出添边后桥的数目。题目保证初始时刻图是连通的。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>1.将图进行正宗缩点（新点+新边的那种）形成树</p><p>2.这棵树的每条边都是桥，在点u点v间添一条边(若u、v不在同一个连通分量中，即没缩成同一点，此举必成环），后来的桥的数目等于原来桥的数目减掉新图里这个环中(不算边u,v)边的数目。<strong>而这个数目等于u、v(对应缩点)到他们最近公共祖先LCA的距离和！这个思想绝了！原本在一般图中，要找这样一个环的边数，怕是要循环或者递归啥的，可偏偏这是在一棵树里！它有这样的特点。</strong></p><p>具体步骤：</p><p>1.Tarjan对原图求桥</p><p>2.<strong>在有桥的前提下DFS正经缩点</strong>(学到了!)</p><p>3.根据缩点建新图(添新边以连接新缩点)</p><p>4.BFS求新点的深度(层)，为求某两点距离其LCA的距离做准备</p><p>5.利用个点深度求两点距离各自LCA的距离</p><p>最后添边在LCA函数里一边查询距离，一边更新(桥变非桥)</p></blockquote><h3 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h3><blockquote><p>关于<strong>正宗缩点</strong>：</p><p>1.朱刘算法求最小树形图的时候，缩点并不是很正宗，点处理的很好，但是边还是用的之前的边，没添一条没删一条。当然这是算法必须具备的特点，正经缩点还不适合它的情境、它的需求。</p><p>2.并查集缩点就更不正宗了……</p><p>关于处理重边的问题：</p><p>为了不走反向边 同时 不忽略重边<code>if(i == pre_e_num ^ 1)continue;</code></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int M = 600005;int n, m, Q;int cnt, tot, idx, deep[N], id[N], h1[N], h2[N], low[N], times[N], num_bridges;bool bridge[M];struct edge{    int u, v, pre;} e[M];struct shrink_node{    int pre, e_num;} node[N];void init(){    cnt = tot = idx = num_bridges = 0;    memset(h1, -1, sizeof(h1));    memset(h2, -1, sizeof(h2));    memset(id,  0, sizeof(id));    memset(low, 0, sizeof(low));    memset(deep, 0, sizeof(deep));    memset(times, 0, sizeof(times));    memset(bridge, 0, sizeof(bridge));}void add(int u, int v, int head[]){    e[cnt].u = u;    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}void Tarjan(int x, int pre_e_num)///Get all bridges!{    low[x] = times[x] = ++tot;    for(int i = h1[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(i == (pre_e_num ^ 1))///Deal with repeated edges!            continue;        if(!times[to])        {            Tarjan(to, i);            low[x] = min(low[x], low[to]);            if(low[to] &gt; times[x])            {                num_bridges++;                bridge[i] = bridge[i ^ 1] = 1;            }        }        else            low[x] = min(low[x], times[to]);    }}void DFS(int x)///Shrink by bridges!{    id[x] = idx;    for(int i = h1[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(id[to] || bridge[i])///Don&#39;t go through any bridge!            continue;        DFS(to);    }}void BFS()///Get the deep to prepare to get the LCA!{    deep[1] = 1, node[1].pre = 0;    queue&lt;int&gt; q;    q.push(1);    while(!q.empty())    {        int now = q.front();        q.pop();        for(int i = h2[now]; ~i; i = e[i].pre)        {            int to = e[i].v;            if(deep[to])                continue;            deep[to] = deep[now] + 1;            q.push(to);            node[to].pre = now;            node[to].e_num = i;        }    }}int LCA(int x, int y){    int ans = 0;    if(deep[y] &gt;= deep[x])        swap(x, y);    while(deep[x] &gt; deep[y])    {        if(bridge[ node[x].e_num ])///Only count the bridges!        {            ans++;            bridge[ node[x].e_num ] = bridge[ node[x].e_num ^ 1 ] = 0;        }        x = node[x].pre;    }    if(x == y)        return ans;    while(x != y)    {        int ex = node[x].e_num, ey = node[y].e_num;        if(bridge[ex])            ans++, bridge[ex] = bridge[ex ^ 1] = 0;        if(bridge[ey])            ans++, bridge[ey] = bridge[ey ^ 1] = 0;        x = node[x].pre, y = node[y].pre;    }    return ans;}int main(){    int t = 1;    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m) &amp;&amp; (n + m))    {        init();        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            add(u, v, h1), add(v, u, h1);        }        Tarjan(1, -1);        for(int i = 1; i &lt;= n; ++i)            if(!id[i])                ++idx, DFS(i);        int number = cnt;        for(int i = 0; i &lt; number; i += 2)        {            u = e[i].u, v = e[i].v;            if(id[u] == id[v])                continue;            bridge[cnt] = 1;            add(id[u], id[v], h2);            bridge[cnt] = 1;            add(id[v], id[u], h2);        }        BFS();        scanf(&quot;%d&quot;, &amp;Q);        cout &lt;&lt; &quot;Case &quot; &lt;&lt; t++ &lt;&lt; &quot;:\n&quot;;        while(Q--)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            if(id[u] != id[v])                num_bridges -= LCA(id[u], id[v]);            cout &lt;&lt; num_bridges &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><blockquote><p>要想办法计算好数组大小，开小了不止会RE，还会TLE</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图のLCA </tag>
            
            <tag> 连通图の桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 796 Critical Links(Connected graph Bridge)</title>
      <link href="2020/04/08/UVA-796-Critical-Links-Connected-graph-Bridge/"/>
      <url>2020/04/08/UVA-796-Critical-Links-Connected-graph-Bridge/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出无向图求桥，可能含有重边</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>不在环里的(双向)边都是桥</p><p>利用Tarjan算法得到的</p><p>times[u]：点u第一次被访问的时间</p><p>low[v]：点v所在连通分量中第一个被搜到的点的第一次被访问的时间</p><p>若边(u, v)在某个环里，low[v] &lt;= times[u]</p><p>反过来，<code>if(low[v] &gt; times[u])</code>说明这条边是桥</p><p>另外注意：1. 重边都不是桥。2.添边的时候反向边要紧跟原边(因为用到了<code>e[i].flag = e[i ^ 1].flag = 1;</code>)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; P;const int N = 11000;const int M = 110000;int n, cnt, tot, bridge, head[N], low[N], times[N];map&lt;int, map&lt;int, int&gt; &gt; mp;struct edge{    bool flag;    int u, v, pre;} e[M];void add(int u, int v){    e[cnt].flag = 0;    e[cnt].u = u;    e[cnt].v = v;    e[cnt].pre = head[u];    head[u] = cnt++;}void Tarjan(int x, int pre){    low[x] = times[x] = ++tot;    for(int i = head[x]; ~i; i = e[i].pre)    {        int to = e[i].v;        if(to == pre)            continue;        if(!times[to])        {            Tarjan(to, x);            low[x] = min(low[x], low[to]);            if(low[to] &gt; times[x])            {                bridge++;                e[i].flag = e[i ^ 1].flag = 1;///must add edge together!            }        }        else            low[x] = min(low[x], times[to]);    }}int main(){    while(~scanf(&quot;%d&quot;, &amp;n))    {        if(n == 0)        {            cout &lt;&lt; &quot;0 critical links\n\n&quot;;            continue;        }        cnt = tot = bridge = 0, mp.clear();        memset(low, 0, sizeof(low));        memset(times, 0, sizeof(times));        memset(head, -1, sizeof(head));        int u, v, num;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d (%d)&quot;, &amp;u, &amp;num);            while(num--)            {                scanf(&quot;%d&quot;, &amp;v);                if(v &lt;= u)                    continue;                add(u, v), mp[u][v]++;                add(v, u), mp[v][u]++;            }        }        for(int i = 0; i &lt; n; ++i)            if(!times[i])                Tarjan(i, -1);        if(bridge == 0)        {            cout &lt;&lt; &quot;0 critical links\n\n&quot;;            continue;        }        cout &lt;&lt; bridge &lt;&lt; &quot; critical links\n&quot;;        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;        for(int i = 0; i &lt; cnt; i += 2)            if(mp[ e[i].u ][ e[i].v ] == 1 &amp;&amp; e[i].flag)                q.push(P(min(e[i].u, e[i].v), max(e[i].u, e[i].v)));        P now;        while(!q.empty())        {            now = q.top();            q.pop();            cout &lt;&lt; now.first &lt;&lt; &quot; - &quot; &lt;&lt; now.second &lt;&lt; &#39;\n&#39;;        }        putchar(&#39;\n&#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4408 Minimun Spanning Tree (Count)</title>
      <link href="2020/04/07/HDU-4408-Minimun-Spanning-Tree-Count/"/>
      <url>2020/04/07/HDU-4408-Minimun-Spanning-Tree-Count/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>最小生成树 + 生成树计数</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>相对于普通的最小生成树，多了一个条件：最小，也就是说生成树的边有了权值。如果想办法去掉权值，问题就转为了普通生成树计数了。就像三维扫描线求体积那题，遍历Z轴，如同去掉了一个维度，将问题转化为了普通的扫描线求面积。这一题能不能通过遍历边的长度而将问题转化呢？可以的。</p><p>在Kruskal算法中：假设图中有a[1]条长度为b[1]的边，有a[2]条长度为b[2]的边…a[k]条长度为b[k]的边。这a[k]条长度相同的边的排列顺序可以是任意的，这意味着顺序不影响结果(即长度为b[k]的边被遍历过后形成的连通块是相同的，即缩点后的图是相同的)，也就是说在长度为b[k]的边的集合里，有num[k]个子集，选任意一个子集得到的结果都是相同的。这样一来，最终答案就是<code>num[1] * num[2] *...*num[last]</code>。</p><p>如何求num[k] ?</p><p>将长度小于b[k]的边都处理完(并查集unite)后形成一个个集合，这一个个集合相当于新图中的一个个“点”。这a[k]条长度为b[k]的边会使这些“点”形成一个个新的连通块，将每一个连通块看做一个图，Gauss计算生成树个数，每个连通块的生成树个数累乘就是num[k]。</p></blockquote><h3 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h3><blockquote><p>1.并查集需要用到一个记录祖先节点的数组，这里需要用到两个这样的数组F[]、K[]，K是F的将来，F是K的过去。在主函数里有如下代码：</p></blockquote><pre><code class="lang-c++">u = found(F, e[i].u), v = found(F, e[i].v);if(u != v){    vis[u] = vis[v] = 1;    K[ found(K, u) ] = found(K, v);    A[u][v]++, A[v][u]++;}</code></pre><p><img src="https://i.loli.net/2020/04/07/vLbkurN3WRMZXdj.png" alt="MSTC.png"></p><blockquote><p>按照两个数组来，上面的环是会形成的，就可以正常进行生成树计数了。倘若只有一个数组，不可能形成环，若无环生成树个数只能是1。便是这里用到了两个数组，因为图的更新需要有“时差”。在此刻之前，K和F要同步。在此刻产生时差。在其他时刻，K和F没有合作关系。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int N = 105;const int M = 1005;ll ans, n, m, p;ll A[N][N], C[N][N], F[N], K[N];bool vis[N];vector&lt;ll&gt; vec[N];struct edge{    ll u, v, w;    edge(ll a, ll b, ll c):u(a),v(b), w(c) {}    edge() {}    bool operator &lt; (edge &amp; t)const    {        return w &lt; t.w;    }} e[M];ll found(ll pre[], ll x){    return pre[x] == x ? x : found(pre, pre[x]);}ll Gauss(ll cnt){    ll res = 1;    for(ll i = 0; i &lt; cnt; ++i)        for(ll j = 0; j &lt; cnt; ++j)            C[i][j] %= p;    for(ll i = 0; i &lt; cnt; ++i)    {        for(ll j = i + 1; j &lt; cnt; ++j)        {            while(C[j][i])            {                ll t = C[i][i] / C[j][i];                for(ll k = i; k &lt; cnt; ++k)                    C[i][k] = (C[i][k] - C[j][k] * t) % p;                swap(C[i], C[j]);                res = -res;            }        }        if(C[i][i] == 0)            return 0L;        res = (res * C[i][i]) % p;    }    return (res + p) % p;}void Matrix_Tree(){    for(ll i = 0; i &lt; n; ++i)        if(vis[i])            vec[ found(K, i) ].push_back(i), vis[i] = 0;    for(ll i = 0; i &lt; n; ++i)        if(vec[i].size() &gt; 1)        {            memset(C, 0, sizeof(C));            ll len = vec[i].size();            for(ll j = 0; j &lt; len; ++j)                for(ll k = j + 1; k &lt; len; ++k)                {                    ll u = vec[i][j], v = vec[i][k];                    if(A[u][v])                    {                        C[j][k] = C[k][j] -= A[u][v];                        C[j][j] += A[u][v], C[k][k] += A[u][v];                    }                }            ans = ans * Gauss(len - 1) % p;            for(ll j = 0; j &lt; len; ++j)                F[ vec[i][j] ] = i;///Can&#39;t initial F[]/K[] with -1.        }    for(ll i = 0; i &lt; n; ++i)        vec[i].clear(), K[i] = F[i] = found(F, i);}int main(){    while(~scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;m, &amp;p) &amp;&amp; n)    {        ll u, v, w;        for(ll i = 0; i &lt; m; ++i)        {            scanf(&quot;%lld %lld %lld&quot;, &amp;u, &amp;v, &amp;w);            u--, v--;            e[i] = edge(u, v, w);        }        sort(e, e + m);        ans = 1;        memset(A, 0, sizeof(A));        for(ll i = 0; i &lt; n; ++i)            K[i] = F[i] = i;        for(ll i = 0; i &lt;= m; ++i)        {            if(i &amp;&amp; e[i].w != e[i - 1].w || i == m)                Matrix_Tree();            u = found(F, e[i].u), v = found(F, e[i].v);            if(u != v)            {                vis[u] = vis[v] = 1;                K[ found(K, u) ] = found(K, v);                A[u][v]++, A[v][u]++;            }        }        bool flag = 1;        for(ll i = 1; i &lt; n; ++i)            if(F[i] != F[i - 1])            {                flag = 0;                break;            }        printf(&quot;%lld\n&quot;, flag ? ans % p : 0);    }    return 0;}</code></pre><blockquote><p>有人说路径压缩会影响点的度数什么的，进而影响邻接矩阵的正确性，故不能使用路径压缩，我想不明白，不过我试了一下路径压缩，也能AC。</p></blockquote><h3 id="还是不理解的地方"><a href="#还是不理解的地方" class="headerlink" title="还是不理解的地方"></a>还是不理解的地方</h3><pre><code class="lang-c++">            for(ll j = 0; j &lt; len; ++j)                F[ vec[i][j] ] = i;///Can&#39;t initial F[]/K[] with -1.        }    for(ll i = 0; i &lt; n; ++i)        vec[i].clear(), K[i] = F[i] = found(F, i);}</code></pre><blockquote><p>Matrix_Tree()函数里后一部分，这里(两个循环)是在更新，可是K不就是新图吗？把K拷贝给F不行吗？我试了不行。所以这算法我还有一个点没想明白，一个很大的、很重要的点！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4305 Lightning(Count spanning trees)</title>
      <link href="2020/04/06/HDU-4305-Lightning-Count-spanning-trees/"/>
      <url>2020/04/06/HDU-4305-Lightning-Count-spanning-trees/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>求生成树有几种形状？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>跟普通生成树计数不同的是，例如一个三角形的图的生成树有三种形状，倘若把这个三角形压成一条线，那生成树就只有一种形状了。</p><p>解决办法是：若某两点看似可以连接时，判断一下，若两点连线中间还有点，则这两点不能连线。</p></blockquote><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><blockquote><p>关于取模，含有负数时<code>((x % mod) + mod) % mod</code>，不含有负数时<code>x % mod</code>,倘若有除法取模要用逆元，据说少量逆元可以类似递推出来？</p></blockquote><pre><code class="lang-c++">void init(){    inv[1]=1;    for(int i = 2;i &lt; M;i++)        inv[i] = (M - M / i) * inv[M % i] % M;}</code></pre><blockquote><p>时间卡的紧：</p><p>本来用double的数据迫不得已改用了int</p><p>多个判断条件并列时，耗时少的判断放前面</p></blockquote><pre><code class="lang-c++">if(A &amp;&amp; B &amp;&amp; C){    //do something;}</code></pre><blockquote><p>比如上述代码，A可能只是个普通bool型变量，B可能是一个长长的表达式，C可能是一个循环才能算得出值的bool变量</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define mod int(1e4 + 7)const int N = 305;int n, b[N][N], R, x[N], y[N];double getDis(int u, int v){    return sqrt( (x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v]) );}bool sameLine(int a, int b, int c){    bool line = (x[a] - x[b])*(y[b] - y[c]) == (y[a] - y[b])*(x[b]-x[c]);    bool middle = (x[c] &gt; x[a] &amp;&amp; x[c] &lt; x[b]) || (x[c] &gt; x[b] &amp;&amp; x[c] &lt; x[a]) ;    return line &amp;&amp; middle;}int Gauss(){    int res = 1;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)            b[i][j] %= mod;    for(int i = 2; i &lt;= n; ++i)    {        for(int j = i + 1; j &lt;= n; ++j)        {            while(b[j][i])///turn first not 0 element in row[j] into 0            {                int t = b[i][i] / b[j][i];                for(int k = i; k &lt;= n; ++k)                    b[i][k] = (b[i][k] - b[j][k] * t) % mod;                swap(b[i], b[j]);                res = -res;            }        }        if(b[i][i] == 0)            return -1;        res = (res * b[i][i]) % mod;    }    return (res + mod) % mod;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;R);        memset(b, 0,sizeof(b));        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d %d&quot;, &amp;x[i], &amp;y[i]);        for(int i = 1; i &lt;= n; ++i)            for(int j = i + 1; j &lt;= n; ++j)            {                if(!(getDis(i, j) &lt;= R))                    continue;                bool flag = 1;                for(int k = 1; k &lt;= n; ++k)                    if(k != i &amp;&amp; k != j &amp;&amp; sameLine(i, j, k))                    {                        flag = 0;                        break;                    }                if(flag)                    b[i][i]++, b[j][j]++, b[i][j] = b[j][i] = -1;            }        cout &lt;&lt; Gauss() &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPOJ Highways and Find the Determinant lll(Count the spanning trees)</title>
      <link href="2020/04/06/SPOJ-Highways-and-Find-the-Determinant-lll-Count-the-spanning-trees/"/>
      <url>2020/04/06/SPOJ-Highways-and-Find-the-Determinant-lll-Count-the-spanning-trees/</url>
      
        <content type="html"><![CDATA[<h3 id="Description-of-Highways"><a href="#Description-of-Highways" class="headerlink" title="Description of Highways"></a>Description of Highways</h3><blockquote><p>给出原图(无向图)，求裸的生成树计数</p></blockquote><h3 id="Description-of-Find-the-Determinant-III"><a href="#Description-of-Find-the-Determinant-III" class="headerlink" title="Description of Find the Determinant III"></a>Description of Find the Determinant III</h3><blockquote><p>求方阵A的行列式的值模P的值</p></blockquote><a id="more"></a><h3 id="Code-of-Highways"><a href="#Code-of-Highways" class="headerlink" title="Code of Highways"></a>Code of Highways</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int N = 55;int n, m;ll b[N][N];ll Gauss(){    ll res = 1;    ///i start from 2 : throw away first row and first column    for(int i = 2; i &lt;= n; ++i)    {        for(int j = i + 1; j &lt;= n; ++j)        {            while(b[j][i])            {                ll t = b[i][i] / b[j][i];                for(int k = i; k &lt;= n; ++k)                    b[i][k] -= b[j][k] * t;                for(int k = i; k &lt;= n; ++k)                    swap(b[i][k], b[j][k]);                res *= -1;            }        }        if(b[i][i] == 0)            return 0;        res *= b[i][i];    }    return res &gt; 0 ? res : -res;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        memset(b, 0,sizeof(b));        int u, v;        while(m--)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            b[u][u]++, b[v][v]++, b[u][v] = b[v][u] = -1;        }        cout &lt;&lt; Gauss() &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>注意建图(基尔霍夫矩阵)</p></blockquote><h3 id="Code-of-Find-The-Determinant-III"><a href="#Code-of-Find-The-Determinant-III" class="headerlink" title="Code of Find The Determinant III"></a>Code of Find The Determinant III</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long long#define MOD(x) ((x % m) + m) % mconst int N = 210;int n, m;ll b[N][N];ll Gauss(){    ll res = 1;    for(int i = 1; i &lt;= n; ++i)    {        for(int j = i + 1; j &lt;= n; ++j)        {            while(b[j][i])            {                ll t = b[i][i] / b[j][i];                for(int k = i; k &lt;= n; ++k)                    b[i][k] = MOD(b[i][k] - b[j][k] * t);                for(int k = i; k &lt;= n; ++k)                    swap(b[i][k], b[j][k]);                res *= -1;            }        }        if(b[i][i] == 0)            return 0;        res = MOD(res * b[i][i]);    }    return res &gt; 0 ? res : -res;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        memset(b, 0,sizeof(b));        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)            {                scanf(&quot;%lld&quot;, &amp;b[i][j]);                b[i][j] = MOD(b[i][j]);            }        cout &lt;&lt; Gauss() &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>注意不能再求主子式的行列式了，就是求原行列式</p><p>注意取模</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 10766 Organising the Organisation(Count spanning tree)</title>
      <link href="2020/04/05/UVA-10766-Organising-the-Organisation-Count-spanning-tree/"/>
      <url>2020/04/05/UVA-10766-Organising-the-Organisation-Count-spanning-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N个点的无向图的补图，求原图最小生成树的数目</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><p><img src="https://i.postimg.cc/Xvz3St2Z/4-MJ9-94-QR3-LLC-O-4-6-A.png" alt="Kirchhoff Matrix-Tree theorem"></p><blockquote><p>可证的事实：如果图G是一棵树，那么它的Kirchhoff矩阵的每一个n - 1阶主子式的行列式都是1。</p><p>推理：如果图G包含X棵树，那么它的Kirchhoff矩阵的每一个n - 1阶主子式的行列式都包含X个1，即X</p><p>另外解行列式采用高斯消元(转为上三角行列式)，与线性代数课上所学的方法有点差异，课上的方法直接了当，前面的行不变，处理后面的行，使得下三角逐渐变为全0(从左至右，从上到下)，但会出现小数。为了避免出现小数，采用如下方法：将“首 需处理 行”与“目标行”运算，使首非零元变0，然后交换两行。由于“首 需处理 行”首非零元总是 &gt;= “目标行”首非零元，因此不会出现小数。</p></blockquote><p><img src="https://i.postimg.cc/15FpgNbX/S-0-CY3-S9-RC1-QSG-29-CL3.png" alt="process"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int N = 55;int n, m, K;ll a[N][N], b[N][N];ll Gauss(){    ll res = 1;    ///i start from 2 : throw away first row and first column    for(int i = 2; i &lt;= n; ++i)    {        for(int j = i + 1; j &lt;= n; ++j)        {            while(b[j][i])///turn first not 0 element in row[j] into 0            {                ll t = b[i][i] / b[j][i];                for(int k = i; k &lt;= n; ++k)                    b[i][k] -= b[j][k] * t;                for(int k = i; k &lt;= n; ++k)                    swap(b[i][k], b[j][k]);                res *= -1;///Don&#39;t forget it!            }        }        if(b[i][i] == 0)            return 0;        res *= b[i][i];    }    return res &gt; 0 ? res : -res;}int main(){    while(~scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;K))    {        memset(a, 0,sizeof(a));        memset(b, 0,sizeof(b));        int u, v;        while(m--)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            a[u][v] = a[v][u] = 1;        }        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(i != j &amp;&amp; !a[i][j])                    b[i][i]++, b[i][j]--;        cout &lt;&lt; Gauss() &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p><a href="https://github.com/fireworks99/Documents/blob/master/周冬《生成树的计数及其应用》.pdf" target="_blank" rel="noopener">https://github.com/fireworks99/Documents/blob/master/%E5%91%A8%E5%86%AC%E3%80%8A%E7%94%9F%E6%88%90%E6%A0%91%E7%9A%84%E8%AE%A1%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E3%80%8B.pdf</a></p><p>周冬《生成树的计数及其应用》</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4009 Transfer water(Minimun tree-shape graph)</title>
      <link href="2020/04/05/HDU-4009-Transfer-water-Minimun-tree-shape-graph/"/>
      <url>2020/04/05/HDU-4009-Transfer-water-Minimun-tree-shape-graph/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个房子搬到山上，要解决供水问题有两种方案：</p><p>①自己打井，耗钱 (X * 房子高度)</p><p>②从别家引水，耗钱 (Y * 两房子的曼哈顿距离)，如果源较低，再加一个水泵钱Z</p><p>求解决所有房子供水问题的最小花费</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>不难发现是一个不定根的题目 -&gt; 增加一个伪根。</p><p>但是在建图时，“饮水”的边正常建立，“打井”如何处理？看似“自给自足”让人想到自环，可两者没什么关系，添自环不解决问题。</p><p>而且对于独立点，即使不能生成最小树形图，也可以”打井”完成任务，这种情况如何求最小花费？</p></blockquote><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><blockquote><p><strong>将伪根连向各点的边的权值设为该点打井花费！</strong></p><p>实现了“打井”与“引水”一视同仁，可计算最小花费。</p><p>什么完美的建模思想！</p><p>这跟之前做过的一道最短路相似，那题是“昂贵的聘礼”，给定了终点，也是不定根(起点任选)，求最短路。但是不仅边有权值，每个点也有权值，意味着从每个点出发的花费不同，这时建立超级源点连向各点的边的权值就应该设为各点权值！</p><p>这是一类<strong>“不定根 &amp;&amp; 点有权值”</strong>的图论题目</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;const int INF = 0x3f3f3f3f;int n, m, X, Y, Z, id[N], pre[N], vis[N], in[N], x[N], y[N], z[N];struct edge{    int u, v, w;}e[N * N];///Pay attention to the number of edges!int getDis(int a, int b){    return Y * (abs(x[a] - x[b]) + abs(y[a] - y[b]) + abs(z[a] - z[b])) + (z[b] &gt; z[a] ? Z :0);}int zhuliu(int root){    int u, v, res = 0;    while(true)    {        ///1.Set of in        for(int i = 1; i &lt;= n; ++i)            in[i] = -1;        for(int i = 1; i &lt;= m; ++i)            if(e[i].u != e[i].v &amp;&amp; (e[i].w &lt; in[ e[i].v ] || in[ e[i].v ] &lt; 0))                in[ e[i].v ] = e[i].w, pre[ e[i].v ] = e[i].u;        for(int i = 1; i &lt;= n; ++i)            if(i != root &amp;&amp; in[i] &lt; 0)                return -1;        ///2.Directed circle        int cnt = 1;        memset(id, -1, sizeof(id));        memset(vis,-1, sizeof(vis));        in[root] = 0;        for(int i = 1; i &lt;= n; ++i)        {            res += in[i];            v = i;            while(id[v] == -1 &amp;&amp; v != root &amp;&amp; vis[v] != i)                vis[v] = i, v = pre[v];            if(id[v] == -1 &amp;&amp; v != root)///   vis[v] == i            {                for(u = pre[v]; u != v; u = pre[u])                    id[u] = cnt;                id[v] = cnt++;            }        }        ///3.No circle -&gt; Over        if(cnt == 1)            break;        ///4.Process other nodes ,and then &quot;shrink&quot;.        for(int i = 1; i &lt;= n; ++i)            if(id[i] == -1)                id[i] = cnt++;        for(int i = 1; i &lt;= m; ++i)        {            v = e[i].v;            e[i].u = id[ e[i].u ];            e[i].v = id[ e[i].v ];            if(e[i].u != e[i].v)                e[i].w -= in[v];///This v is the original v!        }        n = cnt - 1;        root = id[root];    }    return res;}int main(){    while(~scanf(&quot;%d %d %d %d&quot;, &amp;n, &amp;X, &amp;Y, &amp;Z) &amp;&amp; !(n + X + Y + Z == 0))    {        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;x[i], &amp;y[i], &amp;z[i]);            e[i].u = n + 1, e[i].v = i, e[i].w = z[i] * X;        }        m = n;        int tem, num;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;num);            while(num--)            {                scanf(&quot;%d&quot;, &amp;tem);                e[++m].u = i, e[m].v = tem, e[m].w = getDis(i, tem);            }        }        int ans = zhuliu(++n);        printf(&quot;%d\n&quot;, ans);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の树形图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2121 Ice-cream&#39;s world II(Minimum tree-shape graph)</title>
      <link href="2020/04/04/HDU-2121-Ice-cream-s-world-II-Minimum-tree-shape-graph/"/>
      <url>2020/04/04/HDU-2121-Ice-cream-s-world-II-Minimum-tree-shape-graph/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点(0~N-1)M条有向边，不定根(任意一点可选做根节点)求最小树形图</p></blockquote><a id="more"></a><h3 id="Anlyze"><a href="#Anlyze" class="headerlink" title="Anlyze"></a>Anlyze</h3><blockquote><p>增加一个超级节点”伪根“，连向每一个点。</p><p>关于这些边的权值：</p><p>①最初想的是像最短路题目似的，将超点连向各点的边的权值设为0，最后得出的最短路长度就直接是答案。后来想想不对，朱刘算法第一步找“最小入边集”，那样选出来的最小入边集就是这新增的N条边了。</p><p>②所以为了不影响寻找正常的最小入边集，这新增的N条边的权值应该比最小入边集里所有边的长度都要大，假设最小入边集中最长边长度为X，那这N条新边权值要设为 &gt;= X的一个数。</p><p>③那样做还要先求一遍最小入边集，干脆放大一下，找原图所有边中的最长边，设为Y，那么这N条新边的边权要 &gt;= Y;</p><p>④还有个问题，我在求最小树形图时，用了两条“新边”（理论上应该只用一条：u=伪根，v=真根 の那条边），后期无法鉴别。而倘若我直接把“新边”边权设为sum(原图所有边的边权和)，最后答案小于2倍的sum才算真正找到了最小树形图。</p><p>所以说N条新边的边权应 &gt;= sum，最后记得从答案里减掉一个新边边权。</p><p>关于寻找“真根”：</p><p>理论上来说，在选最小入边集时，我们记录了每个点的前驱，if(u == 伪根) 则v == 真根。但还要“缩点”，“缩点”会使所有点的下标屡次改变，这时记录的点就无意义了。</p><p>但是，我们是按顺序添加新边的，比如某条新边下标为m + x,它从伪根指向节点x，那么即使后来缩点了，那唯一一条连接伪根与真根的边，它的u、v都变了，但下边没变，那么那条边依然是独一无二的(它曾指向“真根”，证据就是它的下标 - m == 真根)。(事实上每条边都是独一无二的）</p></blockquote><pre><code class="lang-c++">5 54 3 13 1 21 4 31 2 12 0 1///1.Set of infor(int i = 0; i &lt; n; ++i)    in[i] = -1;for(int i = 1; i &lt;= m; ++i)    if(e[i].u != e[i].v &amp;&amp; (e[i].w &lt; in[ e[i].v ] || in[ e[i].v ] &lt; 0))    {        in[ e[i].v ] = e[i].w, pre[ e[i].v ] = e[i].u;        if(e[i].u == root)        {            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; e[i].u &lt;&lt; &#39; &#39; &lt;&lt; e[i].v &lt;&lt; &#39;\n&#39;;            start = i;        }    }</code></pre><blockquote><p>理解第一个if的第二个条件，在缩点后的意义:选取环上最长边的终点v作为此环的“进入点”</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;const int INF = 0x3f3f3f3f;int n, m, id[N], pre[N], vis[N], in[N], start;struct edge{    int u, v, w;}e[10 * N + N];///Pay attention to the number of edges!int zhuliu(int root){    int u, v, res = 0;    while(true)    {        ///1.Set of in        for(int i = 0; i &lt; n; ++i)            in[i] = -1;        for(int i = 1; i &lt;= m; ++i)            if(e[i].u != e[i].v &amp;&amp; (e[i].w &lt; in[ e[i].v ] || in[ e[i].v ] &lt; 0))            {                in[ e[i].v ] = e[i].w, pre[ e[i].v ] = e[i].u;                if(e[i].u == root)                    start = i;            }        for(int i = 0; i &lt; n; ++i)            if(i != root &amp;&amp; in[i] &lt; 0)                return -1;        ///2.Directed circle        int cnt = 0;        memset(id, -1, sizeof(id));        memset(vis,-1, sizeof(vis));        in[root] = 0;        for(int i = 0; i &lt; n; ++i)        {            res += in[i];            v = i;            while(id[v] == -1 &amp;&amp; v != root &amp;&amp; vis[v] != i)                vis[v] = i, v = pre[v];            if(id[v] == -1 &amp;&amp; v != root)///   vis[v] == i            {                for(u = pre[v]; u != v; u = pre[u])                    id[u] = cnt;                id[v] = cnt++;            }        }        ///3.No circle -&gt; Over        if(cnt == 0)            break;        ///4.Process other nodes ,and then &quot;shrink&quot;.        for(int i = 0; i &lt; n; ++i)            if(id[i] == -1)                id[i] = cnt++;        for(int i = 1; i &lt;= m; ++i)        {            v = e[i].v;            e[i].u = id[ e[i].u ];            e[i].v = id[ e[i].v ];            if(e[i].u != e[i].v)                e[i].w -= in[v];///This v is the original v!        }        n = cnt;        root = id[root];    }    return res;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        int u, v, w, tn = n, tm = m, sum = 0;        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);            e[i].u = u, e[i].v = v, e[i].w = w;            sum += w;        }        for(int i = 0; i &lt; n; ++i)        {            e[m + i + 1].u = n;            e[m + i + 1].v = i;            e[m + i + 1].w = sum + 1;        }        m += n, n++;///Pay attention to the order!        int ans = zhuliu(tn);        if(ans &lt; 0 || ans &gt;= 2 * (sum + 1))            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39; ;        else            printf(&quot;%d %d\n\n&quot;, ans - (sum + 1), start - tm - 1);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の树形图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3164 Command Network(Minimum tree-shape graph)</title>
      <link href="2020/04/03/POJ-3164-Command-Network-Minimum-tree-shape-graph/"/>
      <url>2020/04/03/POJ-3164-Command-Network-Minimum-tree-shape-graph/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点M条有向边，求以1位根节点最小树形图(有向最小生成树)</p></blockquote><a id="more"></a><h3 id="朱刘算法"><a href="#朱刘算法" class="headerlink" title="朱刘算法"></a>朱刘算法</h3><blockquote><p>①选出入边集：找到除root点之外，每一个点的所有入边中权值最小的，用数组in[]记录下这个最小权值，用pre[]记录到达该点的前驱。判断是否存在无入边的点(除了root)，若有，则无法成树。</p><p>②找有向环：倘若无环，则该入边集就是最小树形图，算法结束。</p><p>若有环，说明未成树，做缩点前期工作：记下环上每个点所属环的标号。</p><p>③缩点中期工作：将不属于环上的点“缩点”</p><p>④缩点后期工作：更新缩点后的图中的边的权值。因为我们在过程中“误+”了环中某一边，此时要减掉。重复以上过程。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;const int INF = 0x3f3f3f3f;int n, m, id[N], pre[N], vis[N];double x[N], y[N], in[N];struct edge{    int u, v;    double w;}e[4 * N * N];double getDis(double x, double y, double xx, double yy){    return sqrt((x - xx) * (x - xx) + (y - yy) * (y - yy));}double zhuliu(int root){    int u, v;    double res = 0;    while(true)    {        ///①.Set of in        for(int i = 1; i &lt;= n; ++i)            in[i] = -1.0;        for(int i = 1; i &lt;= m; ++i)            if(e[i].u != e[i].v &amp;&amp; (e[i].w &lt; in[ e[i].v ] || in[ e[i].v ] &lt; 0))                in[ e[i].v ] = e[i].w, pre[ e[i].v ] = e[i].u;        for(int i = 1; i &lt;= n; ++i)            if(i != root &amp;&amp; in[i] &lt; 0)                return -1.0;        ///②.Directed circle        int cnt = 1;        memset(id, -1, sizeof(id));        memset(vis,-1, sizeof(vis));        in[root] = 0;        for(int i = 1; i &lt;= n; ++i)        {            res += in[i];            v = i;            while(id[v] == -1 &amp;&amp; v != root &amp;&amp; vis[v] != i)                vis[v] = i, v = pre[v];            if(id[v] == -1 &amp;&amp; v != root)///   vis[v] == i            {                for(u = pre[v]; u != v; u = pre[u])                    id[u] = cnt;                id[v] = cnt++;            }        }        ///③.No circle -&gt; Over        if(cnt == 1)            break;        ///④.Process other nodes ,and then &quot;shrink&quot;.        for(int i = 1; i &lt;= n; ++i)            if(id[i] == -1)                id[i] = cnt++;        for(int i = 1; i &lt;= m; ++i)        {            v = e[i].v;            e[i].u = id[ e[i].u ];            e[i].v = id[ e[i].v ];            if(e[i].u != e[i].v)                e[i].w -= in[v];///This v is the original v!        }        n = cnt - 1;        root = id[root];    }    return res;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%lf %lf&quot;, &amp;x[i], &amp;y[i]);        int u, v;        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            e[i].u = u, e[i].v = v;            e[i].w = getDis(x[u], y[u], x[v], y[v]);        }        double ans = zhuliu(1);        if(ans &lt; 0)            cout &lt;&lt; &quot;poor snoopy&quot; &lt;&lt; &#39;\n&#39;;        else            printf(&quot;%.2f\n&quot;, ans);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树の树形图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 10600 ACM Contest and Blackout(Second MST)</title>
      <link href="2020/03/23/UVA-10600-ACM-Contest-and-Blackout-Second-MST/"/>
      <url>2020/03/23/UVA-10600-ACM-Contest-and-Blackout-Second-MST/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点M条边，求最小生成树与次小生成树</p><p>（求生成树，说明边是无向边）</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>设原图G(V, E)，最小生成树T(V1, E1)，现有边<code>(u, v)∈G &amp;&amp; (u, v)∉T</code>。u与v之间有唯一的一条路径，将这条路上若干段中最长的一段的长度存储在<code>len[u][v]</code>里，将边(u, v)加入到T中，u与v间形成了环，删掉<code>len[u][v]</code>对应那条边就是一颗准次小生成树了。</p><p>遍历所有的非最小生成树内的边，求出相应的一个个准次小生成树，这里面最小的一个就是真正的次小生成树了。</p><p><code>len[u][v]</code>求解</p><p>Prim：类似于DP的方法<code>len[i][pos] = len[pos][i] = max(len[i][pre[pos]], low[pos]);</code></p><p>Kruskal：有先天优势(边是按权值从小到大排序的，即：当前边的权值是当前已经出现的所有边中的最大值，此时用<strong>当前的边</strong>将两个集合连接，两集合内各取一点，他们之间路径上最大边就是当前边)<code>len[ G[aa][i] ][ G[bb][j] ] = len[ G[bb][j] ][ G[aa][i] ] = w;</code></p></blockquote><h3 id="Code-of-Prim"><a href="#Code-of-Prim" class="headerlink" title="Code of Prim"></a>Code of Prim</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 105;int n, m, MST, SecondMST;int mp[N][N], len[N][N], pre[N], low[N];bool vis[N], used[N][N];int Prim(){    int ans = 0;    memset(len, 0, sizeof(len));    memset(vis, 0, sizeof(vis));    memset(used, 0, sizeof(used));    ans += 0, vis[1] = 1;    for(int i = 1; i &lt;= n; ++i)    {        low[i] = mp[i][1];        pre[i] = 1;    }    int cnt = n, mmin = INF, pos = 1;    while(--cnt)    {        mmin = INF;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; low[i] &lt; mmin)                mmin = low[i], pos = i;        ///if(mmin == INF)        ans += mmin, vis[pos] = 1;        used[pos][pre[pos]] = used[pre[pos]][pos] = 1;        for(int i = 1; i &lt;= n; ++i)        {            if(vis[i] &amp;&amp; i != pos)                len[i][pos] = len[pos][i] = max(len[i][pre[pos]], low[pos]);            if(!vis[i] &amp;&amp; low[i] &gt; mp[pos][i])                low[i] = mp[pos][i], pre[i] = pos;        }    }    return ans;}int SecondPrim(){    int ans = INF;    for(int i = 1; i &lt;= n; ++i)        for(int j = i + 1; j &lt;= n; ++j)            if(!used[i][j] &amp;&amp; mp[i][j] != INF)                ans = min(ans, MST + mp[i][j] - len[i][j]);    return ans;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt;= n; ++i)            for(int j = 0; j &lt;= n; ++j)                mp[i][j] = mp[j][i] = (i == j ? 0 : INF);        int u, v, w;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);            mp[u][v] = mp[v][u] = w;        }        MST = Prim();        SecondMST = SecondPrim();        cout &lt;&lt; MST &lt;&lt; &#39; &#39; &lt;&lt; SecondMST &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-of-Kruskal"><a href="#Code-of-Kruskal" class="headerlink" title="Code of Kruskal"></a>Code of Kruskal</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 105;int n, m, MST, SecondMST, pre[N], len[N][N];vector&lt;int&gt; G[N];int cnt;struct edge{    int there, here, w, vis;    bool operator &lt; (edge &amp; t)const    {        return w &lt; t.w;    }} e[N * N];int found(int x){    return pre[x] == -1 ? x : pre[x] = found(pre[x]);}int unite(int a, int b, int w){    int aa = found(a);    int bb = found(b);    if(aa != bb)    {        int asz = G[aa].size();        int bsz = G[bb].size();        for(int i = 0; i &lt; asz; ++i)            for(int j = 0; j &lt; bsz; ++j)                len[ G[aa][i] ][ G[bb][j] ] = len[ G[bb][j] ][ G[aa][i] ] = w;        pre[aa] = bb;        for(int i = 0; i &lt; asz; ++i)            G[bb].push_back(G[aa][i]);        return 1;    }    return 0;}int Kruskal(){    memset(pre, -1, sizeof(pre));    memset(len,  0, sizeof(len));    for(int i = 0; i &lt;= n; ++i)        G[i].clear(), G[i].push_back(i);    int ans = 0, tot = 0;    sort(e, e + cnt);    for(int i = 0; i &lt; cnt; ++i)    {        if(tot == n - 1)            break;        e[i].vis = unite(e[i].there, e[i].here, e[i].w);        ans += e[i].vis * e[i].w, tot += e[i].vis;    }    return ans;}int SecondKruskal(){    int ans = INF;    for(int i = 0; i &lt; m; ++i)        if(!e[i].vis)            ans = min(ans, MST + e[i].w - len[ e[i].there ][ e[i].here ]);    return ans;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        cnt = 0;        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;e[cnt].there, &amp;e[cnt].here, &amp;e[cnt].w);            e[cnt++].vis = 0;        }        MST = Kruskal();        SecondMST = SecondKruskal();        cout &lt;&lt; MST &lt;&lt; &#39; &#39; &lt;&lt; SecondMST &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1177 Picture(Segment Tree Scanning Lines)</title>
      <link href="2020/03/23/POJ-1177-Picture-Segment-Tree-Scanning-Lines/"/>
      <url>2020/03/23/POJ-1177-Picture-Segment-Tree-Scanning-Lines/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>矩形相交，求合并后的周长</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>算面积的时候主乘法，算周长的时候主加法</p><p>平行于扫描线方向上<strong>新增</strong>的长度 = <code>abs(新len[1] - 旧len[1])</code></p><p>垂直于扫描线方向上新增的长度 = <code>tot[1] * (e[i + 1].h - e[i].h)</code></p><p>新增三个变量，ls(区间左端点是否被覆盖)、rs、tot(扫描线切割了几段)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n;int num;int X[N];int cnt[N &lt;&lt; 2 | 1];int len[N &lt;&lt; 2 | 1];int tot[N &lt;&lt; 2 | 1];bool ls[N &lt;&lt; 2 | 1];bool rs[N &lt;&lt; 2 | 1];struct edge{    int l, r, h;    int flag;    edge(int a, int b, int c, int d):l(a), r(b), h(c), flag(d){}    edge(){}    bool operator &lt; (const edge &amp; t)const    {        return h &lt; t.h;    }}e[N];void up(int o, int L, int R){    if(cnt[o])    {        tot[o] = 2;        ls[o] = rs[o] = 1;        len[o] = X[R + 1] - X[L];    }    else if(L == R)        tot[o] = len[o] = 0, ls[o] = rs[o] = 0;    else    {        len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];        ls[o] = ls[o &lt;&lt; 1], rs[o] = rs[o &lt;&lt; 1 | 1];        tot[o] = tot[o &lt;&lt; 1] + tot[o &lt;&lt; 1 | 1];        if(rs[o &lt;&lt; 1] &amp;&amp; ls[o &lt;&lt; 1 | 1])            tot[o] -= 2;    }}void update(int o, int L, int R, int l, int r, int val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        cnt[o] += val;        up(o, L, R);        return ;    }    if(L == R)        return ;    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, val);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    up(o, L, R);}int main(){    int t = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        num = 0;        memset(len, 0, sizeof(len));        memset(cnt, 0, sizeof(cnt));        memset(tot, 0, sizeof(tot));        memset(ls, 0, sizeof(ls));        memset(rs, 0, sizeof(rs));        int a, b, c, d;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            X[num] = a;            e[num++] = edge(a, c, b, 1);            X[num] = c;            e[num++] = edge(a, c, d, -1);        }        sort(e, e + num);        sort(X, X + num);        int m = unique(X, X + num) - X;        long long ans = 0;        int last = 0;        for(int i = 0; i &lt; num; ++i)        {            int l = lower_bound(X, X + m, e[i].l) - X;///Segment Tree begins with 0            int r = lower_bound(X, X + m, e[i].r) - X - 1;            update(1, 0, m - 1, l, r, e[i].flag);            ans += tot[1] * (e[i + 1].h - e[i].h);            ans += abs(len[1] - last);            last = len[1];        }        printf(&quot;%lld\n&quot;, ans);    }    return 0;}</code></pre><blockquote><p>扫描线题目主要是针对特殊变量（像本题目中tot、ls、rs）设计up函数</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 3642 Get The Treasury(Segment Tree Scanning Lines)</title>
      <link href="2020/03/22/HDU-3642-Get-The-Treasury-Segment-Tree-Scanning-Lines/"/>
      <url>2020/03/22/HDU-3642-Get-The-Treasury-Segment-Tree-Scanning-Lines/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>长方体相交，求相交至少3次部分的体积</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>相交至少三次与相交至少两次的处理方法一样</p><p>然后三维，降维做题，遍历Z轴，一层一层地求解</p><p>还有一点要注意，<code>ans += len3[1] * (e[i + 1].h - e[i].h);</code>不行了，相邻的两个面，e[i + 1]与e[i]只是y轴上相邻，Z轴上可能天上地下，所以用一个变量last记录<strong>本层</strong>前一个y</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20010;int n;int num;int X[N];int cnt[N &lt;&lt; 2 | 1];int len1[N &lt;&lt; 2 | 1], len2[N &lt;&lt; 2 | 1], len3[N &lt;&lt; 2 | 1];struct edge{    int l, r, h, zd, zu;    int flag;    edge(int a, int b, int c, int d, int f, int g):l(a), r(b), h(c), flag(d), zd(f), zu(g) {}    edge() {}    bool operator &lt; (const edge &amp; t)const    {        return h &lt; t.h;    }} e[N];void up(int o, int L, int R){    if(cnt[o])        len1[o] = X[R + 1] - X[L];    else if(L == R)        len1[o] = 0;    else        len1[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];    if(cnt[o] &gt;= 2)        len2[o] = X[R + 1] - X[L];    else if(L == R)        len2[o] = 0;    else    {        if(cnt[o] == 1)            len2[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];        else            len2[o] = len2[o &lt;&lt; 1] + len2[o &lt;&lt; 1 | 1];    }    if(cnt[o] &gt;= 3)        len3[o] = X[R + 1] - X[L];    else if(L == R)        len3[o] = 0;    else    {        if(cnt[o] == 2)            len3[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];        else if(cnt[o] == 1)            len3[o] = len2[o &lt;&lt; 1] + len2[o &lt;&lt; 1 | 1];        else            len3[o] = len3[o &lt;&lt; 1] + len3[o &lt;&lt; 1 | 1];    }}void update(int o, int L, int R, int l, int r, int val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        cnt[o] += val;        up(o, L, R);        return ;    }    if(L == R)        return ;    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, val);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    up(o, L, R);}int main(){    int _, t = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d&quot;, &amp;n);        num = 0;        int a, b, c, d, f, g;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d %d %d %d %d %d&quot;, &amp;a, &amp;b, &amp;f, &amp;c, &amp;d, &amp;g);            X[num] = a;            e[num++] = edge(a, c, b, 1, f, g);            X[num] = c;            e[num++] = edge(a, c, d, -1, f, g);        }        sort(e, e + num);        sort(X, X + num);        int m = unique(X, X + num) - X;        long long ans = 0;        for(int z = -500; z &lt;= 500; ++z)        {            memset(cnt, 0, sizeof(cnt));            memset(len1, 0, sizeof(len1));            memset(len2, 0, sizeof(len2));            memset(len3, 0, sizeof(len3));            int last = 0;            for(int i = 0; i &lt; num; ++i)            {                if(z &gt;= e[i].zd &amp;&amp; z &lt; e[i].zu)                {                    int l = lower_bound(X, X + m, e[i].l) - X;///Segment Tree begins with 0                    int r = lower_bound(X, X + m, e[i].r) - X - 1;                    ans += (long long)len3[1] * (e[i].h - last);                    update(1, 0, m - 2, l, r, e[i].flag);                    last = e[i].h;                }            }        }        printf(&quot;Case %d: %lld\n&quot;, t++, ans);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1255 Covered area(Segment Tree Scanning Lines)</title>
      <link href="2020/03/22/HDU-1255-Covered-area-Segment-Tree-Scanning-Lines/"/>
      <url>2020/03/22/HDU-1255-Covered-area-Segment-Tree-Scanning-Lines/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>多个矩形相交，求至少被覆盖过两次的面积</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>相对于求矩形面积并集，此题所求的特点在于<code>cnt[o] &gt;= 2</code> 才有 <code>len[o] = X[R + 1] - X[L];</code>。另外这要求每段的cnt及时更新，而之前那种方法不down，数据没有被正确表示，而现在就需要用上lazy数组down下去了。</p><p>另外加一个query函数释放所有的lazy以更新数据</p><p>对于之前写过的线段树们，下面节点的状态没被更新不影响上面节点状态的正确性，而这一题下面节点不被lazy更新会导致上面节点呈现着错误的状态，所以每次从线段树取值时都需要释放所有lazy更新这棵树。</p><p>现在这种方案：需要用到线段树维护的值时，释放全部lazy</p><p>相比较于：不用lazy，每次update都更新到底</p><p>还是省时间的</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2100;int n;int num;double X[N];int cnt[N &lt;&lt; 2 | 1], lazy[N &lt;&lt; 2 | 1];double len[N &lt;&lt; 2 | 1];struct edge{    double l, r, h;    int flag;    edge(double a, double b, double c, int d):l(a), r(b), h(c), flag(d){}    edge(){}    bool operator &lt; (const edge &amp; t)const    {        return h &lt; t.h;    }}e[N];void down(int o, int L, int R){    if(lazy[o] != 0)    {        cnt[o &lt;&lt; 1] += lazy[o];        cnt[o &lt;&lt; 1 | 1] += lazy[o];        lazy[o &lt;&lt; 1] += lazy[o];        lazy[o &lt;&lt; 1 | 1] += lazy[o];        lazy[o] = 0;    }}void up(int o, int L, int R){    if(cnt[o] &gt;= 2)        len[o] = X[R + 1] - X[L];    else if(L == R)        len[o] = 0;    else        len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];}void update(int o, int L, int R, int l, int r, int val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        cnt[o] += val;        lazy[o] += val;        up(o, L, R);        return ;    }    if(L == R)        return ;    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, val);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    up(o, L, R);}void query(int o, int L, int R){    if(L == R)    {        up(o, L, R);        return ;    }    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    query(o &lt;&lt; 1, L, mid);    query(o &lt;&lt; 1 | 1, mid + 1, R);    up(o, L, R);}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        num = 0;        memset(len, 0, sizeof(len));        memset(cnt, 0, sizeof(cnt));        memset(lazy, 0, sizeof(lazy));        double a, b, c, d;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lf %lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            X[num] = a;            e[num++] = edge(a, c, b, 1);            X[num] = c;            e[num++] = edge(a, c, d, -1);        }        sort(e, e + num);        sort(X, X + num);        int m = unique(X, X + num) - X;        double ans = 0;        for(int i = 0; i &lt; num; ++i)        {            int l = lower_bound(X, X + m, e[i].l) - X;///Segment Tree begins with 0            int r = lower_bound(X, X + m, e[i].r) - X - 1;            update(1, 0, m - 2, l, r, e[i].flag);            query(1, 0, m - 2);            ans += len[1] * (e[i + 1].h - e[i].h);        }        printf(&quot;%.2f\n&quot;, ans);    }    return 0;}</code></pre><h3 id="方案2-就是不down"><a href="#方案2-就是不down" class="headerlink" title="方案2:就是不down"></a>方案2:就是不down</h3><blockquote><p>区分len1(区间被覆盖次数&gt;=1)与len2(区间覆盖次数&gt;=2)</p></blockquote><h4 id="up函数"><a href="#up函数" class="headerlink" title="up函数"></a>up函数</h4><pre><code class="lang-c++">void up(int o, int L, int R){    if(cnt[o])        len1[o] = X[R + 1] - X[L];    else if(L == R)        len1[o] = 0;    else        len1[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];    if(cnt[o] &gt;= 2)        len2[o] = X[R + 1] - X[L];    else if(L == R)        len2[o] = 0;    else    {        if(cnt[o] == 1)            len2[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];        else            len2[o] = len2[o &lt;&lt; 1] + len2[o &lt;&lt; 1 | 1];    }}</code></pre><blockquote><p>由于更新len2需要用到len1，所以先更新len1</p><p><code>len1[o] &gt;= len2[o]</code>一个区间被覆盖一次以上的长度不少于它被覆盖两次以上的长度，所以当cnt[o] &lt; 2时，如果cnt[o] == 1那就先用len1更新len2，否则再用len2更新len2.</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2100;int n;int num;double X[N];int cnt[N &lt;&lt; 2 | 1];double len1[N &lt;&lt; 2 | 1], len2[N &lt;&lt; 2 | 1];struct edge{    double l, r, h;    int flag;    edge(double a, double b, double c, int d):l(a), r(b), h(c), flag(d){}    edge(){}    bool operator &lt; (const edge &amp; t)const    {        return h &lt; t.h;    }}e[N];void up(int o, int L, int R){    if(cnt[o])        len1[o] = X[R + 1] - X[L];    else if(L == R)        len1[o] = 0;    else        len1[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];    if(cnt[o] &gt;= 2)        len2[o] = X[R + 1] - X[L];    else if(L == R)        len2[o] = 0;    else    {        if(cnt[o] == 1)            len2[o] = len1[o &lt;&lt; 1] + len1[o &lt;&lt; 1 | 1];        else            len2[o] = len2[o &lt;&lt; 1] + len2[o &lt;&lt; 1 | 1];    }}void update(int o, int L, int R, int l, int r, int val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        cnt[o] += val;        up(o, L, R);        return ;    }    if(L == R)        return ;    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, val);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    up(o, L, R);}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        num = 0;        memset(cnt, 0, sizeof(cnt));        memset(len1, 0, sizeof(len1));        memset(len2, 0, sizeof(len2));        double a, b, c, d;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lf %lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            X[num] = a;            e[num++] = edge(a, c, b, 1);            X[num] = c;            e[num++] = edge(a, c, d, -1);        }        sort(e, e + num);        sort(X, X + num);        int m = unique(X, X + num) - X;        double ans = 0;        for(int i = 0; i &lt; num; ++i)        {            int l = lower_bound(X, X + m, e[i].l) - X;///Segment Tree begins with 0            int r = lower_bound(X, X + m, e[i].r) - X - 1;            update(1, 0, m - 2, l, r, e[i].flag);            ans += len2[1] * (e[i + 1].h - e[i].h);        }        printf(&quot;%.2f\n&quot;, ans);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1151 Atlantis(Segment Tree about Scanning lines)</title>
      <link href="2020/03/21/POJ-1151-Atlantis-Segment-Tree-about-Scanning-lines/"/>
      <url>2020/03/21/POJ-1151-Atlantis-Segment-Tree-about-Scanning-lines/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>求N个矩形面积的并集</p></blockquote><a id="more"></a><h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><p><img src="https://i.postimg.cc/c4R1Dp7S/1584781758418.png" alt="Scanning Lines"></p><blockquote><p>线段树是可以从0开始的，只是保证标号从1开始就行</p><p>线段树每个点维护一段区间</p><p>当然需要离散化，将浮点数类型的x值对应成每条垂线的标号，这样之后可以用线段树维护当前扫描线的长度，计算具体长度时逆离散化。</p><p>扫描线长度 * 两条相邻两条水平线的高度差 = 矩形面积</p></blockquote><h3 id="Up"><a href="#Up" class="headerlink" title="Up"></a>Up</h3><pre><code class="lang-c++">void up(int o, int L, int R){    if(cnt[o])        len[o] = X[R + 1] - X[L];    else if(L == R)        len[o] = 0;    else        len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];}</code></pre><blockquote><p>这里按理说有if与else就行了，只是当L == R时不能按照else处理(叶子节点没有子节点了)，所以单独写一下。它等于0是因为这个不可分割的一段没有被覆盖，所以不取它。并不是因为什么“点没有长度”，这里线段树每个点也对应一段区间(不可再分割了)。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 210;int n;int num;double X[N];int cnt[N &lt;&lt; 2 | 1];double len[N &lt;&lt; 2 | 1];struct edge{    double l, r, h;    int flag;    edge(double a, double b, double c, int d):l(a), r(b), h(c), flag(d){}    edge(){}    bool operator &lt; (const edge &amp; t)const    {        return h &lt; t.h;    }}e[N];void up(int o, int L, int R){    if(cnt[o])        len[o] = X[R + 1] - X[L];    else if(L == R)        len[o] = 0;    else        len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];}void update(int o, int L, int R, int l, int r, int val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        cnt[o] += val;        up(o, L, R);        return ;    }    if(L == R)        return ;    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, val);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    up(o, L, R);}int main(){    int t = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        num = 0;        memset(len, 0, sizeof(len));        memset(cnt, 0, sizeof(cnt));        double a, b, c, d;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lf %lf %lf %lf&quot;, &amp;a, &amp;b, &amp;c, &amp;d);            X[num] = a;            e[num++] = edge(a, c, b, 1);            X[num] = c;            e[num++] = edge(a, c, d, -1);        }        sort(e, e + num);        sort(X, X + num);        int m = unique(X, X + num) - X;        double ans = 0;        for(int i = 0; i &lt; num; ++i)        {            int l = lower_bound(X, X + m, e[i].l) - X;///Segment Tree begins with 0            int r = lower_bound(X, X + m, e[i].r) - X - 1;            update(1, 0, m - 1, l, r, e[i].flag);            ans += len[1] * (e[i + 1].h - e[i].h);        }        printf(&quot;Test case #%d\nTotal explored area: %.2f\n\n&quot;, t++, ans);    }    return 0;}</code></pre><blockquote><ol><li><p>离散化不仅有节省空间的作用，也可以将非整型数字对应到整型数字上方便进行线段树等操作的作用。</p></li><li><p>update左右子节点的时候，按理说需要把当前状态(cnt[o])down下去，但是up的设计使得down可忽略，而且<code>cnt[o] += 1</code>与<code>cnt[o] += -1</code>的成对存在保证了不出错。</p><p>而这一做法使得理论与实际有一定偏差，比如最开始那张图，到达第二条扫描线时设[1, 1]这个区间标号为o，则理论上<code>cnt[o] = 2</code>，因为他被覆盖了两次，而实际上<code>cnt[o] = 1</code>，还有个1在它父节点那儿，并没有down下来，而实际上这样做并不会出错（就是因为1与-1的成对存在）。</p></li><li><p>update函数中第一次up出现在“当前区间从属于目标区间”时刻，是因为这里的up并不是纯粹的up，纯粹的up是依据左右子节点的值更新len[o]：<code>len[o] = len[o &lt;&lt; 1] + len[o &lt;&lt; 1 | 1];</code>，也就是up中else那部分。这里的up应该是依据形参val更新<code>len[o]</code>，也就是up函数中if那部分。而之所以不分开写，是应为这两处同时需要他们俩。</p></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4553 Date arrange(Segment Tree)</title>
      <link href="2020/03/20/HDU-4553-Date-arrange-Segment-Tree/"/>
      <url>2020/03/20/HDU-4553-Date-arrange-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>中文题目：小明</p><p>与DS开黑</p><p>与NS约会</p><p>学习</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>题目要求：寻找<strong>具有某种属性的、连续的最长</strong>区间</p><p>与HDU 1540相同，都是找符合某一特点的连续的最长区间</p><p>那么线段树也是一样的</p><p><code>val：ans、lmax、rmax</code>最长连续空间时间段的长度</p><p>此时ans起辅助作用，主角是lmax与rmax，只要down地足够深，要查找的区间总是某些个lmax与rmax的和。</p><p>此题维护两棵线段树：DS树与NS树</p><p>①DS x:</p><p>若DS树有长度足够的区间，去DS树上找结束位置(-x即起始位置)</p><p>将<strong>DS树</strong>对应区间三个val置零</p><p>找不到区间直接输出相应字符串</p><p>②NS x:</p><p>若DS树有长度足够的区间，去DS树上找结束位置(-x即起始位置)</p><p>将<strong>DS树和NS树</strong>对应区间三个val置零</p><p>若DS树没有足够空间，但NS树有足够空间，去NS书上找</p><p>将<strong>DS树和NS树</strong>对应区间三个val置零</p><p>若都没有足够空间，输出相应字符串</p><p>③STUDY x y:</p><p>将<strong>DS树和NS树</strong>对应区间恢复为1（即val值恢复为区间长度）</p><p>另外代码中的query函数，三分去找够大的空闲区间的第x时刻</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;char s[10];int n, m;///0 for DS and 1 for NSint lmax[N &lt;&lt; 2 | 1][2];int rmax[N &lt;&lt; 2 | 1][2];int ans[N &lt;&lt; 2 | 1][2];void down(int o, int L, int R)///related to the function of&quot;update&quot;{    int mid = (L + R) &gt;&gt; 1;    for(int idx = 0; idx &lt; 2; ++idx)    {        if(ans[o][idx] == R - L + 1)        {            lmax[o &lt;&lt; 1][idx] = rmax[o &lt;&lt; 1][idx] = ans[o &lt;&lt; 1][idx] =  mid - L + 1;            lmax[o &lt;&lt; 1 | 1][idx] = rmax[o &lt;&lt; 1 | 1][idx] = ans[o &lt;&lt; 1 | 1][idx] = R - mid;        }        if(ans[o][idx] == 0)        {            lmax[o &lt;&lt; 1][idx] = rmax[o &lt;&lt; 1][idx] = ans[o &lt;&lt; 1][idx] =  0;            lmax[o &lt;&lt; 1 | 1][idx] = rmax[o &lt;&lt; 1 | 1][idx] = ans[o &lt;&lt; 1 | 1][idx] = 0;        }    }}void up(int o, int L, int R){    int mid = (L + R) &gt;&gt; 1;    lmax[o][0] = lmax[o &lt;&lt; 1][0] + (lmax[o &lt;&lt; 1][0] == mid - L + 1 ? lmax[o &lt;&lt; 1 | 1][0] : 0);    lmax[o][1] = lmax[o &lt;&lt; 1][1] + (lmax[o &lt;&lt; 1][1] == mid - L + 1 ? lmax[o &lt;&lt; 1 | 1][1] : 0);    rmax[o][0] = rmax[o &lt;&lt; 1 | 1][0] + (rmax[o &lt;&lt; 1 | 1][0] == R - mid ? rmax[o &lt;&lt; 1][0] : 0);    rmax[o][1] = rmax[o &lt;&lt; 1 | 1][1] + (rmax[o &lt;&lt; 1 | 1][1] == R - mid ? rmax[o &lt;&lt; 1][1] : 0);    ans[o][0] = max(max(ans[o &lt;&lt; 1][0], ans[o &lt;&lt; 1 | 1][0]), rmax[o &lt;&lt; 1][0] + lmax[o &lt;&lt; 1 | 1][0]);    ans[o][1] = max(max(ans[o &lt;&lt; 1][1], ans[o &lt;&lt; 1 | 1][1]), rmax[o &lt;&lt; 1][1] + lmax[o &lt;&lt; 1 | 1][1]);}void build(int o, int l, int r){    if(l == r)    {        lmax[o][0] = rmax[o][0] = ans[o][0] = lmax[o][1] = rmax[o][1] = ans[o][1] = 1;        return ;    }    int mid = (l + r) &gt;&gt; 1;    build(o &lt;&lt; 1, l, mid);    build(o &lt;&lt; 1 | 1, mid + 1, r);    up(o, l, r);}void update(int o, int L, int R, int l, int r, int idx){    if(L &gt; r || R &lt; l)        return ;    if(L &gt;= l &amp;&amp; R &lt;= r)    {        if(idx == 0)///DS or NS1            lmax[o][0] = rmax[o][0] = ans[o][0] = 0;        else///NS2 or Study        {            lmax[o][0] = rmax[o][0] = ans[o][0] = (idx == 1 ? 0 : R - L + 1);            lmax[o][1] = rmax[o][1] = ans[o][1] = (idx == 1 ? 0 : R - L + 1);        }        return ;    }    if(L == R)        return ;    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    update(o &lt;&lt; 1, L, mid, l, r, idx);    update(o &lt;&lt; 1 | 1, mid + 1, R, l, r, idx);    up(o, L, R);}int query(int o, int L, int R, int x, int idx){    if(L == R)        return L;    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    if(ans[o &lt;&lt; 1][idx] &gt;= x)        return query(o &lt;&lt; 1, L, mid, x, idx);    else if(rmax[o &lt;&lt; 1][idx] + lmax[o &lt;&lt; 1 | 1][idx] &gt;= x)        return mid - rmax[o &lt;&lt; 1][idx] + x;    else        return query(o &lt;&lt; 1 | 1, mid + 1, R, x, idx);    up(o, L, R);}int main(){    int _, cnt = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        printf(&quot;Case %d:\n&quot;, cnt++);        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        build(1, 1, n);        int x, y;        while(m--)        {            scanf(&quot;%s%d&quot;, s, &amp;x);            if(s[0] == &#39;D&#39;)            {                if(ans[1][0] &gt;= x)                {                    int t = query(1, 1, n, x, 0);                    t = t - x + 1;                    printf(&quot;%d,let&#39;s fly\n&quot;, t);                    update(1, 1, n, t, t + x - 1, 0);                }                else                    cout &lt;&lt; &quot;fly with yourself\n&quot;;            }            else if(s[0] == &#39;N&#39;)            {                if(ans[1][0] &gt;= x)                {                    int t = query(1, 1, n, x, 0);                    t = t - x + 1;                    printf(&quot;%d,don&#39;t put my gezi\n&quot;, t);                    update(1, 1, n, t, t + x - 1, 1);                }                else if(ans[1][1] &gt;= x)                {                    int t = query(1, 1, n, x, 1);                    t = t - x + 1;                    printf(&quot;%d,don&#39;t put my gezi\n&quot;, t);                    update(1, 1, n, t, t + x - 1, 1);                }                else                    cout &lt;&lt; &quot;wait for me\n&quot;;            }            else            {                scanf(&quot;%d&quot;, &amp;y);                update(1, 1, n, x, y, 2);                cout &lt;&lt; &quot;I am the hope of chinese chengxuyuan!!\n&quot;;            }        }    }    return 0;}</code></pre><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><blockquote><ol><li>区间更新：该down的时候就应该down<br>单点更新：本质也是区间更新，只不过这个“区间”已经最低而不可分割了，故不需要down<br>结论：纯粹单点更新的题目不需要down，其他但凡涉及区间更新的题目都需要down(而且是根据update里面的内容来down)</li><li>数组代替结构体实现的线段树不一定可以完全由memset代替初始化，遇到需要up的就免不了</li><li>build函数里val的初始化要小心，考虑up的影响，可能与实际情况不一样！</li></ol></blockquote><pre><code class="lang-c++">if(A == B)    D = E;if(A == C)    D = F;</code></pre><blockquote><p>不可以写成：</p></blockquote><pre><code class="lang-c++">D = (A == B ? E : F)</code></pre><blockquote><p>因为上面是两个if，并非if-else</p><p>Debug半天…</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4614 Vases and Flowers(Segment Tree and Binary Search)</title>
      <link href="2020/03/19/HDU-4614-Vases-and-Flowers-Segment-Tree-and-Binary-Search/"/>
      <url>2020/03/19/HDU-4614-Vases-and-Flowers-Segment-Tree-and-Binary-Search/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>区间[0, n - 1]，初始值全0，有m次操作。<br>操作分两类：<br>1 X Y 从位置X开始寻找Y个0，如果不足Y个，则寻找尽量多的0，并将他们的值全部修改为1，输出第一个和最后一个修改的1的位置。<br>2 X Y 输出区间[ X , Y ]内1的个数，并将区间内的1修改为0。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>问题：</p><p>①关于找位置没有思路，不知道线段树的val记录什么才能方便找位置</p><p>②关于更新：区间[X, Y]内的0更新为1，这一点若是单点修改很费时，咋办</p><p>对策：</p><p>①val记录区间内1的个数，二分找答案</p><p>②不需要单点更新，区间更新即可，这种bool状态非此即彼，将区间内非0的单点修改为1等效于将整个区间所有点置1</p></blockquote><h3 id="Something-about-Segment-Tree"><a href="#Something-about-Segment-Tree" class="headerlink" title="Something about Segment Tree"></a>Something about Segment Tree</h3><blockquote><p>①关于懒惰：</p><p>像维护区间和这种要求，int型的lazy实现了两个作用：</p><p>1.是否需要down </p><p>2.down的值是多大。</p><p>而本题是维护“状态”(的区间和)，已知知道down多少(即区间长度)，原则上只用bool型变量标记一下就行，但实际上有三个状态(1.不需要down2.down‘1’3.down’0’)，要用int。</p><p>②不用结构体的线段树可以省去建树的过程，但是以后写其他函数形参里都要加两个变量L、R。涉及到子区间先写一下mid。</p><p>③update和query很简单的时候可以写在一起。</p><p>④val down 后是否需要up：视具体情境。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;int n, m, ans;bool change;int num[N &lt;&lt; 2 | 1];int vis[N &lt;&lt; 2 | 1];void down(int o, int L, int R){    if(~vis[o])    {        int mid = (L + R) &gt;&gt; 1;        num[o &lt;&lt; 1] = (vis[o] ? mid - L + 1 : 0);        num[o &lt;&lt; 1 | 1] = (vis[o] ? R - mid : 0);        vis[o &lt;&lt; 1] = vis[o &lt;&lt; 1 | 1] = vis[o];        vis[o] = -1;    }}void UpdateOrQuery(int o, int L, int R, int l, int r, bool val){    if(L &gt; r || R &lt; l)        return ;    if(l &lt;= L &amp;&amp; R &lt;= r)    {        if(val == 0)            vis[o] = change, num[o] = (change ? R - L + 1 : 0);        else            ans += num[o];        return ;    }    if(L == R)        return ;    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    UpdateOrQuery(o &lt;&lt; 1, L, mid, l, r, val);    UpdateOrQuery(o &lt;&lt; 1 | 1, mid + 1, R, l, r, val);    num[o] = num[o &lt;&lt; 1] + num[o &lt;&lt; 1 | 1];}int BSearch(int o, int L, int R, int idx){    if(L == R)        return L;    down(o, L, R);    int mid = (L + R) &gt;&gt; 1;    int tot = mid - L + 1 - num[o &lt;&lt; 1];    if(tot &gt;= idx)        return BSearch(o &lt;&lt; 1, L, mid, idx);    else        return BSearch(o &lt;&lt; 1 | 1, mid + 1, R, idx - tot);///idx - tot}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        memset(num,  0, sizeof(num));        memset(vis, -1, sizeof(vis));        int idx, x, y;        while(m--)        {            scanf(&quot;%d %d %d&quot;, &amp;idx, &amp;x, &amp;y);            if(idx == 1)            {                ++x;                ans = 0;                UpdateOrQuery(1, 1, n, x, n, 1);                int cnt = n - x + 1 - ans;///How many zeros in [x, n].                int tot = n - num[1] - cnt;///How many zeros in [1, x - 1].                if(cnt == 0)                    cout &lt;&lt; &quot;Can not put any one.\n&quot;;                else                {                    int first, last;                    first = BSearch(1, 1, n, tot + 1);                    if(y &gt; cnt)                        last = BSearch(1, 1, n, tot + cnt);                    else                        last = BSearch(1, 1, n, tot + y);                    cout &lt;&lt; first - 1 &lt;&lt; &#39; &#39; &lt;&lt; last - 1 &lt;&lt; &#39;\n&#39;;                    change = 1;                    UpdateOrQuery(1, 1, n, first, last, 0);                }            }            else            {                ++x, ++y;                ans = 0;                UpdateOrQuery(1, 1, n, x, y, 1);                cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;                change = 0;                UpdateOrQuery(1, 1, n, x, y, 0);            }        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="PE"><a href="#PE" class="headerlink" title="PE"></a>PE</h3><blockquote><p>　 <strong>Output one blank line after each test case.</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 优化の二分 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 3974 Assign the task(DFS + Segment Tree)</title>
      <link href="2020/03/17/HDU-3974-Assign-the-task-DFS-Segment-Tree/"/>
      <url>2020/03/17/HDU-3974-Assign-the-task-DFS-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点代表N个员工，形成一棵树，某点的父节点代表他的上司。公司分配任务时，若分配任务y给x，那么x的下属也会停止他们手头的任务来做任务y。</p><p>分配任务、查询某人在做哪个任务。</p></blockquote><a id="more"></a><h3 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h3><p><img src="https://i.postimg.cc/gJDTmLcT/H-N0-A-J-Y6-VS5-K3-1-B.png" alt="DFS order"></p><blockquote><p>①能将树的上各点的“父子关系”体现出来</p><p>②区间左端点是代表，<code>左端点.val</code>恰好能反应这个区间对应点的当前属性</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50010;int n, m, pre[N], tot, in[N], out[N];bool vis[N];char s[10];int cnt, head[N];struct edge{    int v, nxt;}e[N];struct interval{    int L, R, val;}a[N &lt;&lt; 2 | 1];void init(){    cnt = tot = 0;    memset(head, -1, sizeof(head));    memset(pre, -1, sizeof(pre));    memset(vis, 0, sizeof(vis));}void add(int u, int v){    e[cnt].v = v;    e[cnt].nxt = head[u];    head[u] = cnt++;}void DFS(int now){    in[now] = ++tot;    vis[now] = 1;    for(int i = head[now]; ~i; i = e[i].nxt)        if(!vis[ e[i].v ])            DFS(e[i].v);    out[now] = tot;}void build(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = -1;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    build(num &lt;&lt; 1, l, mid);    build(num &lt;&lt; 1 | 1, mid + 1, r);}void down(int num){    if(a[num].val != -1)    {        a[num &lt;&lt; 1].val = a[num].val;        a[num &lt;&lt; 1 | 1].val = a[num].val;        a[num].val = -1;    }}void update(int num, int l, int r, int t){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        a[num].val = t;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);    update(num &lt;&lt; 1, l, r, t);    update(num &lt;&lt; 1 | 1, l, r, t);}void query(int num, int p){    if(a[num].L &gt; p || a[num].R &lt; p)        return ;    if(a[num].L == p &amp;&amp; a[num].R == p)    {        cout &lt;&lt; a[num].val &lt;&lt; &#39;\n&#39;;        return ;    }    down(num);    query(num &lt;&lt; 1, p);    query(num &lt;&lt; 1 | 1, p);}int main(){    int _, t = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d&quot;, &amp;n);        init();        build(1, 1, n);        int b, c;        for(int i = 1; i &lt;= n - 1; ++i)        {            scanf(&quot;%d%d&quot;, &amp;b, &amp;c);            pre[b] = c;            add(c, b);        }        for(int i = 1; i &lt;= n; ++i)            if(pre[i] == -1)            {                DFS(i);                break;            }        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; t++ &lt;&lt; &quot;:\n&quot;;        int x, y;        scanf(&quot;%d&quot;, &amp;m);        while(m--)        {            scanf(&quot;%s&quot;, s);            if(s[0] == &#39;C&#39;)            {                scanf(&quot;%d&quot;, &amp;x);                query(1, in[x]);            }            else            {                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(1, in[x], out[x], y);            }        }    }    return 0;}</code></pre><h3 id="眼瞎Debug一个半小时"><a href="#眼瞎Debug一个半小时" class="headerlink" title="眼瞎Debug一个半小时"></a>眼瞎Debug一个半小时</h3><p><img src="https://i.postimg.cc/02cKDkr1/YIYWIFEYLD8-CEVSG84-H-CY.png" alt="Debug"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1540 Tunnel Warfare(Segment Tree)</title>
      <link href="2020/03/17/HDU-1540-Tunnel-Warfare-Segment-Tree/"/>
      <url>2020/03/17/HDU-1540-Tunnel-Warfare-Segment-Tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点(1 ~ N)，M个操作</p><p>D x 破坏点x</p><p>Q x 查询与x直接或间接相连的点（包括x自身）</p><p>R x 修复最近一次被破坏的点</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>可以用 线段树 || 树状数组 || set </p><p>线段树：</p><p><code>a[num].lmax</code>：包含区间左端点的最大连续子区间长度</p><p><code>a[num].rmax</code>：包含区间右端点的最大连续子区间长度</p><p><code>a[num].ans</code>：本区间最大连续子区间长度（仅用于剪枝：==0 return）</p><p>举例：</p><pre><code class="lang-c++">query(int num, int t)int mid = (a[num].L + a[num].R) &gt;&gt; 1;if(t &lt;= mid){    if(a[num &lt;&lt; 1].rmax &gt;= mid - t + 1)    {        ans += a[num &lt;&lt; 1].rmax + a[num &lt;&lt; 1 | 1].lmax;        return ;    }    else        query(num &lt;&lt; 1, t);}else</code></pre></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;char s[10];int n, m, des[N], last, ans;struct node{    int L, R, ans, lmax, rmax;}a[N &lt;&lt; 2 | 1];void up(int num){    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    a[num].lmax = a[num &lt;&lt; 1].lmax + (a[num &lt;&lt; 1].lmax == mid - a[num].L + 1 ? a[num &lt;&lt; 1 | 1].lmax : 0);    a[num].rmax = a[num &lt;&lt; 1 | 1].rmax + (a[num &lt;&lt; 1 | 1].rmax == a[num].R - mid ? a[num &lt;&lt; 1].rmax : 0);    a[num].ans = max(max(a[num &lt;&lt; 1].ans, a[num &lt;&lt; 1 | 1].ans), a[num &lt;&lt; 1].rmax + a[num &lt;&lt; 1 | 1].lmax);}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].ans = a[num].lmax = a[num].rmax = 1;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);    up(num);}void update(int num, int t, int val){    if(a[num].L &gt; t || a[num].R &lt; t)        return ;    if(a[num].L == a[num].R &amp;&amp; a[num].L == t)    {        a[num].ans = a[num].lmax = a[num].rmax = val;        return ;    }    update(num &lt;&lt; 1, t, val);    update(num &lt;&lt; 1 | 1, t, val);    up(num);}void query(int num, int t){    if(a[num].ans == 0 || a[num].L == a[num].R)    {        ans += a[num].ans;        return ;    }    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(t &lt;= mid)    {        if(a[num &lt;&lt; 1].rmax &gt;= mid - t + 1)        {            ans += a[num &lt;&lt; 1].rmax + a[num &lt;&lt; 1 | 1].lmax;            return ;        }        else            query(num &lt;&lt; 1, t);    }    else    {        if(a[num &lt;&lt; 1 | 1].lmax &gt;= t - mid)        {            ans += a[num &lt;&lt; 1].rmax + a[num &lt;&lt; 1 | 1].lmax;            return ;        }        else            query(num &lt;&lt; 1 | 1, t);    }}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        init(1, 1, n);        while(m--)        {            int t;            scanf(&quot;%s&quot;, s);            if(s[0] == &#39;D&#39;)            {                scanf(&quot;%d&quot;, &amp;t);                des[++last] = t;                update(1, t, 0);            }            else if(s[0] == &#39;R&#39;)                update(1, des[last--], 1);            else            {                scanf(&quot;%d&quot;, &amp;t);                ans = 0, query(1, t);                cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4027 Can you answer these queries(Segment tree)</title>
      <link href="2020/03/17/HDU-4027-Can-you-answer-these-queries-Segment-tree/"/>
      <url>2020/03/17/HDU-4027-Can-you-answer-these-queries-Segment-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个数字N，给出1到N这个N个数字的初值</p><p>M个操作：</p><ol><li>更新x、y之间所有数字为他们的算术平方根</li><li>查询x、y之间所有数字的和</li></ol></blockquote><a id="more"></a><h3 id="Something-about-Segment-Tree"><a href="#Something-about-Segment-Tree" class="headerlink" title="Something about Segment Tree"></a>Something about Segment Tree</h3><blockquote><p>线段树有initial、update、query三个函数</p><p>initial函数用到了<code>int mid = ( + ) &gt;&gt; 1;</code></p><p>而流氓写法的update、query函数没有用到mid</p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>觉得这种题目的更新没办法lazy，区间更新只能换成暴力单点更新。</p><p>此题的剪枝在于“算术平方根”，所给范围内的数字求8次以内次数的算术平方根就会变成1，现在拿一组变量纪录每个区间的最大值，若区间最大值是1，那么就没必要向下更新了。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int N = 100005;ll n, k, ans, val[N];struct node{    ll L, R, sum, mmax;}a[N &lt;&lt; 2 | 1];void init(ll num, ll l, ll r){    a[num].L = l;    a[num].R = r;    a[num].sum = 0;    a[num].mmax = 0;    if(l == r)    {        a[num].sum = a[num].mmax = val[r];        return ;    }    ll mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);    a[num].sum = a[num &lt;&lt; 1].sum + a[num &lt;&lt; 1 | 1].sum;    a[num].mmax = max(a[num &lt;&lt; 1].mmax, a[num &lt;&lt; 1 | 1].mmax);}void update(ll num, ll l, ll r){    if(a[num].L &gt; r || a[num].R &lt; l || a[num].mmax &lt;= 1)///pruning        return ;    if(a[num].L == a[num].R)///Brute single node change!    {        a[num].sum = sqrt(a[num].sum);        a[num].mmax = a[num].sum;        return ;    }    update(num &lt;&lt; 1, l, r);    update(num &lt;&lt; 1 | 1, l, r);    a[num].sum = a[num &lt;&lt; 1].sum + a[num &lt;&lt; 1 | 1].sum;    a[num].mmax = max(a[num &lt;&lt; 1].mmax, a[num &lt;&lt; 1 | 1].mmax);}void query(ll num, ll l, ll r){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        ans += a[num].sum;        return ;    }    if(a[num].L == a[num].R)        return ;    query(num &lt;&lt; 1, l, r);    query(num &lt;&lt; 1 | 1, l, r);}int main(){    ll cnt = 1, order, x, y;    while(~scanf(&quot;%lld&quot;, &amp;n))    {        for(ll i = 1; i &lt;= n; ++i)            scanf(&quot;%lld&quot;, &amp;val[i]);        init(1, 1, n);        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; cnt++ &lt;&lt; &quot;:\n&quot;;        scanf(&quot;%lld&quot;, &amp;k);        while(k--)        {            scanf(&quot;%lld %lld %lld&quot;, &amp;order, &amp;x, &amp;y);            if(x &gt; y)                swap(x, y);            if(order == 1)            {                ans = 0, query(1, x, y);                cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            }            else                update(1, x, y);        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 1610 Count the colors(Segment tree)</title>
      <link href="2020/03/16/ZOJ-1610-Count-the-colors-Segment-tree/"/>
      <url>2020/03/16/ZOJ-1610-Count-the-colors-Segment-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给区间涂色（可遮挡），问最终可看到哪几种颜色，以及这几种颜色分别有几段？</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>跟POJ有一道“贴海报”的题类似，只不过那题只求最终可以看到几种海报，这题还要统计段数。<strong>暴力单点查询</strong>，用一个last变量记录上一个点的颜色，若与现在这个点颜色不相同，那当前颜色段数++。更新last。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 8005;int n, cnt[N], last = -1;struct interval{    int L, R, val;} a[N &lt;&lt; 2 | 1];void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = -1;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void down(int x){    if(a[x].val != -1)    {        a[x &lt;&lt; 1].val = a[x].val;        a[x &lt;&lt; 1 | 1].val = a[x].val;        a[x].val = -1;    }}void update(int num, int l, int r, int t){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        a[num].val = t;        return ;    }    if(a[num].L == a[num].R)///in case of endless recursion        return ;    down(num);    update(num &lt;&lt; 1, l, r, t);    update(num &lt;&lt; 1 | 1, l, r, t);}void query(int num, int l, int r){    if(a[num].L == a[num].R)///in case of endless recursion    {        if(a[num].val != -1 &amp;&amp; a[num].val != last)            cnt[ a[num].val ]++;        last = a[num].val;///Even it&#39;s empty(without any color).        return ;    }    down(num);    query(num &lt;&lt; 1, l, r);    query(num &lt;&lt; 1 | 1, l, r);}int main(){    int L, R, idx;    while(~scanf(&quot;%d&quot;, &amp;n))    {        last = -1;        init(1, 1, 8000);        memset(cnt, 0, sizeof(cnt));        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;L, &amp;R, &amp;idx);            update(1, L + 1, R, idx);        }        query(1, 1, 8000);        for(int i = 0; i &lt;= 8000; ++i)            if(cnt[i] &gt; 0)                cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; cnt[i] &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3026 Brog Maze(BFS+Prim)</title>
      <link href="2020/03/16/POJ-3026-Brog-Maze-BFS-Prim/"/>
      <url>2020/03/16/POJ-3026-Brog-Maze-BFS-Prim/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>将S和A所在点连成最小生成树</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>用BFS求出(S、A)各点之间的最小距离，建立图的边</p><p>求最小生成树</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 55;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;int n, m, node[N][N], num, dis[N][N], e[N * N][N * N], low[N * N];char str[N], mp[N][N];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};bool vis[N][N], used[N * N];void BFS(int x, int y){    memset(vis, 0, sizeof(vis));    memset(dis, 0, sizeof(dis));    queue&lt;P&gt; q;    q.push(P(x, y));    vis[x][y] = 1;    while(!q.empty())    {        P now = q.front();        q.pop();        int nowx = now.first;        int nowy = now.second;        if(node[nowx][nowy])            e[ node[x][y] ][ node[nowx][nowy] ] = dis[nowx][nowy];        for(int i = 0; i &lt; 4; ++i)        {            int xx = nowx + dx[i];            int yy = nowy + dy[i];            if(xx &gt;= 0 &amp;&amp; xx &lt; m &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n)                if(!vis[xx][yy] &amp;&amp; mp[xx][yy] != &#39;#&#39;)                {                    q.push(P(xx, yy));                    vis[xx][yy] = 1;                    dis[xx][yy] = dis[nowx][nowy] + 1;                }        }    }}void Prim(){    int ans = 0, mmin = INF, pos = 1;    memset(used, 0, sizeof(used));    ans += 0, used[pos] = 1;    for(int i = 1; i &lt;= num; ++i)        low[i] = e[pos][i];    int cnt = num;    while(--cnt)    {        mmin = INF;        for(int i = 1; i &lt;= num; ++i)            if(!used[i] &amp;&amp; low[i] &lt; mmin)                mmin = low[i], pos = i;        ///if(mmin == INF)        ans += mmin, used[pos] = 1;        for(int i = 1; i &lt;= num; ++i)            if(!used[i] &amp;&amp; low[i] &gt; e[pos][i])                low[i] = e[pos][i];    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        num = 0;        memset(e, 0, sizeof(e));        memset(node, 0, sizeof(node));        gets(str);        for(int i = 0; i &lt; m; ++i)            gets(mp[i]);        for(int i = 0; i &lt; m; ++i)            for(int j = 0; j &lt; n; ++j)                if(mp[i][j] == &#39;A&#39; || mp[i][j] == &#39;S&#39;)                    node[i][j] = ++num;        for(int i = 0; i &lt; m; ++i)            for(int j = 0; j &lt; n; ++j)                if(node[i][j])                    BFS(i, j);        Prim();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 最小生成树のPrim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1679 The Unique MST(Prim)</title>
      <link href="2020/03/15/POJ-1679-The-Unique-MST-Prim/"/>
      <url>2020/03/15/POJ-1679-The-Unique-MST-Prim/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>求最小生成树是否唯一</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>可以求非严格次小生成树，看是否与最小生成树相同</p><p>用Prim做法，检测某个点到“已连接集合”的最小距离是否唯一</p></blockquote><p><img src="https://i.postimg.cc/wjn3jJWy/prim-2.png" alt="Prim"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;const int INF = 0x3f3f3f3f;int n, m, ans, mp[N][N], vis[N], low[N], cnt[N];void Prim(){    ans = 0;    int pos = 1, mmin = INF;    memset(cnt,   0, sizeof(cnt));    memset(vis,   0, sizeof(vis));    memset(low, INF, sizeof(low));    vis[1] = 1;    for(int i = 1; i &lt;= n; ++i)        low[i] = mp[pos][i], cnt[i] = 1;    int tot = n;    while(--tot)    {        mmin = INF;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; low[i] &lt; mmin)                mmin = low[i], pos = i;        ///if(mmin == INF)        vis[pos] = 1;        ans += mmin;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i])            {                if(low[i] == mp[pos][i])                    cnt[i]++;                else if(low[i] &gt; mp[pos][i])                    low[i] = mp[pos][i], cnt[i] = 1;            }    }}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                mp[i][j] = (i == j ? 0 : INF);        int u, v, w;        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);            mp[u][v] = mp[v][u] = w;        }        Prim();        bool flag = 0;        for(int i = 1; i &lt;= n; ++i)            if(cnt[i] &gt; 1)            {                flag = 1;                break;            }        if(flag)            cout &lt;&lt; &quot;Not Unique!&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树のPrim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 3261 Connections in Galaxy War(union-find-set)</title>
      <link href="2020/03/13/ZOJ-3261-Connections-in-Galaxy-War-union-find-set/"/>
      <url>2020/03/13/ZOJ-3261-Connections-in-Galaxy-War-union-find-set/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>假设有编号从0开始的n个点，每个点都有一个非负权值p[i]。现在有没有重边的m条边和Q个操作。<br>对于操作有两种类型 :<br>destroy a b 表示摧毁a,b点之间的边<br>query a 表示从a出发能到的点中,权值比a大权值最大,在权值最大前提下编号最小的点。如果没有这样的点输出-1。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>我所解决不了的问题是删边，并查集没学过删边操作，要是每次都重建一次并查集太耗时间了，怎么办呢？</p><p><strong>逆序解决问题</strong>：</p><p>从后向前解决问题，最初的并查集排除了所有删掉的边，正好对应最后的查询。然后向前遍历，若遇到删边操作，说明前面的查询都是建立在“包含这条边”的基础上的，那么我们添边，如此一来，<strong>化“删边”为“添边”</strong>，解决了问题。</p><p>总结：正序解决问题不行，试试逆序。老子说过：世间万物都包含对立两方，对立的双方可以相互转化。</p><p>另外用一个mmax[i]数组记录以i点所在集合(连通块)内最大val值，方法是把mmax数组作为每个集合<strong>祖先节点的一个属性，毕竟祖先节点代表着整个集合</strong>。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;int n, m, k, cnt;int pre[N], val[N], u[N], v[N], mmax[N], idx[N], ans[N];map&lt; int, map&lt;int, bool&gt; &gt;mp;struct node{    char s[10];    int x, y;}q[N];int found(int x){    if(pre[x] == -1)        return x;    return pre[x] = found(pre[x]);}void unite(int a, int b){    int aa = found(a);    int bb = found(b);    if(aa != bb)    {        pre[aa] = bb;        if(mmax[bb] &lt; mmax[aa])        {            mmax[bb] = mmax[aa];            idx[bb] = idx[aa];        }        else if(mmax[bb] == mmax[aa])            idx[bb] = min(idx[bb], idx[aa]);    }}int main(){    bool flag = 0;    while(~scanf(&quot;%d&quot;, &amp;n))    {        cnt = 0;        mp.clear();        memset(pre, -1, sizeof(pre));        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;val[i]);            mmax[i] = val[i];            idx[i] = i;        }        scanf(&quot;%d&quot;, &amp;m);        for(int i = 1; i &lt;= m; ++i)            scanf(&quot;%d %d&quot;, &amp;u[i], &amp;v[i]);        scanf(&quot;%d&quot;, &amp;k);        for(int i = 1; i &lt;= k; ++i)        {            scanf(&quot;%s&quot;, q[i].s);            if(q[i].s[0] == &#39;q&#39;)                scanf(&quot;%d&quot;, &amp;q[i].x);            else            {                scanf(&quot;%d %d&quot;, &amp;q[i].x, &amp;q[i].y);                mp[ q[i].x ][ q[i].y ] = 1;                mp[ q[i].y ][ q[i].x ] = 1;            }        }        for(int i = 1; i &lt;= m; ++i)            if(mp[ u[i] ][ v[i] ] == 0)                unite(u[i], v[i]);        for(int i = k; i &gt;= 1; --i)        {            if(q[i].s[0] == &#39;d&#39;)                unite(q[i].x, q[i].y);            else            {                int xx = found(q[i].x);                if(mmax[xx] &gt; val[ q[i].x ])                    ans[cnt++] = idx[xx];                else                    ans[cnt++] = -1;            }        }        if(flag)            cout &lt;&lt; &#39;\n&#39;;        flag = 1;        for(int i = cnt - 1; i &gt;= 0; --i)            cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2912 Rochambeau(union-find-set)</title>
      <link href="2020/03/12/POJ-2912-Rochambeau-union-find-set/"/>
      <url>2020/03/12/POJ-2912-Rochambeau-union-find-set/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个小伙伴进行猜拳游戏，除了裁判以外，其他人只会出单一的一种，给出m中猜拳的结果，要求找出裁判序号，并且输出在第几次猜拳可以确定。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>种类并查集、排除法做题</p><p>除了裁判的小伙伴分为3组：0、1、2</p><p>从1到n枚举，假设当前 i 是裁判，若合并除裁判外的其他人而无矛盾的话，i 是准裁判。记一下裁判的个数。</p><p>另外要确定最少几行可以得出”谁是裁判”结论，我们记录每次排除一个人时记下是哪一行出现了矛盾，得到n - 1个位置。因为排除了所有的非裁判才知道裁判是谁，所以那n - 1个位置中到最靠后一个位置才能排除n - 1个非裁判，才能得知谁是裁判。</p></blockquote><h3 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h3><blockquote><p>先来一个小总结：</p><p>种类并查集分两种：①种类2种②种类3种</p><p>(若是多于3种便不能由AB、AC的关系推出BC的关系)</p><p>“2种”还好写，”3种”的有固定的一套体系</p><p>而关于这套体系我还有些东西没弄清楚：</p><ol><li><p>unite先if搞两者属于同一集合的情况（否则会WA）</p></li><li><p>必须有else，把那里面的内容单独放外面会RE</p></li><li><p>0= 、 1&gt; 、2&lt;  或者 0= 、1&lt; 、2&gt; 都是可行的</p></li><li><p>关于<code>(val[a] - val[b] + 3) % 3 != idx</code>我觉得不能解释以下两种情况</p></li></ol><p>①<code>A &gt; pre &amp;&amp; B &lt; pre -&gt; A &gt; B</code></p><p>②<code>A &lt; pre &amp;&amp; B &gt; pre -&gt; A &lt; B</code></p><p>现在明白了， <code>A &gt; pre &amp;&amp; pre &gt; B</code> -&gt; <code>B &gt; A</code>!</p><p>这个大于号在这里很误导人，石头剪刀布是相互制约的！</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 510;char ch[N * 4];int n, m, a[N * 4], b[N * 4], pre[N], val[N];int found(int x){    if(pre[x] == -1)        return x;    int tem = found(pre[x]);    val[x] += val[ pre[x] ];    val[x] %= 3;    return pre[x] = tem;}bool unite(int a, int b, int idx){    int aa = found(a);    int bb = found(b);    if(aa == bb)/// == first, then != .    {        if((val[a] - val[b] + 3) % 3 != idx)            return 1;    }    else    {///without {} will be RE ! ? ? !        pre[aa] = bb;        val[aa] = (-val[a] + idx + val[b] + 3) % 3;    }    return 0;}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        for(int i = 1; i &lt;= m; ++i)            scanf(&quot;%d%c%d&quot;, &amp;a[i], &amp;ch[i], &amp;b[i]);        bool flag = 1;        int idx, num = 0, cnt = 0, which = 0;        for(int i = 0; i &lt; n; ++i)///n times union-find-set        {            flag = 1;            memset(val,  0, sizeof(val));            memset(pre, -1, sizeof(pre));            for(int j = 1; j &lt;= m; ++j)            {                if(a[j] == i || b[j] == i)                    continue;                if(ch[j] == &#39;=&#39;)                    idx = 0;                else if(ch[j] == &#39;&lt;&#39;)/// &gt; is also OK ! ? ? !                    idx = 1;                else                    idx = 2;                if(unite(a[j], b[j], idx))                {                    flag = 0;                    num = max(num, j);                    break;                }            }            if(flag)                cnt++, which = i;        }        if(cnt == 0)            cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; &#39;\n&#39;;        else if(cnt &gt; 1)            cout &lt;&lt; &quot;Can not determine&quot; &lt;&lt; &#39;\n&#39;;        else            printf(&quot;Player %d can be determined to be the judge after %d lines\n&quot;, which, num);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2492 A Bug&#39;s Life(easy union-find-set)</title>
      <link href="2020/03/12/POJ-2492-A-Bug-s-Life-easy-union-find-set/"/>
      <url>2020/03/12/POJ-2492-A-Bug-s-Life-easy-union-find-set/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>这题跟POJ 1703一样，没什么好说的。写题解是提醒自己unite函数里，连接前if判断的重要性，我今天尝试将unite在主函数里实现，忘记了if判断(两者在同一集合里还乱连接)直接连接导致RE</p></blockquote><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool flag;int n, m, a, aa, b, bb, pre[10005];int found(int x){    if(pre[x] == -1)        return x;    return pre[x] = found(pre[x]);}int main(){    int _, cnt = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        flag = 0;        memset(pre, -1, sizeof(pre));        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        while(m--)        {            scanf(&quot;%d %d&quot;, &amp;a, &amp;b);            if(flag)                continue;            aa = found(a);            bb = found(b);            if(aa != bb)            {                int bbnn = found(b + n), aann = found(a + n);                if(aa != bbnn &amp;&amp; bb != aann)                    pre[aa] = found(b + n), pre[bb] = found(a + n);            }            else                flag = 1;        }        cout &lt;&lt; &quot;Scenario #&quot; &lt;&lt; cnt++ &lt;&lt; &quot;:\n&quot;;        if(flag)            cout &lt;&lt; &quot;Suspicious bugs found!&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;No suspicious bugs found!&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1984 Navigation Nightmare(valset)</title>
      <link href="2020/03/11/POJ-1984-Navigation-Nightmare-valset/"/>
      <url>2020/03/11/POJ-1984-Navigation-Nightmare-valset/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有<strong>n</strong>个网格状的农田，每个农田之间有距离，会依次给出关系，在给出关系后询问两个农田之间的曼哈顿距离是多少？</p></blockquote><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>在两种情况下我会去看别人写的题解：<br>1.百wa不得其解<br>2.代码实现卡在某个点上<br>解决了这道题目后，自己写题解时要注意写明什么原因看了别人的题解<br>对于1，写清楚到底wa在哪个点上<br>对于2，写清楚别人怎么过的那个点</p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>对于此题，我对于”方向“无从下手，固然要记录当前结点到祖先节点的方向，开一个char数组标记吗？可路径压缩时又该如何更新彼此的数据？</p><p>解决办法：<strong>数字化</strong></p><p>想想倘若是一维的，可以通过权值的正负区分左右，二维亦是如此。</p><p>以N、E为正，S、W为负</p><p>把祖先节点放在圆点上，更新每个点相对于祖先节点的NSEW。</p><p>那么同一祖先节点的节点间的哈密顿距离也就易求了。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40005;int n, m, k;char dir[10];int u[N], v[N], w, ns[N], ew[N], val_ns[N], val_ew[N], pre[N];int found(int x){    if(pre[x] == -1)        return x;    int tem = found(pre[x]);    ns[x] += ns[ pre[x] ];    ew[x] += ew[ pre[x] ];    return pre[x] = tem;}void unite(int a, int b, int v_ns, int v_ew){    int aa = found(a);    int bb = found(b);    if(aa != bb)    {        pre[aa] = bb;        ns[aa] = -ns[a] + v_ns + ns[b];        ew[aa] = -ew[a] + v_ew + ew[b];    }}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        memset(pre, -1, sizeof(pre));        memset(ns ,  0,  sizeof(ns));        memset(ew ,  0,  sizeof(ew));        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d%d%d%s&quot;, &amp;u[i], &amp;v[i], &amp;w, dir);            if(dir[0] == &#39;N&#39;)                val_ns[i] = w;            else if(dir[0] == &#39;S&#39;)                val_ns[i] = -w;            else if(dir[0] == &#39;E&#39;)                val_ew[i] = w;            else                val_ew[i] = -w;        }        scanf(&quot;%d&quot;, &amp;k);        int cnt = 0;        for(int i = 0; i &lt; k; ++i)        {            int a, b, idx;            scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;idx);            while(cnt &lt; idx)            {                cnt++;                unite(u[cnt], v[cnt], val_ns[cnt], val_ew[cnt]);            }            if(found(a) != found(b))                cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; abs(ns[a] - ns[b]) + abs(ew[a] - ew[b]) &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1733 Parity game(valset)</title>
      <link href="2020/03/11/POJ-1733-Parity-game-valset/"/>
      <url>2020/03/11/POJ-1733-Parity-game-valset/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N、M分别表示某个01串的长度、查询数量</p><p>接下来M行，L R S 表示[L, R]有奇数个1还是偶数个1</p><p>问哪一行出错了(与前面所述有矛盾)，输出这行的前一行标号</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>带权并查集，跟HDU 3038 How many answers are wrong相似，但刚开始我不会做，在这里反思：</p><p>做题一定要有自己的充足的思考，先自己试着去解题，不行再看题解。</p><p>记住哪个点不行，自己尝试多种方法解决这个点。</p><p>看题解时思考题解是怎么实现自己所实现不了的功能，要学会这种思想。</p><p>现在我看以前的题解，发现要是在让我做那道题，我还是不会，真是讽刺。</p><p>我只知道那样做可行，而若抛却那种做法却不知如何去做。</p><p>就像只知道必要条件而不知道充分条件，只学到皮毛，没学到思想。只得到一条鱼而没学会怎么捕鱼。</p></blockquote><h3 id="升华"><a href="#升华" class="headerlink" title="升华"></a>升华</h3><blockquote><p>问：为什么计算机相关的数据结构在描述区间的时候都是<strong>[左闭，右开)</strong>？</p><p>一个未学过计算机的人相较而言会更喜欢[左闭， 右闭]这种描述</p><p>下面我们来探索一下</p><p>先给定区间[1, 9]，我们用某种方式将1~9连接</p><p>在分别给定区间[1, 3]， [4, 6]， [7, 9]，我们用同样的连接它们</p><p>但我们发现前后两者所表现的不一样：后者三个区间彼此没有组合在一起</p><p>但是两者其实所包含的区间完全一样</p><p>问题就在于：这种连接方式不够好</p><p>换成[左闭右开)或者(左开右闭]的方式连接就好了！</p><p>一般常用左开右闭，像“前缀和”就有这样的意思</p><p>但介于计算机从0开始，0的左为“-1”，不适合做下标，左闭右开更好些</p></blockquote><p><img src="https://i.postimg.cc/HkC70FPj/S2-VQUWXHZLWJKCZLHEOP5-JG.png" alt=""></p><blockquote><p>以上都是我的思考以及猜测</p><p>另外这题数大，但数据量不大，正常思路应该用离散化解决一下，但我想用map偷懒，而且我第一反应觉得这题不用离散化(但实际上看来可以)，实测map可用。</p><p>map\<int, int=""> mp：无限大的数组(甚至下标可以为负值)</int,></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool flag;char s[10];int n, m, ans, L, R;map&lt;int, int&gt; pre;map&lt;int, int&gt; val;int found(int x){    if(pre[x] == 0)        return x;    int tem = found(pre[x]);    val[x] += val[ pre[x] ];    val[x] %= 2;    return pre[x] = tem;}void unite(int L, int R, int num, int idx){    int LL = found(L);    int RR = found(R);    if(LL != RR)    {        pre[LL] = RR;        val[LL] = (-val[L] + val[R] + num + 2) % 2;    }    else    {        if((val[L] - val[R] + 2) % 2 != num)            flag = 1, ans = idx - 1;    }}int main(){    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m))    {        pre.clear();        val.clear();        flag = 0, ans = m;        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d %d %s&quot;, &amp;L, &amp;R, s);            if(flag)                continue;            if(s[0] == &#39;e&#39;)                unite(L, R + 1, 0, i);            else                unite(L, R + 1, 1, i);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1417 True Liars(union-find sets)</title>
      <link href="2020/03/10/POJ-1417-True-Liars-union-find-sets/"/>
      <url>2020/03/10/POJ-1417-True-Liars-union-find-sets/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个回答，P1个好人(只说实话)， P2个坏人(只说谎话)</p><p>X(回答者) Y(被提及的人) A(yes表示X说Y是好人，no表示X说Y是坏人)</p><p>问凭现有条件能否确定P1个好人分别是谁</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>分析得知，yes表示X与Y同类，no表示X与Y异类</p><p>可用种类并查集。背包的事，以后有缘再见。</p></blockquote><h3 id="Something-about-种类并查集"><a href="#Something-about-种类并查集" class="headerlink" title="Something about 种类并查集"></a>Something about 种类并查集</h3><blockquote><ol><li>A kind of 带权并查集</li><li>把所有种类都并到一个集合里，根据每个点与根节点的关系来判断种类，而非将不同种类并到不同的集合里</li></ol></blockquote><h3 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h3><blockquote><p>权值的更新类似向量的表示</p></blockquote><p><img src="https://i.postimg.cc/5y43cSyj/GN-8-N4-RETUN2-R-ERS4-MU.png" alt="valset"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 610;int n, p, q;int fa[N], val[N];bool used[N];int a[N][2];vector&lt;int&gt;b[N][2];int dp[N][N / 2];int pre[N][N / 2];void init(){    for(int i = 0; i &lt;= p + q; ++i)        fa[i] = i;    memset(val, 0, sizeof(val));}int found(int x){    if(x == fa[x])        return x;    int tem = found(fa[x]);    val[x] += val[ fa[x] ];    val[x] %= 2;    return fa[x] = tem;}//int found(int x)//{//    if(x == fa[x])//        return x;////    int tem = fa[x];//    fa[x] = found(fa[x]);//    val[x] += val[tem];//    val[x] %= 2;//    return fa[x];//}void unite(int u, int v, int tem){    int uu = found(u);    int vv = found(v);    if(uu != vv)    {        fa[uu] = vv;        val[uu] = (-val[u] + val[v] + tem + 2) % 2;    }}int main(){    while(~scanf(&quot;%d %d %d&quot;, &amp;n, &amp;p, &amp;q))    {        if(n == 0 &amp;&amp; p == 0 &amp;&amp; q == 0)            break;        init();        int u, v, tem;        char s[10];        while(n--)        {            scanf(&quot;%d %d %s&quot;, &amp;u, &amp;v, s);            if(s[0] == &#39;y&#39;)                tem = 0;            else                tem = 1;            unite(u, v, tem);        }        for(int i = 0; i &lt; N; ++i)        {            b[i][0].clear();            b[i][1].clear();            a[i][0]=0;            a[i][1]=0;        }        memset(used, 0,sizeof(used));        int cnt = 1;        for(int i = 1; i &lt;= p + q; ++i)            if(!used[i])            {                int tmp = found(i);                for(int j = i; j &lt;= p + q; ++j)                    if(found(j)==tmp)                    {                        used[j] = 1;                        b[cnt][ val[j] ].push_back(j);                        a[cnt][ val[j] ]++;                    }                cnt++;            }        memset(dp, 0, sizeof(dp));        dp[0][0] = 1;        for(int i = 1; i &lt; cnt; ++i)        {            for(int j = p; j &gt;= 0; --j)            {                if(j - a[i][0] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i][0]])                {                    dp[i][j] += dp[i - 1][j - a[i][0]];                    pre[i][j] = j - a[i][0];                }                if(j - a[i][1] &gt;= 0 &amp;&amp; dp[i - 1][j - a[i][1]])                {                    dp[i][j] += dp[i - 1][j - a[i][1]];                    pre[i][j] = j - a[i][1];                }            }        }        if(dp[cnt - 1][p]!=1)            printf(&quot;no\n&quot;);        else        {            vector&lt;int&gt;ans;            ans.clear();            int t = p;            for(int i = cnt - 1; i &gt;= 1; --i)            {                int tmp = t - pre[i][t];                if(tmp == a[i][0])                    for(int j = 0; j &lt; a[i][0]; ++j)                        ans.push_back(b[i][0][j]);                else                    for(int j = 0; j &lt; a[i][1]; ++j)                        ans.push_back(b[i][1][j]);                t = pre[i][t];            }            sort(ans.begin(), ans.end());            for(int i = 0; i &lt; ans.size(); i++)                printf(&quot;%d\n&quot;,ans[i]);            printf(&quot;end\n&quot;);        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
            <tag> DPの背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codefroces C.Adding Powers</title>
      <link href="2020/03/10/Codefroces-C-Adding-Powers/"/>
      <url>2020/03/10/Codefroces-C-Adding-Powers/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出n个数和数字k，问这n个数是不是每个都：</p><p>等于k的某些幂次之和</p><p>这些幂次彼此各不相同</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>将每个数字拆解成k的幂次之和的形式</p></blockquote><pre><code class="lang-c++">        long long a, cnt[60];        memset(cnt, 0, sizeof(cnt));        for(int i = 0; i &lt; n; ++i)        {            cin &gt;&gt; a;            int idx = 0;            while(a &gt; 0)            {                cnt[idx++] += a % k;                a /= k;            }        }</code></pre><blockquote><p>就是上面这段代码，智慧结晶啊！</p><p>运用了逐次降幂的思想（让我想起了Java老师讲进制转换）</p><p>举例：k的x次幂，拿他 /= k，可以完成 x 次，之后成为 1，运用上面的代码得到<code>cnt[x] == 1</code>。同理，若是k的x次幂与k的y次幂之和，这个数字跑完代码后得到<code>cnt[x] == 1 &amp;&amp; cnt[y] == 1 &amp;&amp; cnt[others] == 0</code>。</p><p>算法很清楚地显示了这个数字在 k的幂次 这一角度的组成。</p><p>对于这一题，针对所有数字，使用同一个cnt数组，若是所有的1都落在不同位上，则YES，若是落在同一位上则NO！</p><p>这想法真好。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int t;    cin &gt;&gt; t;    while (t--)    {        int n, k;        cin &gt;&gt; n &gt;&gt; k;        long long a, cnt[60];        memset(cnt, 0, sizeof(cnt));        for(int i = 0; i &lt; n; ++i)        {            cin &gt;&gt; a;            int idx = 0;            while(a &gt; 0)            {                cnt[idx++] += a % k;                a /= k;            }        }        bool ok = true;        for (int i = 0; i &lt; 60; ++i)            if (cnt[i] &gt; 1)                ok = false;        cout &lt;&lt; (ok ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; &quot;\n&quot;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4370 0 or 1(The shortest path)</title>
      <link href="2020/03/09/HDU-4370-0-or-1-The-shortest-path/"/>
      <url>2020/03/09/HDU-4370-0-or-1-The-shortest-path/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个方形矩阵，求构造一个同样大小的（只含0、1）方形矩阵，在满足三个条件的前提下，两矩阵相同位置上的数字乘积总和最小。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>这题的建模思想绝了！谁能想到乍一看这么像数论的题目其实是个图论题！</p><p>将方形矩阵视为n个点的图，位置(i, j)上权值代表从 i 到 j 的距离</p><p>第一个条件规定点1有且仅有一个出度</p><p>第二个条件规定点n有且仅有一个入度</p><p>第三个条件规定其他点 入度 == 出度</p><p>有符合以上条件的两种模型</p><p>第一种模型：根据所求可转化为求最短路（首先能成一棵树，来满足‘度’的限制，然后代价最小。因为有方向所以是最短路，否则我想最小生成树可能也可…）</p><p>第二种模型是1、n两个非自环之最小环之和</p><p>在 分别以他们为起点，求最短路的过程中 可以求出</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, path, circle, t_circle;int e[305][305], dis[305], vis[305];void Dijkstra(int start){    memset(vis, 0, sizeof(vis));    memset(dis, INF, sizeof(dis));    dis[start] = 0;    int mmin = INF, pos = -1;    for(int i = 1; i &lt;= n; ++i)    {        mmin = INF, pos = -1;        for(int j = 1; j &lt;= n; ++j)            if(!vis[j] &amp;&amp; dis[j] &lt; mmin)                mmin = dis[j], pos = j;        vis[pos] = 1;        for(int j = 1; j &lt;= n; ++j)        {            dis[j] = min(dis[j], dis[pos] + e[pos][j]);            if(j == start &amp;&amp; pos != start)                circle = min(circle, dis[pos] + e[pos][j]);        }    }}int main(){    while(~scanf(&quot;%d&quot;, &amp;n))    {        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                scanf(&quot;%d&quot;, &amp;e[i][j]);        circle = INF;        Dijkstra(1);        path = dis[n];        t_circle = circle;        circle = INF;        Dijkstra(n);        cout &lt;&lt; min(path, t_circle + circle) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 3416 Marriage IV(the shortest path and maxflow)</title>
      <link href="2020/03/09/HDU-3416-Marriage-IV-shorted-path-and-maxflow/"/>
      <url>2020/03/09/HDU-3416-Marriage-IV-shorted-path-and-maxflow/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>求最短路有几种方案</p><p>（不同的两种方案所经过的边完全不同！）</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>以 A 为起点跑一遍spfa， 得到 dis_a[]</p><p>以 B 为起点跑一遍spfa， 得到 dis_b[]</p><p>对于边(u, v, w)，若满足<code>dis_a[u] + dis_b[v] + w == dis_a[B]</code></p><p>则这条边是最短路的可选边(可以作为最短路上的一条边)</p><p>找出所有的可选边，设其容量为1，A到B的最大流即完全不同的最短路方案数</p><p>结论：<strong>图论相关的题目，求有几种方案：将确定边设容量为1，求最大流即可</strong></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define Begin cout &lt;&lt; &quot;Check Begin---------------\n&quot;;#define END cout &lt;&lt; &quot;Check End-----------------\n&quot;;#define Exit cout &lt;&lt; &quot;Exit---------------------\n&quot;;const int INF = 0x3f3f3f3f;const int N = int(1e3) + 5;const int M = int(1e5) + 5;int n, m, start, over;int cnt_a, cnt_b, cnt_c;struct edge{    int to, w, pre;} a[M], b[M], c[2 * M];int dis_a[N], dis_b[N];bool vis_a[N], vis_b[N];int head_a[N], head_b[N], head_c[N];void init(){    cnt_a = 0, cnt_b = 0, cnt_c = 0;    for(int i = 0; i &lt;= n; ++i)    {        dis_a[i] = dis_b[i] = INF;        vis_a[i] = vis_b[i] = 0;        head_a[i] = head_b[i] = head_c[i] = -1;    }}void add(int &amp; cnt, edge * e, int * head, int from, int to, int w){    e[cnt].to = to;    e[cnt].w = w;    e[cnt].pre = head[from];    head[from] = cnt++;}void spfa(int s, int * head, edge * e, int * dis, bool * vis){    queue&lt;int&gt; q;    q.push(s);    dis[s] = 0;    vis[s] = 1;    while(!q.empty())    {        int now = q.front();        q.pop();        vis[now] = 0;        for(int i = head[now]; ~i; i = e[i].pre)        {            int to = e[i].to;            if(dis[to] &gt; dis[now] + e[i].w)            {                dis[to] = dis[now] + e[i].w;                if(!vis[to])                    q.push(to), vis[to] = 1;            }        }    }}int maxflow, deep[N], cur[N];bool BFS(int s, int t){    memset(deep, INF, sizeof(deep));    for(int i = 0; i &lt;= n; ++i)        cur[i] = head_c[i];    deep[s] = 0;    queue&lt;int&gt; q;    q.push(s);    while(!q.empty())    {        int now = q.front();        q.pop();        for(int i = head_c[now]; ~i; i = c[i].pre)            if(deep[ c[i].to ] == INF &amp;&amp; c[i].w)            {                deep[ c[i].to ] = deep[now] + 1;                q.push(c[i].to);            }    }    if(deep[t] &lt; INF)        return 1;    return 0;}int DFS(int now, int t, int limit){    if(!limit || now == t)        return limit;    int flow = 0, f;    for(int i = cur[now]; ~i; i = c[i].pre)    {        cur[now] = i;///Try To Realize this sentence!!!        if(deep[ c[i].to ] == deep[now] + 1)            if(f = DFS(c[i].to, t, min(limit, c[i].w)))            {                flow += f;                limit -= f;                c[i].w -= f;                c[i ^ 1].w += f;                if(!limit)                    break;            }    }    return flow;}void Dinic(int s, int t){    int tem;    while(BFS(s, t))        while(tem = DFS(s, t, INF))            maxflow += tem;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        init();        int u[M], v[M], w[M];        for(int i = 1; i &lt;= m ; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;u[i], &amp;v[i], &amp;w[i]);            if(u[i] == v[i])                continue;            add(cnt_a, a, head_a, u[i], v[i], w[i]);            add(cnt_b, b, head_b, v[i], u[i], w[i]);        }        scanf(&quot;%d %d&quot;, &amp;start, &amp;over);        spfa(start, head_a, a, dis_a, vis_a);        spfa(over, head_b, b, dis_b, vis_b);        for(int i = 1; i &lt;= m; ++i)            if(u[i] != v[i] &amp;&amp; dis_a[ u[i] ] + dis_b[ v[i] ] + w[i] == dis_a[over])            {                add(cnt_c, c, head_c, u[i], v[i], 1);                add(cnt_c, c, head_c, v[i], u[i], 0);            }        maxflow = 0;        Dinic(start, over);        cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>注意形参里的引用与指针的合理使用!</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4725 The shortest Path in Nya Graph</title>
      <link href="2020/03/08/HDU-4725-The-shortest-Path-in-Nya-Graph/"/>
      <url>2020/03/08/HDU-4725-The-shortest-Path-in-Nya-Graph/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点分别落在各层(layer), 每层可能有多个点, 也可能没有点, 每一层和其上下两层之间的点权值为C。另外有M条权值为w的边, 求1到N的最短路径, 如果不存在输出 -1</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>如果N个点均匀落在相邻两层上，那么连线是N ^ 2级别的，会TLE</p><p>优化：每层设立一个层节点，(i + n)表示第i层的层节点标号</p><p>层节点指向本层所有节点，权值为0</p><p>本层所有节点指向相邻层的层节点，权值为w</p></blockquote><p><img src="https://i.postimg.cc/fWphfZfG/before.png" alt="before"></p><p><img src="https://i.postimg.cc/vDFkFYPD/after.png" alt="after"></p><blockquote><p>上图例子中，优化前18条单向边，优化后12条</p><p>添加层节点消耗了空间，换取了时间</p><p>另外，Dijkstra堆优化真好用，用过即AC(好过stack实现的spfa)</p><p>还有，Dijkstra堆优化存图时用vector+pair</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100105;const int inf = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;vector&lt;P&gt; node[2 * N];int layer[2 * N], head[2 * N], cnt, dis[2 * N], tot, sum, n, m, c;bool vis[2 * N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n + n; ++i)        dis[i] = inf, vis[i] = 0, node[i].clear(), layer[i] = 0;}void Dijkstra(){    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;    dis[1] = 0;    q.push(P(dis[1], 1));    while(!q.empty())    {        P now = q.top();        q.pop();        int idx = now.second;        if(vis[idx])            continue;        vis[idx] = 1;        int sz = node[idx].size();        for(int i = 0; i &lt; sz; ++i)        {            P nxt = node[idx][i];            if(dis[nxt.second] &gt; dis[idx] + nxt.first)            {                dis[nxt.second] = dis[idx] + nxt.first;                q.push(P(dis[nxt.second], nxt.second));            }        }    }}int main(){    int t, tot = 1;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;c);        init();        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d&quot;, &amp;layer[i]);        for(int i = 1; i &lt;= n; ++i)///traverse each node instead of each layer        {            node[ layer[i] + n ].push_back(P(0, i));            if(layer[i] &gt; 1)                node[i].push_back(P(c, layer[i] + n - 1));            if(layer[i] &lt; n)                node[i].push_back(P(c, layer[i] + n + 1));        }        int u, v, w;        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d %d %d&quot;, &amp;u, &amp;v, &amp;w);            node[u].push_back(P(w, v));            node[v].push_back(P(w, u));        }        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; tot++ &lt;&lt; &quot;: &quot;;        Dijkstra();        if(dis[n] != inf)            cout &lt;&lt; dis[n] &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LightOJ 1074 Extended Traffic(The shortest path)</title>
      <link href="2020/03/08/LightOJ-1074-Extended-Traffic-The-shortest-path/"/>
      <url>2020/03/08/LightOJ-1074-Extended-Traffic-The-shortest-path/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出n个点的权值(不超过20),点 i 到点 j 之间的距离(如果可达)为(a[j] - a[i]) ^ 3,求到查询点的最短路径</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>单向边，可有负权边，可含负权环 -&gt; 用spfa叭</p><p>若某个点在负权环里(<code>++times[to] &gt; n</code>)，那么从点to出发所能到达的点(无论是否在负权环里)到起点的距离都是无限小，可以DFS枚举所有<strong>可达点</strong>并标记</p><p>（补充一下：若是单纯求负权环上所有点，应该与强连通分量有关，不仅仅是DFS这么简单）</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_N = 205;const int INF = 0x3f3f3f3f;int n, val[MAX_N];struct edge{    int to, w, pre;} e[50005];int cnt, head[50005], dis[MAX_N], vis[MAX_N], times[MAX_N], through_circle[MAX_N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        head[i] = -1, dis[i] = INF, vis[i] = 0, times[i] = 0, through_circle[i] = 0;}void add(int from, int to, int w){    e[cnt].to = to;    e[cnt].w = w;    e[cnt].pre = head[from];    head[from] = cnt++;}///这些点不仅是负环上的点，还有不在负环上但最短路经由负环的点!void DFS(int now){    through_circle[now] = 1;    for(int i = head[now]; ~i; i = e[i].pre)        if(!through_circle[ e[i].to ])            DFS(e[i].to);}void spfa(){    dis[1] = 0;    queue&lt;int&gt; q;    q.push(1);    vis[1] = 1, times[1] = 1;    while(!q.empty())    {        int now = q.front();        q.pop();        vis[now] = 0;        for(int i = head[now]; ~i; i = e[i].pre)        {            int to = e[i].to;            if(dis[to] &gt; dis[now] + e[i].w)            {                dis[to] = dis[now] + e[i].w;                if(!through_circle[to] &amp;&amp; !vis[to])                    q.push(to), vis[to] = 1;                if(++times[to] &gt; n)                    DFS(to);            }        }    }}int main(){    int _, tot = 1;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d&quot;, &amp;n);        init();        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d&quot;, &amp;val[i]);        int num, u, v, w;        scanf(&quot;%d&quot;, &amp;num);        for(int i = 0; i &lt; num; ++i)        {            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);            w = (val[v] - val[u])*(val[v] - val[u])*(val[v] - val[u]);            add(u, v, w);        }//        Dijkstra();        spfa();        int q;        cout &lt;&lt; &quot;Case &quot; &lt;&lt; tot++ &lt;&lt; &quot;:\n&quot;;        scanf(&quot;%d&quot;, &amp;num);        while(num--)        {            scanf(&quot;%d&quot;, &amp;q);            ///cout &lt;&lt; (dis[q] &lt;= 3 ? &#39;?&#39; : dis[q]) &lt;&lt; &#39;\n&#39;;            if(dis[q] &lt; 3 || dis[q] == INF || through_circle[q] == 1)                cout &lt;&lt; &#39;?&#39; &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; dis[q] &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><blockquote><p>补充：三目运算符后面两者的类型需要一致</p><p><code>dis[q] &lt;= 3 ? &#39;?&#39; : dis[q]</code></p><p>以上代码该输出’?’的时候输出了63(?的ASCLL码)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1062 昂贵的聘礼(The shortest path)</title>
      <link href="2020/03/07/POJ-1062-%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC-The-shortest-path/"/>
      <url>2020/03/07/POJ-1062-%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC-The-shortest-path/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>男方去女方家提亲，女方提出要 P 彩礼，男方觉得有点多，于是女方提出可以拿 物品T 来，那样彩礼只要 V。物品T在第 i 个人那里， 男方去求取，遇到了同样的困难：要钱太多但倘若拿来某物品，可以给他优惠。</p><p>女方这边有等级差别，你所交易的人中，任意两人等级不可大于M。</p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>M(等级差别限制)   N(可交易人 1 ~ N 1是女方家里人，是最终要交易的对象)</p><p>接下来N个描述</p><p>P(该交易人所有物品的价值)    ——每个交易人只有一个物品</p><p>L(该交易人等级)</p><p>X(优惠方案数)</p><p>紧跟X行， 每行 T(交易人编号) V(该交易人物品价格)</p><p>花最少的钱取到1号手里的物品：那个她</p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>先撇开等级限制，可以Dijkstra求出点1到其他所有点的最短路dis[i]，那么dis[i]+val[i] 就是一直换到物品i的最少花费，由于最终换到谁才满足花费最少不确定，所以遍历一遍取最小值即可。</p><p>再考虑等极限制，由于必定与1交易，所以交易人等级区间为<code>[val[1]-M,val[1]+M]</code>，但有可能交易时出错，比如跟<code>val[1]-M</code>和<code>val[1]+M</code>交易，那么他俩等级差都2M了。所以可行区间应为<code>[val[1]-M, val[1]]</code>、<code>[val[1]-M+1, val[1]+1]</code>……遍历枚举区间即可</p></blockquote><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><blockquote><p>图是有向图（边是单向边）</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n;vector&lt;int&gt; vec;bool vis[105];int val[105], lev[105], e[105][105], dis[105];int Dijkstra(){    memset(dis, INF, sizeof(dis));    memset(vis, 0, sizeof(vis));    dis[1] = 0;    int mmin = INF, pos = 0, sz = vec.size();    for(int i = 0; i &lt; sz; ++i)    {        mmin = INF, pos = 0;        for(int j = 0; j &lt; sz; ++j)        {            int to = vec[j];            if(!vis[to] &amp;&amp; dis[to] &lt; mmin)            {                mmin = dis[to];                pos = to;            }        }        vis[pos] = 1;        for(int j = 0; j &lt; sz; ++j)        {            int to = vec[j];            if(vis[to])                continue;            if(dis[to] &gt; dis[pos] + e[pos][to])                dis[to] = dis[pos] + e[pos][to];        }    }    int res = INF;    for(int i = 0; i &lt; sz; ++i)    {        int to = vec[i];        dis[to] += val[to];        res = min(res, dis[to]);    }    return res;}int main(){    scanf(&quot;%d %d&quot;, &amp;m, &amp;n);    for(int i = 1; i &lt;= n; ++i)        for(int j = i; j &lt;= n; ++j)            e[i][j] = e[j][i] = INF;    int P, L, X, T, V;    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%d %d %d&quot;, &amp;P, &amp;L, &amp;X);        val[i] = P, lev[i] = L;        for(int j = 1; j &lt;= X; ++j)        {            scanf(&quot;%d %d&quot;, &amp;T, &amp;V);            e[i][T] = V;///The graph is directed.        }    }    int ans = INF;    for(int down = lev[1] - m; down &lt;= lev[1]; ++down)    {        vec.clear();        for(int j = 1; j &lt;= n; ++j)            if(lev[j] &gt;= down &amp;&amp; lev[j] &lt;= down + m)                vec.push_back(j);        ans = min(ans, Dijkstra());    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces contest 853 A Planning(优先队列贪心)</title>
      <link href="2020/01/21/Codeforces-contest-853-A-Planning-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%B4%AA%E5%BF%83/"/>
      <url>2020/01/21/Codeforces-contest-853-A-Planning-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>分别在1~N分钟该起飞的航班，因技术问题全部推迟k分钟起飞，但现在可以重新安排k+1 ~ k+1+N这N分钟，每分钟起飞一个航班，前提是不能比起初计划早。每个航班每推迟一分钟有代价c[i]，求最小代价及安排。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>原想着：贪心给每个航班参考代价安排起飞时间，先安排代价大的航班，可是发现一个问题，不能保证最后剩余的时间合理(满足前提)，就是说假如最后剩余的航班原计划在第5分钟起飞但(由于我的分配策略)只剩下第3分钟了…</p><p>换位思考：既然给航班分配起飞时刻不行，不如给起飞时刻分配航班。</p><p>给当前时刻分配<strong>时间合理的、代价最大的</strong>航班，把时间合理的航班放进一个人容器里，从中找出代价最大的，用优先队列。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longtypedef pair&lt;ll, ll&gt; P;const int N = 300005;P fli[N];int main(){    ll n, k;    while(~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k))    {        ll ans = 0, first = 0, second;        priority_queue&lt;P, vector&lt;P&gt;, less&lt;P&gt; &gt; q;        vector&lt;P&gt; vec;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%lld&quot;, &amp;first);            fli[i] = P(first, i);        }        for(int i = 1; i &lt;= k; ++i)            q.push(fli[i]);        for(int i = k + 1; i &lt;= k + n; ++i)        {            if(i &lt;= n)                q.push(fli[i]);            first = q.top().first;            second = q.top().second;            q.pop();            ans += first * (i - second);            vec.push_back(P(second, i));        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        sort(vec.begin(), vec.end());        int sz = vec.size();        for(int i = 0; i &lt; sz; ++i)            printf(&quot;%lld%c&quot;, vec[i].second, (i == sz - 1) ? &#39;\n&#39;: &#39; &#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2502 Subway(最短路,自行建图)</title>
      <link href="2020/01/19/POJ-2502-Subway-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%87%AA%E8%A1%8C%E5%BB%BA%E5%9B%BE/"/>
      <url>2020/01/19/POJ-2502-Subway-%E6%9C%80%E7%9F%AD%E8%B7%AF-%E8%87%AA%E8%A1%8C%E5%BB%BA%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>小k要从家去学校，他可以选择步行或者地铁，步行的速度是10km/h，地铁的速度是40km/h。(忽略等待地铁的时间)</p><p>小k可以随意上下地铁，并且可以(通过步行)在地铁线路之间转换。所有的地铁运行都是双向的。</p><p>求从家到校的最短用时。</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>此题最重要的地方在于建模：构图。</p><p>将家设为点0，学校设为点1，每个地铁站(假设共有x个)站点都设为一点，<strong>相邻两个</strong>之间的边(地铁边)的权值是距离/地铁速度。将这(x+2)个点中<strong>任意两个</strong>之间建立步行边，权值是距离/步行速度。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double eps = 1e-8;const double INF = double(0x3f3f3f3f);typedef pair&lt;double, double&gt; P;P node[505];int cnt;double e[220][220];double dis(P a, P b){    return sqrt( (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second) );}void floyd(){    for(int k = 0; k &lt; cnt; ++k)        for(int i = 0; i &lt; cnt; ++i)            for(int j = 0; j &lt; cnt; ++j)                if(e[i][j] &gt; e[i][k] + e[k][j])                    e[i][j] = e[i][k] + e[k][j];}void init(){    for(int i = 0; i &lt; 210; ++i)        for(int j = 0; j &lt; 220; ++j)            e[i][j] = e[j][i] = (i == j ? 0 : INF);}int main(){    init();    double x, y;    scanf(&quot;%lf %lf&quot;, &amp;x, &amp;y);    node[cnt++] = P(x, y);///start : 0    scanf(&quot;%lf %lf&quot;, &amp;x, &amp;y);    node[cnt++] = P(x, y);///end : 1    int pos = 2;    while(~scanf(&quot;%lf%lf&quot;, &amp;x, &amp;y))    {        if(fabs(x + 1.0) &lt; eps &amp;&amp; fabs(y + 1.0) &lt; eps)        {            for(int i = pos; i + 1 &lt; cnt; ++i)                e[i][i + 1] = e[i + 1][i] = dis(node[i], node[i + 1]) / 40000.0;            pos = cnt;        }        else            node[cnt++] = P(x, y);    }    for(int i = 0; i &lt; cnt; ++i)        for(int j = i + 1; j &lt; cnt; ++j)            e[i][j] = e[j][i] = min(e[i][j], dis(node[i], node[j]) / 10000.0);    floyd();    printf(&quot;%d&quot;, int(e[0][1] * 60.0 + 0.5));    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3159 Candies(最短路解差分约束)</title>
      <link href="2020/01/18/POJ-3159-Candies-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%A7%A3%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
      <url>2020/01/18/POJ-3159-Candies-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%A7%A3%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>堆(优先队列)优化的Dijkstra</p><p>用栈(而非队列)实现spfa</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>题目是求从1到n的最短路（差分约束）</p><p>关键在于算法的优化</p><p>①堆优化的Dijkstra：</p><p>我之前的Dijkstra都是手动去模拟那个优化过程的，可能因为模拟地不准确而效果不好？易TLE</p><p>②栈实现的spfa：</p><p>spfa是对Bellman-Ford的优化，Bellman-Ford是在暴力求解最短路。</p><p>假设：图只是一棵树，1起点，n终点，从终点向起点添边，则复杂度达到最大n*m,n-1次对m条边的松弛，每次对m条边松弛只有一次是有用的！</p><p>而spfa是以松弛过的点为基去松弛，保证了大部分松弛都是有效的，至少是可能的</p><p>而spfa的实现，按理说用队列还是栈没区别，但事实是：用栈比用队列快？？？而且前提是没有负环？？？</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 30005;const int INF = 0x3f3f3f3f;struct edge{    int to, w, pre;} a[N * 5];typedef pair&lt;int, int&gt; P;int n, m;bool vis[N];int head[N], cnt, dis[N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = INF, vis[i] = 0, head[i] = -1;}void add(int from, int to, int w){    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt++;}void dijkstra(int start){    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;    dis[start] = 0;    q.push( P(0, start) );    while(!q.empty())    {        P now = q.top();        q.pop();        int dist = now.first;        int idx = now.second;        if(dis[idx] &lt; dist)///vis[idx] == 1            continue;        for(int i = head[idx]; ~i; i = a[i].pre)        {            int v = a[i].to;            if(dis[v] &gt; dis[idx] + a[i].w)            {                dis[v] = dis[idx] + a[i].w;                q.push(P(dis[v], v));            }        }    }}void spfa(int start){    stack&lt;int&gt; st;    dis[start] = 0;    vis[start] = 1;    st.push(start);    while(!st.empty())    {        int now = st.top();        st.pop();        vis[now] = 0;        for(int i = head[now]; ~i; i = a[i].pre)        {            int v = a[i].to;            if(dis[v] &gt; dis[now] + a[i].w)            {                dis[v] = dis[now] + a[i].w;                if(!vis[v])                {                    st.push(v);                    vis[v] = 1;                }            }        }    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        init();        int u, v, w;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add(u, v, w);        }//        dijkstra(1);        spfa(1);        cout &lt;&lt; dis[n] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>另外补充一句：普通的队列与栈，都可以用数组模拟</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>石子合并(区间DP)</title>
      <link href="2020/01/12/SDNUOJ-1045-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6-%E5%8C%BA%E9%97%B4DP/"/>
      <url>2020/01/12/SDNUOJ-1045-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6-%E5%8C%BA%E9%97%B4DP/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有n堆石子排成一行，每次选择相邻的两堆石子，将其合并为一堆，记录该次合并的得分为两堆石子个数之和。已知每堆石子的石子个数，求当所有石子合并为一堆时，最小的总得分。</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>一大堆石子由两小堆石子堆成，此次操作的得分为两小堆石子质量之和，而倘若这两小堆石子又各是由两小小堆石子堆成，那么此次操作的得分是：两堆石子之和 <strong>+</strong> 堆成第一堆的得分 <strong>+</strong> 堆成第二堆的得分</p><p>状态转移方程：</p><p>dp[i][j] = dp[i][k] + dp[k + 1][j] + (sum[j] - sum[i - 1]) </p></blockquote><h3 id="Code-of-SDNUOJ-1045"><a href="#Code-of-SDNUOJ-1045" class="headerlink" title="Code of SDNUOJ 1045"></a>Code of SDNUOJ 1045</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);int a[205];int sum[205];int dp[205][205];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        memset(a, 0, sizeof(a));        memset(sum, 0, sizeof(sum));        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum[i] = sum[i - 1] + a[i];        }        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                dp[i][j] = (i == j ? 0 : INF);        for(int len = 1; len &lt;= n; ++len)            for(int i = 1; i + len - 1 &lt;= n; ++i)                for(int j = i; j &lt;= i + len - 1; ++j)                    dp[i][i + len - 1] = min(dp[i][i + len - 1], dp[i][j] + dp[j + 1][i + len - 1] + sum[i + len - 1] - sum[i - 1]);        cout &lt;&lt; dp[1][n] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-of-SDNUOJ-1048"><a href="#Code-of-SDNUOJ-1048" class="headerlink" title="Code of SDNUOJ 1048"></a>Code of SDNUOJ 1048</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);int a[405];int sum[405];int dp[405][405];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        memset(a, 0, sizeof(a));        memset(sum, 0, sizeof(sum));        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum[i] = sum[i - 1] + a[i];        }        for(int i = n + 1; i &lt;= 2 * n; ++i)        {            a[i] = a[i - n];            sum[i] = sum[i - 1] + a[i];        }        for(int i = 1; i &lt;= 2 * n; ++i)            for(int j = 1; j &lt;= 2 * n; ++j)                dp[i][j] = (i == j ? 0 : INF);        for(int len = 1; len &lt;= 2 * n; ++len)            for(int i = 1; i + len - 1 &lt;= 2 * n; ++i)                for(int j = i; j &lt;= i + len - 1; ++j)                    dp[i][i + len - 1] = min(dp[i][i + len - 1], dp[i][j] + dp[j + 1][i + len - 1] + sum[i + len - 1] - sum[i - 1]);        int ans = INF;        for(int i = 1; i &lt;= n; ++i)            ans = min(ans, dp[i][i + n - 1]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DPの区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 ICPC Asia Nanchang Regional</title>
      <link href="2019/12/09/2019-ICPC-Asia-Nanchang-Regional/"/>
      <url>2019/12/09/2019-ICPC-Asia-Nanchang-Regional/</url>
      
        <content type="html"><![CDATA[<h2 id="E-Bob’sProblem"><a href="#E-Bob’sProblem" class="headerlink" title="E.Bob’sProblem"></a>E.Bob’sProblem</h2><blockquote><p>N个点（从1到N）</p><p>M条边（带权，有黑白两种）</p><p>选边，使得在图联通的前提下，边权和最大</p><p>限制条件：白边不能超过K条</p></blockquote><a id="more"></a><h3 id="analyze"><a href="#analyze" class="headerlink" title="analyze"></a>analyze</h3><blockquote><p>1.黑边没有限制数目，又是求最大边权和，所以选择所有黑边</p><p>2.(无向图可用并查集缩点)缩点后，对于白边，求最大生成树</p><p>3.若有多余白边(在K的限制下)，贪心选取权值大的</p><p>细节：①int node = n;每次连入一个点node—，若最后node&gt;1不能生成树输出-1.②每次用一条白边k—，若最后k<0白边不够用输出-1.③求生成树过程中未用到的白边单独存一数组中，若最后k>0则sort后贪心选.</0白边不够用输出-1.③求生成树过程中未用到的白边单独存一数组中，若最后k></p><p>有点东西：这题里，无向图求缩点，和 求生成树，都用了并查集</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst int maxn = 50005;const int maxm = 500005;struct edge{    ll u, v, w;    bool operator &lt; (const edge t) const    {        return w &gt; t.w;    }};edge white[maxm];edge black[maxm];edge other[maxm];ll pre[maxn];ll found(ll x){    return x == pre[x] ? x : pre[x] = found(pre[x]);}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        ll n, m, k, u, v, w, c, ans = 0, b_num = 0, w_num = 0, o_num = 0;        scanf(&quot;%lld %lld %lld&quot;, &amp;n, &amp;m, &amp;k);        for(ll i = 0; i &lt; m; ++i)        {            scanf(&quot;%lld %lld %lld %lld&quot;, &amp;u, &amp;v, &amp;w, &amp;c);            if(c == 0)            {                black[b_num].u = u;                black[b_num].v = v;                black[b_num].w = w;                b_num++;            }            else            {                white[w_num].u = u;                white[w_num].v = v;                white[w_num].w = w;                w_num++;            }        }        ///选择所有的黑边 + 并查集缩点(无向图)        for(ll i = 0; i &lt;= n; ++i)            pre[i] = i;        ll node = n;        for(ll i = 0; i &lt; b_num; ++i)        {            ll x = found(black[i].u);            ll y = found(black[i].v);            if(x != y)            {                pre[x] = y;                node--;            }            ans += black[i].w;        }        ///Kruskal最大生成树        sort(white, white + w_num);        for(ll i = 0; i &lt; w_num; ++i)        {            ll x = found(white[i].u);            ll y = found(white[i].v);            if(x != y)            {                pre[x] = y;                node--, k--;                ans += white[i].w;            }            else                other[o_num++] = white[i];        }        if(node &gt; 1 || k &lt; 0)            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        else        {            sort(other, other + o_num);            for(ll i = 0; i &lt; k &amp;&amp; i &lt; o_num; ++i)                ans += other[i].w;            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><h2 id="C-And-and-Pair"><a href="#C-And-and-Pair" class="headerlink" title="C.And and Pair"></a>C.And and Pair</h2><blockquote><p>给出一个大数N的二进制表示，找出有多少有序对(i, j)满足以下条件</p></blockquote><p><img src="https://i.postimg.cc/CKGvh0st/4-BWPM-A-4-R4-GB-0-ANK.png" alt="factors"></p><h2 id="analyze-1"><a href="#analyze-1" class="headerlink" title="analyze"></a>analyze</h2><blockquote><p>1.i &gt;= j</p><p>2.n的0位，i在该位上也必须是0</p><p>3.i的1位，j在该位上必须是0(这也说明i &gt; j)</p><p>于是，针对n，先确定i，再根据i确定j</p><p>①我们先看 i 与 j 的关系：</p><p>针对某个 i ，将其最高位1前导0去掉后，剩x个0， j 就有<img src="https://i.postimg.cc/3rn9KL79/ST-L0-7-P2-PK2-W3-C7-L3-C-1-G.png" alt="2^x">种</p><p>因为 j 在 i 的每个0位上可选0或1</p><p>②再来看 n 推 i 推 j ：</p><p>从低位到高位看（从右向左），（因为从左向右不好算）</p><p>找到1所在位，若它右边有 y 个1，x 个0，推导总结得方案数：</p><blockquote><p><img src="https://i.postimg.cc/L6kfVD6L/QVB-2-PZU-A-K-54-CX5-S.png" alt="figure1"></p></blockquote><p>又有公式</p><blockquote><p><img src="https://i.postimg.cc/t4KjC3Wv/Y3-H-EY-3-NT69-BS6-RE-5.png" alt="figure2"></p></blockquote><p>得方案数: <img src="https://i.postimg.cc/RVJpCjd9/WDVAP5-RS-TG-9-U4-NP-F.png" alt="figure3"></p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;using namespace std;const int mod = int(1e9 + 7);#define ll long long/// i &gt;=  j/// n 的 0 位, i 在该位上也必须是0/// i 的 1 位, j 在该位上必须是0 (i &gt; j)ll num2[100005];ll num3[100005];int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    num3[0] = num2[0] = 1;    for(int i = 1; i &lt;= 100001; ++i)    {        num2[i] = num2[i - 1] * 2 % mod;        num3[i] = num3[i - 1] * 3 % mod;    }    while(_--)    {        string s;        cin &gt;&gt; s;        ll ans = 0;        int len = s.length(), zero = 0, one = 0;        for(int i = len - 1; i &gt;= 0; --i)        {            if(s[i] == &#39;1&#39;)            {                ans = (ans + (num2[zero] * num3[one] % mod)) % mod;                one++;            }            else                zero++;        }        ans = (ans + 1) % mod;        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><p><img src="https://i.postimg.cc/d0VrSFZY/M5-I4-YR5-MJUT-JP-D-6-Y2-HJ.png" alt="什么鬼"></p><h2 id="G-Eating-Plan"><a href="#G-Eating-Plan" class="headerlink" title="G.Eating Plan"></a>G.Eating Plan</h2><blockquote><p>N个数字（1~N的排列），Q组询问</p><p>某个数字的阶乘 代表 那堆食物的 重量</p><p>必须连续进食（吃第3、5堆则必须吃第4堆）</p><p>肚子里攒 998857459 就减去它(这个地方是在说取模)</p><p>询问 K ，最少吃几堆，才能使肚子里的食物不少于K</p></blockquote><h3 id="analyze-2"><a href="#analyze-2" class="headerlink" title="analyze"></a>analyze</h3><blockquote><p>凡涉及 <strong>阶乘取模</strong> ，想想是不是到哪一个数字就成0了，此后都是0</p><p>这个模数998857459是合数，更有可能，打表发现在2803项是这样的</p><p>①预处理 前2802的阶乘</p><p>②RMQ离线处理询问（不过这个RMQ的处理方法，是通解吗？）</p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longconst ll maxn = 100005;const ll mod = 998857459;ll num[maxn];ll fac[maxn];ll sum[maxn];ll ans[maxn];ll cnt;struct node{    ll val, id;} rec[maxn];int main(){    fac[0] = 1;    for(ll i = 1; i &lt;= 3000; ++i)    {        fac[i] = fac[i - 1] * i % mod;        if(fac[i] == 0)        {            ///cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;///2803            break;        }    }    ll n, m;    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);    for(ll i = 1; i &lt;= n; ++i)    {        scanf(&quot;%lld&quot;, &amp;num[i]);        num[i] = fac[ num[i] ];    }    for(ll i = 1; i &lt;= n; ++i)        if(num[i])        {            cnt++;            rec[cnt].id = i;            rec[cnt].val = num[i];//            sum[cnt] = (sum[cnt - 1] + num[i]) % mod;            sum[cnt] = (sum[cnt - 1] + num[i]);        }    for(ll i = 1; i &lt;= cnt; ++i)        for(ll j = i; j &lt;= cnt; ++j)            ans[ rec[j].id - rec[i].id + 1 ] = max(ans[ rec[j].id - rec[i].id + 1 ], (sum[j] - sum[i - 1]) % mod);    while(m--)    {        ll q, len = -1;        scanf(&quot;%lld&quot;, &amp;q);        for(ll i = 1; i &lt;= n; ++i)            if(ans[i] &gt;= q)            {                len = i;                break;            }        if(len == -1)            puts(&quot;-1&quot;);        else            cout &lt;&lt; len &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2295 Radar (DLX + binary search)</title>
      <link href="2019/11/26/HDU-2295-Radar-DLX-binary-search/"/>
      <url>2019/11/26/HDU-2295-Radar-DLX-binary-search/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个城市，共M处布有雷达，条件受限，这M处雷达只能选用K个去覆盖城市，求雷达最小覆盖半径</p></blockquote><a id="more"></a><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><blockquote><p>Dancing-Links-X</p><p>行：可选解决方案——那些雷达</p><p>列：目标覆盖区域——那些城市</p><p>二分查找半径，判断：如果第i个雷达在此半径下能覆盖第j个城市，那么link(i, j)，问题转换为DLX重复覆盖：选取一些行，使得每列含有1</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxnode = 3005;const double eps = 1e-8;int n, m, k;struct node{    double x, y;};node city[55], radar[55];int cnt[55], Head[55], vis[55];int L[maxnode], R[maxnode], U[maxnode], D[maxnode];int Row[maxnode], Col[maxnode];bool check(int i, int j, double dis){    if((city[i].x - radar[j].x) * (city[i].x - radar[j].x) + (city[i].y - radar[j].y) * (city[i].y - radar[j].y) &lt; dis * dis)        return true;    return false;}void init(){    for(int i = 0; i &lt;= n; ++i)///列表元素    {        cnt[i] = 0;        L[i] = i - 1;        R[i] = i + 1;        U[i] = D[i] = i;    }    L[0] = n;    R[n] = 0;    memset(Head, -1, sizeof(Head));}void link(int row, int col, int id){    Row[id] = row;    Col[id] = col;    U[id] = U[col];    D[id] = col;    D[ U[col] ] = id;    U[col] = id;    if(Head[row] == -1)        Head[row] = L[id] = R[id] = id;    else    {        L[id] = L[ Head[row] ];        R[id] = Head[row];        R[ L[ Head[row] ] ] = id;        L[ Head[row] ] = id;    }    cnt[col]++;}///具体删除列void abandon(int id){    for(int i = D[id]; i != id; i = D[i])        L[ R[i] ] = L[i], R[ L[i] ] = R[i];}void resume(int id){    for(int i = D[id]; i != id; i = D[i])        L[ R[i] ] = R[ L[i] ] = i;}int h(){    int num = 0;    memset(vis, 0, sizeof(vis));    for(int i = R[0]; i != 0; i = R[i])    {        if(!vis[i])        {            num++;            for(int j = D[i]; j != i; j = D[j])                for(int k = R[j]; k != j; k = R[k])                    vis[ Col[k] ] = 1;        }    }    return num;}bool Dance(int deep){    if(deep + h() &gt; k)        return 0;    if(R[0] == 0)    {        if(deep &lt;= k)            return 1;        return 0;    }    int c = R[0];    for(int i = R[0]; i != 0; i = R[i])        if(cnt[i] &lt; cnt[c])            c = i;    for(int i = D[c]; i != c; i = D[i])    {        abandon(i);///参数为id 我选这个1,后续无需参考此列(删除)        for(int j = R[i]; j != i; j = R[j])            abandon(j);///删除1元素所在行上 1元素所在列        if(Dance(deep + 1))            return 1;        for(int j = R[i]; j != i; j = R[j])            resume(j);        resume(i);    }    return 0;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%lf%lf&quot;, &amp;city[i].x, &amp;city[i].y);        for(int i = 1; i &lt;= m; ++i)            scanf(&quot;%lf%lf&quot;, &amp;radar[i].x, &amp;radar[i].y);        double L = 0, R = 2000;        while(R - L &gt; eps)        {            double mid = (R + L) / 2.0;            init();            int id = n;            for(int i = 1; i &lt;= n; ++i)///列Col                for(int j = 1; j &lt;= m; ++j)///行Row                {                    if(check(i, j, mid))                        link(j, i, ++id);                }            if(Dance(0))                R = mid;            else                L = mid;        }        printf(&quot;%.6f\n&quot;, R);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 优化の二分 </tag>
            
            <tag> 数据结构のDancing-Links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 CCPC Harbin F-Fixing Banners</title>
      <link href="2019/11/24/2019-CCPC-Harbin-F-Fixing-Banners/"/>
      <url>2019/11/24/2019-CCPC-Harbin-F-Fixing-Banners/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出6个字符串，问：是否能刚好从每个字符串上扣下一个字母组成‘harbin’</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>最近看Dancing Links X，Dancing Links 据说是优化特殊DFS的一种数据结构，这里说的’特殊DFS’指：建模后是01矩阵，少选择几行，使每列有1。但这个题要求每行都必须选，就不是DLX算法了，只是简单的搜索。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string s;int mp[10][10];bool vis[10];bool DFS(int deep){    if(deep == 7)        return 1;    for(int i = 1; i &lt;= 6; ++i)        if(!vis[i] &amp;&amp; mp[deep][i])        {            vis[i] = 1;            if(DFS(deep +1))                return 1;            vis[i] = 0;        }    return 0;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        memset(mp, 0, sizeof(mp));        memset(vis, 0, sizeof(vis));        for(int i = 1; i &lt;= 6; ++i)        {            cin &gt;&gt; s;            if(s.find(&#39;h&#39;) != -1)                mp[i][1] = 1;            if(s.find(&#39;a&#39;) != -1)                mp[i][2] = 1;            if(s.find(&#39;r&#39;) != -1)                mp[i][3] = 1;            if(s.find(&#39;b&#39;) != -1)                mp[i][4] = 1;            if(s.find(&#39;i&#39;) != -1)                mp[i][5] = 1;            if(s.find(&#39;n&#39;) != -1)                mp[i][6] = 1;        }        if(DFS(1))            cout &lt;&lt; &quot;Yes\n&quot;;        else            cout &lt;&lt; &quot;No\n&quot;;    }    return 0;}</code></pre><blockquote><p>也是建模成01矩阵，然后DFS搜索：从每行选出一个字母，使得每列含1</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FZU 1686 神龙的难题(DLX repeat cover)</title>
      <link href="2019/11/24/FZU-1686-%E7%A5%9E%E9%BE%99%E7%9A%84%E9%9A%BE%E9%A2%98-DLX-repeat-cover/"/>
      <url>2019/11/24/FZU-1686-%E7%A5%9E%E9%BE%99%E7%9A%84%E9%9A%BE%E9%A2%98-DLX-repeat-cover/</url>
      
        <content type="html"><![CDATA[<h3 id="Deacription"><a href="#Deacription" class="headerlink" title="Deacription"></a>Deacription</h3><blockquote><p>N x M的01矩阵，给出a、b，表示一次性可以将a行b列的小矩阵内的数字全变成0，问最终使全图为0需要几步</p></blockquote><a id="more"></a><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><blockquote><p>把每个1视为列，每一种覆盖方式视为行</p><p>最少需要拿出多少行，使得每列都含有1——重复覆盖</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_V = 100005;///数组开小可能超时int n, m, length, width, res, tot;int cnt[255];///第i列1元素的个数int L[MAX_V], R[MAX_V], U[MAX_V], D[MAX_V];int Head[255];///第i行第一个1元素的ID,意义同列标元素int Row[MAX_V], Col[MAX_V];///记录id所在行列int ans[255], mp[20][20];bool vis[255];void init(){    for(int i = 0; i &lt;= tot; ++i)///初始化Head及tot个列标元素    {        cnt[i] = 0;        L[i] = i - 1;        R[i] = i + 1;        U[i] = i;        D[i] = i;//        Row[i] = 0;//        Col[i] = i;    }    L[0] = tot;    R[tot] = 0;    memset(Head, -1, sizeof(Head));}void link(int row, int col, int id){    Row[id] = row;    Col[id] = col;    U[id] = U[col];///我向上    D[id] = col;///我向下    D[ U[col] ] = id;///我上 下我    U[col] = id;///我下 上我    if(Head[row] == -1)        Head[row] = L[id] = R[id] = id;    else    {        L[id] = L[ Head[row] ];///我向左        R[id] = Head[row];///我向右        R[ L[ Head[row] ] ] = id;///我左 右我        L[ Head[row] ] = id;///我右 左我    }    cnt[col]++;}///具体删除列，没有删除行(这一列有1了，我以后无需参考此列选行)void abandon(int id){    for(int i = D[id]; i != id; i = D[i])///空了id,便于后续删除列        L[ R[i] ] = L[i], R[ L[i] ] = R[i];}void resume(int id){    for (int i = D[id]; i != id; i = D[i])///空了id(因为上面就没abandon)        L[ R[i] ] = R[ L[i] ] = i;}int h(){    int num = 0;    memset(vis, 0, sizeof(vis));    for(int i = R[0]; i != 0; i = R[i])    {        if(vis[i])            continue;        num++;        for(int j = D[i]; j != i; j = D[j])            for(int k = R[j]; k != j; k = R[k])                vis[ Col[k] ] = 1;    }    return num;///当前矩阵可拆解次数}void Dance(int deep){    if(deep + h() &gt;= res)///估价剪枝        return ;    if(R[0] == 0)///准出口(每次abandon都会ban掉列标元素)    {        if(deep &lt; res)            res = deep;        return;    }    ///找到1的数目最少的一列  将列标元素存在c里    int c = R[0];    for(int i = R[0]; i != 0; i = R[i])        if(cnt[i] &lt; cnt[c])            c = i;    ///对于c列1元素所在行，遍历每行，看看选择哪一行合适    ///最少含1列，1所在行必然不被同时选    for(int i = D[c]; i != c; i = D[i])    {        ans[deep] = Row[i];///选当前行        abandon(i);///我选这个1,后续无需参考此列(删除)        for(int j = R[i]; j != i; j = R[j])            abandon(j);///删除1元素所在行上 1元素所在列        Dance(deep + 1);        for(int j = R[i]; j != i; j = R[j])            resume(j);        resume(i);    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        tot = 0;        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= m; ++j)            {                scanf(&quot;%d&quot;, &amp;mp[i][j]);                if(mp[i][j])                    mp[i][j] = ++tot;            }        int id = tot, block = 0;        init();        scanf(&quot;%d%d&quot;, &amp;length, &amp;width);        for(int i = 1; i + length - 1 &lt;= n; ++i)            for(int j = 1; j + width - 1 &lt;= m; ++j)            {                block++;                for(int k = i; k &lt;= i + length - 1; ++k)                    for(int l = j; l &lt;= j + width - 1; ++l)                        if(mp[k][l])                            link(block, mp[k][l], ++id);            }        res = 0x3f3f3f3f;///不要自以为是随便搞        Dance(0);        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构のDancing-Links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 3498 who&#39;s your daddy(DLX repeat cover)</title>
      <link href="2019/11/24/HDU-3948-who-s-your-daddy-DLX-repeat-cover/"/>
      <url>2019/11/24/HDU-3948-who-s-your-daddy-DLX-repeat-cover/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个数字，M组”相邻”关系</p><p>消灭数字，攻击某个数字的时候，它本身以及与它相邻的数字会被消灭，求最少攻击次数</p></blockquote><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-ASN.1">5 41 21 32 44 5</code></pre><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><pre><code class="lang-ASN.1">1 1 1 0 01 1 0 1 01 0 1 0 00 1 0 1 10 0 0 1 1</code></pre><h3 id="问题转换"><a href="#问题转换" class="headerlink" title="问题转换"></a>问题转换</h3><blockquote><p>至少选出多少行,使每列都含有1</p></blockquote><h2 id="Dancing-Links-X-重复覆盖"><a href="#Dancing-Links-X-重复覆盖" class="headerlink" title="Dancing Links X 重复覆盖"></a>Dancing Links X 重复覆盖</h2><blockquote><p>①含1最少列，1所在行“们”必然不会被同时选中</p><p>②含1最少列 中 任选一行，将该行1元素所在列删除(这个过程会删掉列标元素——这样<strong>R[0] == 0</strong>可判作准出口，此列这个1却保留了——为了向右继续删)</p><p>③删除列是因为这列已经有1了，我以后选行的时候无需参考</p><p>④与精确覆盖思路上不同的是：精确覆盖删到只剩Head这个元素算成功，而重复覆盖只是把所有列标元素删掉算找到一个答案(当然它会遍历所有情况，找到最优的)</p><p>⑤与精确覆盖实现上不同的是：重复覆盖abandon与resume函数里的参数是id，而精确覆盖形参是列表元素，里面删除内容也不同</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_V = 10010;int n, m, res;int cnt[105];///第i列1元素的个数int L[MAX_V], R[MAX_V], U[MAX_V], D[MAX_V];int Head[105];///第i行第一个1元素的ID,意义同列标元素int Row[MAX_V], Col[MAX_V];///记录id所在行列int ans[105];bool vis[105];vector&lt;int&gt; vec[105];void init(){    for(int i = 0; i &lt;= n; ++i)///初始化Head及m个列标元素    {        cnt[i] = 0;        L[i] = i - 1;        R[i] = i + 1;        U[i] = i;        D[i] = i;        vec[i].clear();        vec[i].push_back(i);    }    L[0] = n;    R[n] = 0;    memset(Head, -1, sizeof(Head));}void link(int row, int col, int id){    Row[id] = row;    Col[id] = col;    U[id] = U[col];///我向上    D[id] = col;///我向下    D[ U[col] ] = id;///我上 下我    U[col] = id;///我下 上我    if(Head[row] == -1)        Head[row] = L[id] = R[id] = id;    else    {        L[id] = L[ Head[row] ];///我向左        R[id] = Head[row];///我向右        R[ L[ Head[row] ] ] = id;///我左 右我        L[ Head[row] ] = id;///我右 左我    }    cnt[col]++;}///具体删除列，没有删除行(这一列有1了，我以后无需参考此列选行)void abandon(int id){    for(int i = D[id]; i != id; i = D[i])///空了id,便于后续删除列        L[ R[i] ] = L[i], R[ L[i] ] = R[i];}void resume(int id){    for (int i = D[id]; i != id; i = D[i])///空了id(因为上面就没abandon)        L[ R[i] ] = R[ L[i] ] = i;}int h(){    int num = 0;    memset(vis, 0, sizeof(vis));    for(int i = R[0]; i != 0; i = R[i])    {        if(vis[i])            continue;        num++;        for(int j = D[i]; j != i; j = D[j])            for(int k = R[j]; k != j; k = R[k])                vis[ Col[k] ] = 1;    }    return num;///当前矩阵可拆解次数}void Dance(int deep){    if(deep + h() &gt;= res)///估价剪枝        return ;    if(R[0] == 0)///准出口(每次abandon都会ban掉列标元素)    {        if(deep &lt; res)            res = deep;        return;    }    ///找到1的数目最少的一列  将列标元素存在c里    int c = R[0];    for(int i = R[0]; i != 0; i = R[i])        if(cnt[i] &lt; cnt[c])            c = i;    ///abandon(c);重复覆盖，某列含多个1也可选多行    ///对于c列1元素所在行，遍历每行，看看选择哪一行合适    ///最少含1列，1所在行必然不被同时选    for(int i = D[c]; i != c; i = D[i])    {        ans[deep] = Row[i];///选当前行        abandon(i);///我选这个1,后续无需参考此列(删除)        for(int j = R[i]; j != i; j = R[j])            abandon(j);///删除1元素所在行上 1元素所在列        Dance(deep + 1);        for(int j = R[i]; j != i; j = R[j])            resume(j);        resume(i);    }    ///resume(c);    ///return 0;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        init();        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            vec[u].push_back(v);            vec[v].push_back(u);        }        int id = n;///介于id的缘故,需要存完了再link        for(int i = 1; i &lt;= n; ++i)            for(int j = 0; j &lt; vec[i].size(); ++j)                link(i, vec[i][j], ++id);        res = n;        Dance(0);        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构のDancing-Links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hihocoder 1317 (DLX cover precisely)</title>
      <link href="2019/11/17/hihocoder-1317-Dancing-Links-X/"/>
      <url>2019/11/17/hihocoder-1317-Dancing-Links-X/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>小Ho最近遇到一个难题，他需要破解一个棋局。</p><p>棋局分成了n行，m列，每行有若干个棋子。小Ho需要从中选择若干行使得每一列有且恰好只有一个棋子。</p><p><a href="http://hihocoder.com/problemset/problem/1317" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1317</a></p></blockquote><a id="more"></a><h2 id="Dancing-Link-X"><a href="#Dancing-Link-X" class="headerlink" title="Dancing Link X"></a>Dancing Link X</h2><blockquote><p><a href="https://www.cnblogs.com/grenet/p/3145800.html" target="_blank" rel="noopener">https://www.cnblogs.com/grenet/p/3145800.html</a></p><p>Dancing Links : 循环双向链，纵横交叉形成的网状结构</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int MAX_V = 10010;int n, m;int cnt[105];///第i列1元素的个数int L[MAX_V], R[MAX_V], U[MAX_V], D[MAX_V];int Head[105];///第i行第一个1元素的ID,意义同列标元素int Row[MAX_V], Col[MAX_V];///记录id所在行列int ans[105];void init(){    for(int i = 0; i &lt;= m; ++i)///初始化Head及m个列标元素    {        cnt[i] = 0;        L[i] = i - 1;        R[i] = i + 1;        U[i] = i;        D[i] = i;    }    L[0] = m;    R[m] = 0;    for(int i = 0; i &lt;= n; ++i)///初始化“伪行标元素”        Head[i] = -1;}void link(int row, int col, int id){    Row[id] = row;    Col[id] = col;    U[id] = U[col];///我向上    D[id] = col;///我向下    D[ U[col] ] = id;///我上 下我    U[col] = id;///我下 上我    if(Head[row] == -1)        Head[row] = L[id] = R[id] = id;    else    {        L[id] = L[ Head[row] ];///我向左        R[id] = Head[row];///我向右        R[ L[ Head[row] ] ] = id;///我左 右我        L[ Head[row] ] = id;///我右 左我    }    cnt[col]++;}void abandon(int c){    ///抛弃c列    L[ R[c] ] = L[c];///我右的左 在将来 就是现在的 我左    R[ L[c] ] = R[c];    ///抛弃c列1元素所在行(∵不能同时选)    for(int i = D[c]; i != c; i = D[i])        for(int j = R[i]; j != i; j = R[j])        {            U[ D[j] ] = U[j];///我下的上 在将来 就是现在的 我上            D[ U[j] ] = D[j];            --cnt[ Col[j] ];        }}void resume(int c){    ///恢复c列1元素所在行    for (int i = U[c]; i != c; i = U[i])        for (int j = L[i]; j != i; j = L[j])        {            D[ U[j] ] = j;            U[ D[j] ] = j;            ++cnt[ Col[j] ];        }    ///列标元素    L[ R[c] ] = R[ L[c] ] = c;}bool Dance(int deep){    if(R[0] == 0)        return 1;    ///找到1的数目最少的一列  将列标元素存在c里    int c = R[0];    for(int i = R[0]; i != 0; i = R[i])        if(cnt[i] &lt; cnt[c])            c = i;    abandon(c);    ///对于c列1元素所在行，遍历每行，看看选择哪一行合适    for(int i = D[c]; i != c; i = D[i])    {        ans[deep] = Row[i];///选当前行        for(int j = R[i]; j != i; j = R[j])            abandon(Col[j]);///删除1元素所在行上 1元素所在列        if(Dance(deep + 1))            return 1;        for(int j = L[i]; j != i; j = L[j])            resume(Col[j]);    }    resume(c);    return 0;}int main(){    int _, val, id;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        init();        id = m;///0-&gt;Head, [1, m]对应列标元素        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= m; ++j)            {                scanf(&quot;%d&quot;, &amp;val);                if(val)                {                    id++;                    link(i, j, id);                }            }        if(Dance(0))            cout &lt;&lt; &quot;Yes\n&quot;;        else            cout &lt;&lt; &quot;No\n&quot;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构のDancing-Links </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ Sudoku(数独) 2676 2918 3074 3076</title>
      <link href="2019/11/13/POJ-Sudoku-%E6%95%B0%E7%8B%AC-2676-2918-3074-3076/"/>
      <url>2019/11/13/POJ-Sudoku-%E6%95%B0%E7%8B%AC-2676-2918-3074-3076/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>填补数独空白处</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>对于2676 和 2918 两题来说，不需要复杂的剪枝，普通DFS即可过</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int ans[12][12];string s[12];bool flag;bool check (int x, int y, int num){    for(int i = 1; i &lt;= 9; ++i)        if(ans[x][i] == num || ans[i][y] == num)            return 0;    int base_x = (x - 1) / 3 * 3;    int base_y = (y - 1) / 3 * 3;    int xx = x % 3, yy = y % 3;    int cx = (xx + 1) % 3;    int dx = (xx + 2) % 3;    int cy = (yy + 1) % 3;    int dy = (yy + 2) % 3;    if(!cx)        cx = 3;    if(!dx)        dx = 3;    if(!cy)        cy = 3;    if(!dy)        dy = 3;    if(ans[base_x + cx][base_y + cy] == num            || ans[base_x + cx][base_y + dy] == num            || ans[base_x + dx][base_y + cy] == num            || ans[base_x + dx][base_y + dy] == num)        return 0;    return 1;}void DFS(int x, int y){    if(x == 10)    {        flag = 1;        return ;    }    if(flag)        return ;    if(y &gt; 9)        DFS(x + 1, 1);//每次DFS完测一次flag:任意一次退出都可能是完成任务    if(flag)        return ;    if(ans[x][y])        DFS(x, y + 1);    else//原先没把这个for放在else里    {        for(int i = 1; i &lt;= 9; ++i)            if(check(x, y, i))            {                ans[x][y] = i;                DFS(x, y + 1);                if(flag)                    return ;                ans[x][y] = 0;            }    }    if(flag)        return ;}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        flag = 0;        for(int i = 0; i &lt; 9; ++i)            cin &gt;&gt; s[i];        for(int i = 1; i &lt;= 9; ++i)            for(int j = 1; j &lt;= 9; ++j)                ans[i][j] = s[i - 1][j - 1] - &#39;0&#39;;        DFS(1, 1);        for(int i = 1; i &lt;= 9; ++i)        {            for(int j = 1; j &lt;= 9; ++j)                cout &lt;&lt; ans[i][j];            cout &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><h2 id="对于3074（数据强一些）"><a href="#对于3074（数据强一些）" class="headerlink" title="对于3074（数据强一些）"></a>对于3074（数据强一些）</h2><blockquote><p>如果发现某行、某列、某九宫格可填的数字比较少，那么<strong>优先处理</strong>他们</p><p>可关键在于如何标记某行(或某列、某九宫格)有哪些可填数字呢？</p><p>可填数字总共9个，我们可以想到使用二进制进行状态压缩</p><p>用一个十进制数字的二进制形态的1/0位代表可填否</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;char a[120];char b[12][12];int tot;//空的个数int row[12];//第i行可填的数字(二进制状态压缩为一个十进制的int)int col[12];int room[12];int cnt[520];int num[520];int get_room(int x, int y){    return (x - 1) / 3 * 3 + (y - 1) / 3 + 1;/*  1 4 7    2 5 8    3 6 9  */}//某个数字的存在引起该行该列该九宫格不可再填该数字void flip(int x, int y, int z){    row[x] ^= (1 &lt;&lt; z);    col[y] ^= (1 &lt;&lt; z);    room[get_room(x, y)] ^= (1 &lt;&lt; z);}void init(){    //(1 &lt;&lt; 9) - 1 == 2 ^ 10 - 1 == 11111111(二进制)    //默认9个数字皆可填    for(int i = 1; i &lt;= 9; ++i)        row[i] = col[i] = room[i] = (1 &lt;&lt; 9) - 1;    tot = 0;    for(int i = 1; i &lt;= 9; ++i)        for(int j = 1; j &lt;= 9; ++j)        {            b[i][j] = a[ (i - 1) * 9 + j - 1 ];            if(b[i][j] != &#39;.&#39;)                flip(i, j, b[i][j] - &#39;1&#39;);            else                tot++;        }}bool DFS(int tot){    if(tot == 0)        return 1;    int mmin = INF, x, y;    for(int i = 1; i &lt;= 9; ++i)        for(int j = 1 ;j &lt;= 9; ++j)        {            if(b[i][j] != &#39;.&#39;)                continue;            int val = row[i] &amp; col[j] &amp; room[get_room(i, j)];            if(val == 0)//当前格子可填数字的个数为0                return 0;            if(cnt[val] &lt; mmin)            {                x = i, y = j;//这个格子可填数字的个数最少                mmin = cnt[val];//可填数字的个数            }        }    int val = row[x] &amp; col[y] &amp; room[get_room(x, y)];    for(; val; val -= (val &amp; -val))//之前那种方法不太行了....    {        int tem = num[val &amp; -val];        b[x][y] = tem + &#39;1&#39;;        flip(x, y, tem);        if(DFS(tot - 1))            return 1;        flip(x, y, tem);//消除影响        b[x][y] = &#39;.&#39;;    }    return 0;}// (i &amp; -i) == 2 ^ p   (p为i的最低位1所在位)int main(){    //十进制数字i转为二进制时含数字1的个数(对应可填数字个数)    for(int i = 0; i &lt; (1 &lt;&lt; 9); ++i)        for(int j = i; j; j &gt;&gt;= 1)            if(j &amp; 1)                cnt[i]++;    for(int i = 0; i &lt;= 9; ++i)//打表2的整数幂        num[1 &lt;&lt; i] = i;    while(scanf(&quot;%s&quot;, a))    {        if(a[0] == &#39;e&#39;)            break;        init();        DFS(tot);        for(int i = 1; i &lt;= 9; ++i)            for(int j = 1; j &lt;= 9; ++j)                cout &lt;&lt; b[i][j];        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>由于DFS不是本体正解，900ms卡过，而且是交C++过，交G++就超时</p></blockquote><h3 id="对于3076：剪枝情况多而易漏"><a href="#对于3076：剪枝情况多而易漏" class="headerlink" title="对于3076：剪枝情况多而易漏"></a>对于3076：剪枝情况多而易漏</h3><blockquote><p>DFS：</p><p>①遍历所有格子：处理空白格子</p><p> (1)未填空格出错：虽是空白格子，已无可填数字——return 0；</p><p> (2)唯一数字可填：某个空白格子(受所在行列宫的影响)只能填一个数字——填上</p><p>②遍历所有行：每行遍历所有数字[1, 16]</p><p> (1)已填数字出错：某一数字在一行上出现了不止一次——return 0；</p><p> (2)唯一空格可填：这一行上好多空格，某个数字只能填那一个特定的</p><p>③遍历所有列（同②）</p><p>④遍历所有宫（同②）</p><p>⑤从情况少的地方入手（这里的数据备份特重要）</p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;#define ll long longchar b[20][20];int tot;///空的个数int row[20];///第i行可填的数字(二进制状态压缩为一个十进制的int)int b_row[20];///第i行剩余的空位int col[20];int b_col[20];int room[20];int b_room[20];int cnt[65540];int num[65540];/*   1  2  3  4     5  6  7  8     9 10 11 12    13 14 15 16  */int get_room(int x, int y){    return (x - 1) / 4 * 4 + (y - 1) / 4 + 1;}int get_b_room(int x, int y){    int xx = x % 4, yy = y % 4;    if(xx == 0)        xx = 4;    if(yy == 0)        yy = 4;    return 4 * (xx - 1) + yy;}int get_one(int tem){    int ans = 0;    while(tem)    {        if(tem &amp; 1)            ans++;        tem &gt;&gt;= 1;    }    return ans;}///某个数字的存在:///①引起该行、该列、该九宫格不可再填该数字///②该行对应列、该列对应行、该九宫格对应格成为已填格void flip(int x, int y, int z){    ///x行、y列、该九宫格：不能再填第z位代表的字符了 z∈[0, 15]    row[x] ^= (1 &lt;&lt; z);    col[y] ^= (1 &lt;&lt; z);    room[get_room(x, y)] ^= (1 &lt;&lt; z);//    cout &lt;&lt; &quot;Check flip : &quot; &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; &#39; &#39; &lt;&lt; z &lt;&lt; &#39;\n&#39;;//    cout &lt;&lt; get_room(x, y) &lt;&lt; &#39; &#39; &lt;&lt; get_b_room(x, y) &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;    b_row[x] ^= (1 &lt;&lt; (y - 1));///x行的第y列已填好数字    b_col[y] ^= (1 &lt;&lt; (x - 1));///y列的第x行已填好数字    b_room[get_room(x,  y)] ^= (1 &lt;&lt; (get_b_room(x, y) - 1));///该九宫格的对应格已填好数字    ///将[1, 16]转为[0, 15]}//void rev(int i, int ID, int &amp; x, int &amp; y)//{//    int rx = (ID - 1) / 4 + 1;//    int ry = ID - 4 * (rx - 1);//    int xx = (i - 1) / 4 + 1;//    int yy = i - 4 * (xx - 1);//    x = 4 * (xx - 1) + rx;//    y = 4 * (yy - 1) + ry;//}void init(){    tot = 256;    ///这16位是从0位开始用的    ///(1 &lt;&lt; 16) - 1 == 2 ^ 16 - 1 == 1111 1111 1111 1111 (二进制)    ///默认16个数字皆可填(1可填0不可填),16个空位均未填(1待填，0已填)    for(int i = 1; i &lt;= 16; ++i)        b_row[i] = b_col[i] = b_room[i] = row[i] = col[i] = room[i] = (1 &lt;&lt; 16) - 1;    for(int i = 1; i &lt;= 16; ++i)        for(int j = 1; j &lt;= 16; ++j)            if(b[i][j] != &#39;-&#39;)            {                tot--;                flip(i, j, b[i][j] - &#39;A&#39;);///    [0, 15] 代表 [A, P]            }}bool DFS(int tot){    if(tot == 0)        return 1;//    print();    //遍历所有格子：处理空白格    //出现矛盾：及时止损    //唯一可选：及时填上    for(int i = 1; i &lt;= 16; ++i)        for(int j = 1; j &lt;= 16; ++j)            if(b[i][j] == &#39;-&#39;)            {                int val = row[i] &amp; col[j] &amp; room[get_room(i, j)];                if(!val)//空白格没有可填数字                    return 0;                if(get_one(val) == 1)//空白格有唯一可填数字                {                    int tem = num[val &amp; -val];//[0, 15]                    b[i][j] = tem + &#39;A&#39;;                    flip(i, j, tem);                    tot--;                }            }    //遍历所有行：对于每行遍历所有数字    for(int i = 1; i &lt;= 16; ++i)        for(int k = 1; k &lt;= 16; ++k)        {            int k_num = 0, choice = 0, tem_y;            for(int j = 1; j &lt;= 16; ++j)            {                int val = row[i] &amp; col[j] &amp; room[get_room(i, j)];                if(b[i][j] == (k - 1) + &#39;A&#39;)                    k_num++;                if(k_num == 2)//某行出现两次k                    return 0;                if(b[i][j] == &#39;-&#39; &amp;&amp; val &amp; (1 &lt;&lt; (k - 1)))//能填k的空白格                    choice++, tem_y = j;            }            if(k_num == 0 &amp;&amp; choice == 0)//k在这行未出现过，但没有能填k的空白格                return 0;            if(k_num == 0 &amp;&amp; choice == 1)//数字 对 不唯一空白格 的 唯一可选(多个空白格，只能填在那个上)            {                b[i][tem_y] = (k - 1) + &#39;A&#39;;                flip(i, tem_y, k - 1);                tot--;            }        }    for(int j = 1; j &lt;= 16; ++j)        for(int k = 1; k &lt;= 16; ++k)        {            int k_num = 0, choice = 0, tem_x = 0;            for(int i = 1; i &lt;= 16; ++i)            {                int val = row[i] &amp; col[j] &amp; room[get_room(i, j)];                if(b[i][j] == (k - 1) + &#39;A&#39;)                    k_num++;                if(k_num == 2)                    return 0;                if(b[i][j] == &#39;-&#39; &amp;&amp; val &amp; (1 &lt;&lt; (k - 1)))                    choice++, tem_x = i;            }            if(k_num == 0 &amp;&amp; choice == 0)                return 0;            if(k_num == 0 &amp;&amp; choice == 1)            {                b[tem_x][j] = (k - 1) + &#39;A&#39;;                flip(tem_x, j, k - 1);                tot--;            }        }    for(int i = 1; i &lt;= 16; ++i)    {        int x = (i + 3) / 4, y = i - (x - 1) * 4;        for(int k = 1; k &lt;= 16; ++k)        {            int k_num = 0, choice = 0, tem_x, tem_y;            for(int ii = (x - 1) * 4 + 1; ii &lt;= 4 * x; ++ii)                for(int jj = (y - 1) * 4 + 1; jj &lt;= 4 * y; ++jj)                {                    int val = row[ii] &amp; col[jj] &amp; room[get_room(ii, jj)];                    if(b[ii][jj] == (k - 1) + &#39;A&#39;)                        k_num++;                    if(k_num == 2)                        return 0;                    if(b[ii][jj] == &#39;-&#39; &amp;&amp; val &amp; (1 &lt;&lt; (k - 1)))                        choice++, tem_x = ii, tem_y = jj;                }            if(k_num == 0 &amp;&amp; choice == 0)                return 0;            if(k_num == 0 &amp;&amp; choice == 1)            {                b[tem_x][tem_y] = (k - 1) + &#39;A&#39;;                flip(tem_x, tem_y, (k - 1));                tot--;            }        }    }    if(tot == 0)        return 1;    ///(优先处理)优先选择候选数字少的格子填数字更高效    int mmin = INF, x, y;    for(int i = 1; i &lt;= 16; ++i)        for(int j = 1 ; j &lt;= 16; ++j)        {            if(b[i][j] != &#39;-&#39;)                continue;            int val = row[i] &amp; col[j] &amp; room[get_room(i, j)];            if(val == 0)///当前格子可填数字的个数为0                return 0;            if(cnt[val] &lt; mmin)            {                x = i, y = j;///这个格子可填数字的个数最少                mmin = cnt[val];///可填数字的个数            }        }    int t_b[20][20], t_row[20], t_col[20], t_room[20];    memcpy(t_b, b, sizeof(b));    memcpy(t_row, row, sizeof(row));    memcpy(t_col, col, sizeof(col));    memcpy(t_room, room, sizeof(room));    int t_tot = tot;    int val = row[x] &amp; col[y] &amp; room[get_room(x, y)];    for(; val; val -= (val &amp; -val))///之前那种方法不太行了....    {        int tem = num[val &amp; -val];        b[x][y] = tem + &#39;A&#39;;        flip(x, y, tem);        if(DFS(tot - 1))            return 1;        else///原来这儿有猫腻儿        {            memcpy(b, t_b, sizeof(t_b));            memcpy(row, t_row, sizeof(t_row));            memcpy(col, t_col, sizeof(t_col));            memcpy(room, t_room, sizeof(t_room));            tot = t_tot;        }    }    return 0;}/// (i &amp; -i) == 2 ^ p   (p为i的最低位1所在位)int main(){    ///十进制数字i转为二进制时含数字1的个数(对应可填数字个数)    for(int i = 0; i &lt; (1 &lt;&lt; 16); ++i)        for(int j = i; j; j &gt;&gt;= 1)            if(j &amp; 1)                cnt[i]++;    for(int i = 0; i &lt;= 16; ++i)///打表2的整数幂        num[1 &lt;&lt; i] = i;    while(~scanf(&quot;%s&quot;, b[1] + 1))    {        for(int i = 2; i &lt;= 16; ++i)            scanf(&quot;%s&quot;, b[i] + 1);        init();        DFS(tot);        for(int i = 1; i &lt;= 16; ++i)        {            for(int j = 1; j &lt;= 16; ++j)                cout &lt;&lt; b[i][j];            cout &lt;&lt; &#39;\n&#39;;        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-Other-‘s"><a href="#Code-Other-‘s" class="headerlink" title="Code(Other ‘s)"></a>Code(Other ‘s)</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define LL long long#define mem(a, b) memset(a, b, sizeof(a))//headconst int N = 17;int mp[N][N];///字符[A,P]转数字[1,16]int st[N][N];///禁用标记int sum = 0;///已填char s[N][N+5];///原图void add(int x, int y, int t){    mp[x][y] = t;    sum++;    for (int i = 1; i &lt;= 16; i++)    {        ///t - 1 : 依然是从0开始        /// 或 | 1 强，多次| 本1还是1：表示该位置不可放t了        st[i][y] |= 1&lt;&lt;t-1;///同列不可放t        st[x][i] |= 1&lt;&lt;t-1;///同行不可放t    }    int xx = (x+3)/4, yy = (y+3)/4;    for (int i = (xx-1)*4 + 1; i &lt;= xx*4; i++)        for (int j = (yy-1)*4 + 1; j &lt;= yy*4; j++)            st[i][j] |= 1&lt;&lt;t-1;///同16宫格不可放t}void print(){    for (int i = 1; i &lt;= 16; i++)    {        for (int j = 1; j &lt;= 16; j++)            putchar(mp[i][j]-1+&#39;A&#39;);        puts(&quot;&quot;);    }    puts(&quot;&quot;);}///两种剪枝：///①格子有唯一可填的数字///②数字有唯一可填的格子///②有时候一个空白格看起来有好多数字可填(其所在行列宫并不满)，但某个数字(比如1)以外的数字(2~16)分别出现在了他所在的行列宫，那这一个格只能填该数字bool dfs(){    if(sum == 256)    {        print();        return true;    }    cout &lt;&lt; &quot;Check tot : &quot; &lt;&lt; 256 - sum &lt;&lt; &quot;---------------&quot; &lt;&lt; &#39;\n&#39;;    ///遍历每个格子:检测所有的&quot;未填空格&quot;    ///有矛盾：及时返回    ///只能填一个数字：及时填上    print();    for (int i = 1; i &lt;= 16; i++)        for (int j = 1; j &lt;= 16; j++)            if(!mp[i][j])            {                int cnt = 0, t = 0;                for (int k = 1; k &lt;= 16; k++)                    if((st[i][j] &amp; (1&lt;&lt;k-1)) == 0)///与&amp; 0强,可行方案: k -&gt; st[i][j]                    {                        cnt++;                        t = k;                        if(cnt == 2)                            break;                    }                ///①未填空格出错：虽是空格，无可填数字                if(!cnt)///当前格子虽然是空的，但是不能填数字了!(很明显没有兼顾行、列、16格)例如：这一格所在行其他数字都填了只剩4，但这一格所在16宫格有4了                    return false;                if(cnt == 1)///唯一可填(是由st[i][j]决定的，而st数组本身就是综合了行列宫，所以此处填上此数字是&quot;当前方案性&quot;正确的)                {                    add(i, j, t);                    cout &lt;&lt; &quot;ADD 1 : ------------------\n&quot;;                    cout &lt;&lt; &quot;add : &quot; &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; t &lt;&lt; &#39;\n&#39;;//                    print();                }                ///真就填上了???!!!这层DFS尝试方案有误怎么办?全局的mp数组不能恢复到原样啊!!            }    ///遍历每一行(这一行有好多空白格，但某个数字只有一个可填格子)    for (int i = 1; i &lt;= 16; i++)        for (int k = 1; k &lt;= 16; k++)///遍历16个数字        {            int cnt1 = 0, cnt2 = 0, y;            for (int j = 1; j &lt;= 16; j++)///某一行上对应的16个格子            {                if(mp[i][j] == k)                    cnt1++;                ///②已填数字出错：某行出现同一个数字两次(没有兼顾行列宫)例如：某格子根据所在列性质填了数字4，同行的一个格子根据他的所在列性质也填了数字4                if(cnt1 == 2)                    return false;                if(!mp[i][j] &amp;&amp; (st[i][j] &amp; (1&lt;&lt;k-1)) == 0)///找到了空白格的可填数字k                    cnt2++, y = j;            }            if(!cnt1 &amp;&amp; !cnt2)///数字k在这一行没有出现过 同时 (没有空白格 或 空白格无可填数字)                return false;            if(!cnt1 &amp;&amp; cnt2 == 1)///数字k在这一行没有出现过 同时 (此行唯一空白格mp[i][y]有唯一可填数字k)            {                add(i, y, k);///唯一可填（只考虑本行决定的,也&quot;是当前方案性&quot;正确）                cout &lt;&lt; &quot;ADD 2 : ------------------\n&quot;;                cout &lt;&lt; &quot;add : &quot; &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; y &lt;&lt; &#39; &#39; &lt;&lt; k &lt;&lt; &#39;\n&#39;;//                print();            }        }    ///遍历每一列    for (int j = 1; j &lt;= 16; j++)        for (int k = 1; k &lt;= 16; k++)        {            int cnt1 = 0, cnt2 = 0, x;            for (int i = 1; i &lt;= 16; i++)            {                if(mp[i][j] == k)                    cnt1++;                if(cnt1 == 2)                    return false;                if(!mp[i][j] &amp;&amp; (st[i][j] &amp; (1&lt;&lt;k-1)) == 0)                    cnt2++, x = i;            }            if(!cnt1 &amp;&amp; !cnt2)                return false;            if(!cnt1 &amp;&amp; cnt2 == 1)            {                add(x, j, k);                cout &lt;&lt; &quot;ADD 3 : --------------------- \n&quot;;                cout &lt;&lt; &quot;add : &quot; &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; k &lt;&lt; &#39;\n&#39;;//                print();            }        }    ///遍历每一个16宫格    for (int i = 1; i &lt;= 16; i++)    {        int x = (i+3)/4, y = i - (x-1)*4;        for (int k = 1; k &lt;= 16; k++)        {            int cnt1 = 0, cnt2 = 0, xx, yy;            for (int ii = (x-1)*4+1; ii &lt;= x*4; ii++)                for (int jj = (y-1)*4+1; jj &lt;= y*4; jj++)                {                    if(mp[ii][jj] == k)                        cnt1++;                    if(cnt1 == 2)                        return false;                    if(!mp[ii][jj] &amp;&amp; (st[ii][jj] &amp; (1&lt;&lt;k-1)) == 0)                        cnt2++, xx = ii, yy = jj;                }            if(!cnt1 &amp;&amp; !cnt2)                return false;            if(!cnt1 &amp;&amp; cnt2 == 1)            {                add(xx, yy, k);                cout &lt;&lt; &quot;ADD 4 : ------------------\n&quot;;                cout &lt;&lt; &quot;add : &quot; &lt;&lt; xx &lt;&lt; &#39; &#39; &lt;&lt; yy &lt;&lt; &#39; &#39; &lt;&lt; k &lt;&lt; &#39;\n&#39;;//                print();            }        }    }    if(sum == 256)    {        print();        return true;    }    ///选择可填数字最少的空白格尝试填数    ///①找到格子    int mn = N, x, y;    for (int i = 1; i &lt;= 16; i++)        for (int j = 1; j &lt;= 16; j++)            if(!mp[i][j])///空白格            {                int cnt = 0;                for (int k = 1; k &lt;= 16; k++)                    if((st[i][j] &amp; (1&lt;&lt;k-1)) == 0)                    {                        cnt++;///该空白格可填数字数目                        if(cnt &gt;= mn)                            break;                    }                if(cnt &lt; mn)                {                    mn = cnt;                    x = i;                    y = j;                }            }    int tst[N][N], tmp[N][N];    memcpy(tst, st, sizeof(st));    memcpy(tmp, mp, sizeof(mp));    int tsum = sum;    ///②尝试填数    for (int k = 1; k &lt;= 16; k++)        if((st[x][y] &amp; (1&lt;&lt;k-1)) == 0)        {            add(x, y, k);///之前的唯一性add都是&quot;当前方案&quot;正确的，这里是尝试性add，可能是错的，便用到了上面的&quot;出错剪枝&quot;            bool f = dfs();///唯一的递归口（上面的都执行完了才尝试性递归）            if(!f)            {                ///数据还原                cout &lt;&lt; &quot;---------------Change---------------\n&quot;;                memcpy(st, tst, sizeof(tst));                memcpy(mp, tmp, sizeof(tmp));                sum = tsum;            }            else                return true;        }    return false;}int main(){    while(scanf(&quot;%s&quot;, s[1]+1) != EOF)    {        for (int i = 2; i &lt;= 16; i++)            scanf(&quot;%s&quot;, s[i]+1);        sum = 0;        mem(mp, 0);        mem(st, 0);        for (int i = 1; i &lt;= 16; i++)            for (int j = 1; j &lt;= 16; j++)                if(isalpha(s[i][j]))                    add(i, j, s[i][j] - &#39;A&#39; + 1);        dfs();    }    return 0;}/*--A----C-----O-I-J--A-B-P-CGF-H---D--F-I-E----P--G-EL-H----M-J------E----C--G----I--K-GA-B---E-JD-GP--J-F----A---E---C-B--DP--O-E--F-M--D--L-K-A-C--------O-I-L-H-P-C--F-A--B------G-OD---J----HK---J----H-A-P-L--B--P--E--K--A--H--B--K--FI-C----F---C--D--H-N-*/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 简单搜索の剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2586 How far away(LCA)</title>
      <link href="2019/11/08/HDU-2586-How-far-away-LCA/"/>
      <url>2019/11/08/HDU-2586-How-far-away-LCA/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点，n - 1条边连起来(构成了一棵树)，无更新操作，查询任意两点间距离</p></blockquote><a id="more"></a><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p><a href="https://blog.csdn.net/nameofcsdn/article/details/52230548" target="_blank" rel="noopener">https://blog.csdn.net/nameofcsdn/article/details/52230548</a></p></blockquote><h3 id="Code（RMQ-ST离线做法）"><a href="#Code（RMQ-ST离线做法）" class="headerlink" title="Code（RMQ~ST离线做法）"></a>Code（RMQ~ST离线做法）</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 41000;int n, m;int tot;//遍历数int dis[N];//距离根节点1的距离struct node{    int v, w, pre;} a[N * 2];int head[N * 2], cnt = 1;void add_edge(int u, int v, int w){    a[cnt].v = v;    a[cnt].w = w;    a[cnt].pre = head[u];    head[u] = cnt++;}bool vis[N];int first[N];//该点首次出现所对应的的遍历数totint point[N * 4];//遍历数tot所对应的那个点的标号int depth[N * 4];//遍历数tot所对应的那个点的深度void DFS(int u, int dep){    vis[u] = 1;    point[++tot] = u, first[u] = tot, depth[tot] = dep;    for(int i = head[u]; ~i; i = a[i].pre)    {        int v = a[i].v, w = a[i].w;        if(!vis[v])        {            dis[v] = dis[u] + w;            DFS(v, dep + 1);            //退回到这一点也是一次访问            point[++tot] = u, depth[tot] = dep;        }    }}int sma[N][20];//存的是某个区间里最小的遍历数totvoid ST(){    for(int i = 1; i &lt;= n; ++i)        sma[i][0] = depth[i];    for(int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)        for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)            sma[i][j] = min(sma[i][j - 1], sma[i + (1 &lt;&lt; (j - 1))][j - 1]);}int RMQ(int l, int r){    int k = 0;    while( (1 &lt;&lt; (k + 1)) &lt;= r - l + 1 )        ++k;    return min(sma[l][k], sma[r - (1 &lt;&lt; k) + 1][k]);}int LCA(int u, int v){    int x = first[u];    int y = first[v];    if(x &gt; y)        swap(x, y);    int res = RMQ(x, y);    return point[res];}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        cnt = 1;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int u, v, w;        memset(head, -1, sizeof(head));        for(int i = 0; i &lt; n - 1; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add_edge(u, v, w);            add_edge(v, u, w);        }        tot = 0, dis[1] = 0;        memset(vis, 0, sizeof(vis));        DFS(1, 1);        ST();        while(m--)        {            int u, v;            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            int lca = LCA(u, v);            cout &lt;&lt; dis[u] + dis[v] - 2 * dis[lca] &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><blockquote><blockquote><p>Trajan+并查集(在线做法)</p></blockquote></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 41000;const int M = 810;int n, m;bool vis[N];int ance[N];//准lcaint pre[N], dis[N];struct edge{    int v, w, pre;} a[N * 2];int head[N * 2], cnt;void add_adge(int u, int v, int w){    a[cnt].v = v;    a[cnt].w = w;    a[cnt].pre = head[u];    head[u] = cnt++;}struct query{    int u, v, lca, pre;} q[N];int qhead[N * 2], qcnt;void add_query(int u, int v){    q[qcnt].u = u;    q[qcnt].v = v;    q[qcnt].lca = -1;    q[qcnt].pre = qhead[u];    qhead[u] = qcnt++;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[y] = x;}void Tarjan(int u){    vis[u] = 1;    ance[u] = pre[u] = u;    for(int i = head[u]; ~i; i = a[i].pre)    {        int v = a[i].v;        int w = a[i].w;        if(!vis[v])        {            dis[v] = dis[u] + w;            Tarjan(v);            unite(u, v);//Tarjan完了再unite，保证了LCA是准确的        }    }    for(int i = qhead[u]; ~i; i = q[i].pre)    {        int v = q[i].v;        if(vis[v])//v是已经遍历过的非叶子节点            q[i].lca = q[i ^ 1].lca = ance[found(v)];    }}void init(){    cnt = qcnt = 0;//从零开始，小偶大奇，异或1    memset(vis, 0, sizeof(vis));    memset(dis, 0, sizeof(dis));    memset(head, -1, sizeof(head));    memset(qhead, -1, sizeof(qhead));}int main(){    int _;    scanf(&quot;%d&quot;, &amp;_);    while(_--)    {        init();        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int u, v, w;        for(int i = 0; i &lt; n - 1; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add_adge(u, v, w);            add_adge(v, u, w);        }        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            add_query(u, v);            add_query(v, u);        }        dis[1] = 0;        Tarjan(1);        for(int i = 0; i &lt; m; ++i)//0 1/2 3/4 5/...取前者        {            int u = q[i * 2].u;            int v = q[i * 2].v;            int lca = q[i * 2].lca;            cout &lt;&lt; dis[u] + dis[v] - 2 * dis[lca] &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><blockquote><p>在建树的时候就把LCA求出来</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图のLCA </tag>
            
            <tag> DPのST算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3683 Paiest John&#39;s Busiest Day(2-sat:Tarjan+Topo)</title>
      <link href="2019/11/05/POJ-3683-Paiest-John-s-Busiest-Day-2-sat-Tarjan-Topo/"/>
      <url>2019/11/05/POJ-3683-Paiest-John-s-Busiest-Day-2-sat-Tarjan-Topo/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有一个小镇上只有一个牧师。这个小镇上有一个传说，在九月一日结婚的人会受到爱神的保佑，但是要牧师举办一个仪式。这个仪式要么在婚礼刚刚开始的时候举行，要么举行完婚礼正好结束。<br>现在已知有n场婚礼，告诉你每一场的开始和结束时间，以及举行仪式所需要的时间。问牧师能否参加所有的婚礼，如果能则输出一种方案.</p></blockquote><a id="more"></a><h3 id="2-sat"><a href="#2-sat" class="headerlink" title="2-sat"></a>2-sat</h3><blockquote><p>①输入+初始化 input() + initial()</p><p>②添边 add_edge()</p><p>③缩点 Tarjan()</p><p>④判可行否 judge()</p><p>⑤若可行，记下超点的对立点</p><p>⑥反向建边拓扑染色：</p><p>遍历所有的点</p><p>对于每个点:</p><p>若与他相连接的点跟它本身不处于同一个强连通分量中</p><p>将两个强连通分量(即两个超点)反向建边</p><p>进行BFS拓扑染色</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10005;struct time{    int start, over;} tm[N];stack&lt;int&gt; st;vector&lt;int&gt; v[N];///Trajan用vector&lt;int&gt; e[N];///Topo用///弄明白t跟num!int n, m, t, num;///num:强连通分量(连通块)的个数,缩点后点的个数bool vis[N];///该点是否访问过int inst[N];///该点是否在栈中int time[N];///i点第一次被访问的时间int low[N];///i点所在强连通分量子图中第一个被搜到的点的time值int ltt[N];///i点属于第几个强连通分量(0表示不属于任何一个)int OPP[N];///超点的对立点int in[N];int color[N];///拓扑染色,下标是超点!void Tarjan(int x)///搜索x点及其子树{    int temp;    st.push(x);    inst[x] = vis[x] = 1;    low[x] = time[x] = ++t;    for(int i = 0; i &lt; v[x].size(); i++)    {        temp = v[x][i];        if(vis[temp] == 0)        {            Tarjan(temp);            low[x] = min(low[x], low[temp]);        }        else if(inst[temp] == 1)///成环时            low[x] = min(low[x], time[temp]);        else///点temp访问过却不在当前栈里：属于已发现的强连通分量            continue;///这两个不能合二为一的原因：只有从此指彼的单向路    }    if(low[x] == time[x])    {        num++;///找到第num个强连通分量        while(!st.empty())        {            temp = st.top();            st.pop();            ltt[temp] = num;///temp结点属于第num个强连通分量            inst[temp] = 0;            if(temp == x)                break;        }    }}bool Error(int a, int b){    if(tm[a].start &gt;= tm[b].over || tm[b].start &gt;= tm[a].over)        return 0;    return 1;}void Topo(){    memset(in, 0, sizeof(in));    memset(color, -1, sizeof(color));    ///遍历所有的点    ///对于每个点:    ///若与他相连接的点跟它本身不处于同一个强连通分量中    ///将两个强连通分量(即两个超点)反向建边    ///进行BFS拓扑染色    for(int i = 1; i &lt;= 2 * n; ++i)        for(int j = 0; j &lt; v[i].size(); ++j)///多个vector注意区分清楚        {            int tem = v[i][j];            if(ltt[i] == ltt[tem])                continue;            e[ ltt[tem] ].push_back(ltt[i]);            in[ ltt[i] ]++;        }    queue&lt;int&gt; q;    for(int i = 1; i &lt;= num; ++i)        if(!in[i])            q.push(i);    while(!q.empty())    {        int tem = q.front();        q.pop();        if(color[tem] == -1)        {            color[tem] = 1;            color[ OPP[tem] ] = 0;        }        for(int i = 0; i &lt; e[tem].size(); ++i)        {            in[ e[tem][i] ]--;            if(in[ e[tem][i] ] == 0)                q.push(e[tem][i]);        }    }}void init()///只一组数据无需init(){    t = num = 0;    memset(vis, 0, sizeof(vis));    memset(inst, 0, sizeof(inst));    memset(time, 0, sizeof(time));    memset(low, 0, sizeof(low));    memset(ltt, 0, sizeof(ltt));    memset(color, -1, sizeof(color));}///强连通分量内元素个数最少为1(该元素本身)///这意味着每个元素都有从属的强连通分量int main(){    scanf(&quot;%d&quot;, &amp;n);    ///①init();    ///②input();    int ssh, ssm, eeh, eem, len;    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%d:%d %d:%d %d&quot;, &amp;ssh, &amp;ssm, &amp;eeh, &amp;eem, &amp;len);        tm[i].start = ssh * 60 + ssm;        tm[i].over = tm[i].start + len;        tm[i + n].over = eeh * 60 + eem;        tm[i + n].start = tm[i + n].over - len;    }    ///③add_edge();    ///注意此题跟 POJ 3207 的不同    ///那题一冲突都冲突，这题不一样    int addnum = 0;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)///跟之前那题不一样,必须这么写!!!        {            if(i == j)                continue;            if(Error(i, j))                v[i].push_back(j + n);            if(Error(i, j + n))                v[i].push_back(j);            if(Error(i + n, j))                v[i + n].push_back(j + n);            if(Error(i + n, j + n))                v[i + n].push_back(j);        }    ///④Tarjan();    for(int i = 1; i &lt;= 2 * n; ++i)        if(!vis[i])            Tarjan(i);    ///⑤judge();    for(int i = 1; i &lt;= n; ++i)    {        if(ltt[i] == ltt[i + n])        {            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;            return 0;        }        OPP[ ltt[i] ] = ltt[i + n];///之前傻地写成OPP[ ltt[i] ] = OPP[ ltt[i + n] ];        OPP[ ltt[i + n] ] = ltt[i];    }    cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;    ///⑥Topo();    Topo();    for(int i = 1; i &lt;= n; ++i)    {        if(color[ ltt[i] ])///color 里下标是超点            printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, tm[i].start / 60, tm[i].start % 60, tm[i].over / 60, tm[i].over % 60);        else            printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, tm[i+n].start / 60, tm[i+n].start % 60, tm[i+n].over / 60, tm[i+n].over % 60);    }    return 0;}</code></pre><h1 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h1><pre><code class="lang-c++">#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_V = 10005;int n;vector&lt;int&gt; vs;vector&lt;int&gt; G[MAX_V];vector&lt;int&gt; rG[MAX_V];vector&lt;int&gt; nv[MAX_V];struct time{    int start, over;} tm[MAX_V];bool used[MAX_V];int cmp[MAX_V];void add_eage(int from, int to){    G[from].push_back(to);    rG[to].push_back(from);}void DFS(int v){    used[v] = 1;    for(int i = 0; i &lt; G[v].size(); ++i)        if(!used[ G[v][i] ])            DFS(G[v][i]);        vs.push_back(v);}void rDFS(int v, int k){    used[v] = 1;    cmp[v] = k;    for(int i = 0; i &lt; rG[v].size(); ++i)        if(!used[ rG[v][i] ])            rDFS(rG[v][i], k);}int scc(){    memset(used, 0, sizeof(used));    vs.clear();    for(int v = 1; v &lt;= n; ++v)        if(!used[v])            DFS(v);    memset(used, 0, sizeof(used));    int k = 0;    for(int i = vs.size() - 1; i &gt;= 0; --i)        if(!used[vs[i]])            rDFS(vs[i], ++k);    return k;}bool Error(int a, int b){    if(tm[a].start &gt;= tm[b].over || tm[b].start &gt;= tm[a].over)        return 0;    return 1;}int main(){    scanf(&quot;%d&quot;, &amp;n);    int ssh, ssm, eeh, eem, len;    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%d:%d %d:%d %d&quot;, &amp;ssh, &amp;ssm, &amp;eeh, &amp;eem, &amp;len);        tm[i].start = ssh * 60 + ssm;        tm[i].over = tm[i].start + len;        tm[i + n].over = eeh * 60 + eem;        tm[i + n].start = tm[i + n].over - len;    }    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)///跟之前那题不一样,必须这么写!!!        {            if(i == j)                continue;            if(Error(i, j))                add_eage(i, j + n);            if(Error(i, j + n))                add_eage(i, j);            if(Error(i + n, j))                add_eage(i + n, j + n);            if(Error(i + n, j + n))                add_eage(i + n, j);        }    int num = scc();    for(int i = 1; i &lt;= n; i++)        if(cmp[i] == cmp[i + n])        {            puts(&quot;NO&quot;);            return 0;        }    puts(&quot;YES&quot;);    for(int i = 1; i &lt;= n; i++)    {        if(cmp[i] &gt; cmp[i + n]) // 在仪式开始时举行            printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, tm[i].start / 60, tm[i].start % 60, tm[i].over / 60, tm[i].over % 60);        else            printf(&quot;%.2d:%.2d %.2d:%.2d\n&quot;, tm[i+n].start / 60, tm[i+n].start % 60, tm[i+n].over / 60, tm[i+n].over % 60);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の2-sat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3207 Ikki&#39;s Story IV(2-sat)</title>
      <link href="2019/11/04/POJ-3207-Ikki-s-Story-IV-2-sat/"/>
      <url>2019/11/04/POJ-3207-Ikki-s-Story-IV-2-sat/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个点按顺序排列在一个圆环上，要连接M条边，可从圈内连，可从圈外连，问能否实现各边不相交</p></blockquote><a id="more"></a><h3 id="2-sat"><a href="#2-sat" class="headerlink" title="2-sat"></a>2-sat</h3><blockquote><p>什么是2-SAT呢？就是</p><p>①有一些集合，(对应此题中有一些边)</p><p>②每个集合中有且仅有两个元素，(某条边是从圈内连or从圈外连)</p><p>③两个元素必须且只能选一个，(从圈内连或者从圈外连，二选一)</p><p>④集合间的元素存在一定的选择关系，(边不能相交)</p><p>求解可行性及可行方案。</p></blockquote><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><blockquote><p>1、连边</p><p>2、跑Tarjan</p><p>3、判<strong>可行性</strong>，即同一集合中的两个点是否同属一个强连通块</p><p>(若不求可行方案，到此步即可)</p><p>4、缩点建新图，连反边</p><p>5、拓扑序，若当前点没有被访问过，则选择该点，不选择其另外的点</p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>对于此题，连线对应区间如果相交，那么两线不能同时在圈内或同时在圈外</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; v[2005];int n, m, t, num;///num:强连通分量(连通块)的个数,缩点后点的个数bool vis[2105];///该点是否访问过int inst[2105];///该点是否在栈中int time[2105];///i点第一次被访问的时间int low[2105];///i点所在强连通分量子图中第一个被搜到的点的time值int ltt[2105];///i点属于第几个强连通分量(0表示不属于任何一个)int l[2005], r[2005];void init()///只一组数据无需init(){    t = num = 0;    memset(vis, 0, sizeof(vis));    memset(inst, 0, sizeof(inst));    memset(time, 0, sizeof(time));    memset(low, 0, sizeof(low));    memset(ltt, 0, sizeof(ltt));}void Trajan(int x)///搜索x点及其子树{    int temp;    st.push(x);    inst[x] = vis[x] = 1;    low[x] = time[x] = ++t;    for(int i = 0; i &lt; v[x].size(); i++)    {        temp = v[x][i];        if(vis[temp] == 0)        {            Trajan(temp);            low[x] = min(low[x], low[temp]);        }        else if(inst[temp] == 1)///成环时            low[x] = min(low[x], time[temp]);        else///点temp访问过却不在当前栈里：属于已发现的强连通分量            continue;///这两个不能合二为一的原因：只有从此指彼的单向路    }    if(low[x] == time[x])    {        num++;///找到第num个强连通分量        while(!st.empty())        {            temp = st.top();            st.pop();            ltt[temp] = num;///temp结点属于第num个强连通分量            inst[temp] = 0;            if(temp == x)                break;        }    }}///强连通分量内元素个数最少为1(该元素本身)///这意味着每个元素都有从属的强连通分量int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);        l[i]++, r[i]++;///初始化涉及0,尽量避开使用下标0        if(l[i] &gt; r[i])            swap(l[i], r[i]);    }    ///i j 是两条冲突线，不能同时连    for(int i = 0; i &lt; m; ++i)        for(int j = i + 1; j &lt; m; ++j)            if((l[i] &lt;= l[j] &amp;&amp; r[i] &gt;= l[j] &amp;&amp; r[i] &lt;= r[j])                    || (l[j] &lt;= l[i] &amp;&amp; r[j] &gt;= l[i] &amp;&amp; r[j] &lt;= r[i]))            {                ///① i  and  j&#39;                v[i].push_back(j + m);///i内j外                v[j + m].push_back(i);///j外i内                ///② i&#39;  and  j                v[i + m].push_back(j);///i外j内                v[j].push_back(i + m);///j内i外            }    n = 2 * m;    ///对所有点遍历，若未被访问过，就进行一遍Trajan    for(int i = 1; i &lt;= n; ++i)        if(!vis[i])            Trajan(i);    bool flag = 1;    for(int i = 1; i &lt;= m; ++i)        if(ltt[i] == ltt[i + m])        {            flag = 0;            break;        }    if(flag)        cout &lt;&lt; &quot;panda is telling the truth...\n&quot;;    else        cout &lt;&lt; &quot;the evil panda is lying again\n&quot;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の2-sat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1703 Find them, Catch them（并查集变形）</title>
      <link href="2019/11/02/POJ-1703-Find-them-Catch-them%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%98%E5%BD%A2%EF%BC%89/"/>
      <url>2019/11/02/POJ-1703-Find-them-Catch-them%EF%BC%88%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%8F%98%E5%BD%A2%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有两个帮派，</p><p>给出 D a b 表示a和b位于不同帮派，</p><p>给出 A a b 表示询问a和b是否属于同一帮派</p></blockquote><a id="more"></a><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote><p>初始化一个 2 * N 的并查集，</p><p>如果a和b属于不同帮派，</p><p>unite(a, b + n) &amp;&amp; unite(b, a + n)</p><p>这样如果c和b属于不同帮派</p><p>unite(c, b + n) &amp;&amp; unite(b, c + n)</p><p>就把a和c连起来了</p><p>!!!什么神仙做法！！！</p><p><del>是不是暗示我们，有些题多用点空间就能解决问题</del></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int n, m;int pre[N * 2];void init(){    for(int i = 0; i &lt;= n * 2; ++i)        pre[i] = i;}int found(int x){    if(pre[x] != x)        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[x] = y;    return ;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        char ch;        int a, b;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        getchar();        init();        while(m--)        {            ch = getchar();            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            getchar();            if(ch == &#39;D&#39;)            {                unite(a, b + n);                unite(b, a + n);            }            else            {                int x = found(a);//                int xx = found(a + n);                int y = found(b);                int yy = found(b + n);                if(x == y)                    cout &lt;&lt; &quot;In the same gang.\n&quot;;                else if(x == yy)                    cout &lt;&lt; &quot;In different gangs.\n&quot;;                else                    cout &lt;&lt; &quot;Not sure yet.\n&quot;;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2010 Moo University Financial Aid(贪心+优先队列)</title>
      <link href="2019/11/02/POJ-2010-Moo-University-Financial-Aid-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>2019/11/02/POJ-2010-Moo-University-Financial-Aid-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>学校要选出N个人发放助学金，</p><p>但有C个人申请（给出C个人的成绩和各自的申请金额），</p><p>而且学校只能发放不超过F的金钱，</p><p>找出一种策略，使得被发放助学金的学生的群体，</p><p>他们的成绩的中位数最大</p></blockquote><a id="more"></a><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><blockquote><p>按成绩排序作为基本顺序</p><p>处理上部：</p><p>选取后 N/2 个学生，将每个申请金额置于一个优先级队列中(由大到小)，并记下总和</p><p>从第 C - N / 2 - 1 个位置当做中位数依次往下测试(保证了选取最大的)</p><p>处理下部：</p><p>在基本顺序的基础上将下部分(要测试的位置以下)按申请金额由小到大排序</p><p>取前 N / 2 个的金额总和，记下最后一个位置(即 int last_pos = N / 2 - 1)</p><p>检测：</p><p>上部金额 + 下部金额 + 当前检测位置金额 &lt;= F 即退出</p><p>否则：</p><p>①将当前检测位置 idx 并入上部</p><p>②让其前一位置 idx - 1 脱离下部</p><p>在对idx - 1这个位置检测</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int score, money;};node stu_s[100005];///整体按成绩排序node stu_m[100005];///下部分按钱排序bool cmp_score(node a, node b){    if(a.score != b.score)        return a.score &lt; b.score;    else        return a.money &lt; b.money;}bool cmp_money(node a, node b){    return a.money &lt; b.money;}int main(){    int N, C, F;    scanf(&quot;%d%d%d&quot;, &amp;N, &amp;C, &amp;F);    for(int i = 0; i &lt; C; ++i)    {        scanf(&quot;%d%d&quot;, &amp;stu_s[i].score, &amp;stu_s[i].money);        stu_m[i].score = stu_s[i].score;        stu_m[i].money = stu_s[i].money;    }    sort(stu_s, stu_s + C, cmp_score);    long long up_money = 0;    priority_queue&lt;int&gt; up_half_money;    for(int i = C - 1, cnt = 0; cnt &lt; (N &gt;&gt; 1); --i, ++cnt)    {        up_half_money.push(stu_s[i].money);        up_money += stu_s[i].money;    }    for(int i = 0; i &lt; C; ++i)    {        stu_m[i].score = stu_s[i].score;        stu_m[i].money = stu_s[i].money;    }    sort(stu_m, stu_m + C - N / 2 - 1, cmp_money);    long long down_money = 0;    int last_score = stu_m[ (N &gt;&gt; 1) - 1 ].score, pos = N / 2 - 1;    for(int i = 0; i &lt; (N &gt;&gt; 1); ++i)        down_money += stu_m[i].money;    int idx = C - 1 - N / 2;    while(idx &gt;= 0)    {        if(up_money + down_money + stu_s[idx].money &lt;= F)            break;        ///中位数并入上部        if(stu_s[idx].money &lt; up_half_money.top())        {            up_money -= up_half_money.top();            up_half_money.pop();            up_half_money.push(stu_s[idx].money);            up_money += stu_s[idx].money;        }        else            up_half_money.push(stu_s[idx].money);        ///中位数下一个数脱离下部        if(stu_s[idx - 1].score &lt; last_score)        {            down_money -= stu_s[idx - 1].money;            down_money += stu_m[++pos].money;        }        else;        idx --;    }    if(idx &lt; 0)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    else        cout &lt;&lt; stu_s[idx].score &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3614 Sunscreen(贪心+优先队列)</title>
      <link href="2019/11/02/POJ-3614-Sunscreen-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>2019/11/02/POJ-3614-Sunscreen-%E8%B4%AA%E5%BF%83-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>C头牛，L瓶防晒霜，</p><p>C行，每行代表每头牛既能日光浴又不会被晒伤时的spf取值范围</p><p>L行，每行代表每瓶防晒霜能使牛的spf值变成多少，以及每瓶能涂抹几头牛</p><p>求最多有几头牛可以既能晒日光浴又能不被晒伤</p></blockquote><a id="more"></a><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><blockquote><p>对牛和防晒霜从小到大排序</p><p>对于每瓶防晒霜来说，它有一个spf值，</p><p>找出所有下界小于spf的牛，放在一起</p><p>在这里面，上界也小于spf的牛可以直接扔掉(没救了)</p><p>上界大于spf即满足条件，此时防晒霜应优先给上界小的牛用</p><p>因为上界大的牛有更大的获得后续防晒霜的可能性</p><p>这里适合使用优先队列，从满足条件的牛中选出上界最小的</p><p>如果当前防晒霜用完了队列里还有牛，没关系，继续用下一瓶</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int l, r;}a[3000];bool cmp(node a, node b){    if(a.l != b.l)        return a.l &lt; b.l;    return a.r &lt; b.r;}struct spf{    int val, num;    bool operator &lt;(const spf &amp; a)const    {        return val &lt; a.val;    }}b[3000];int main(){    int C, L;    scanf(&quot;%d%d&quot;, &amp;C, &amp;L);    for(int i = 0; i &lt; C; ++i)        scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r);    sort(a, a + C, cmp);    for(int i = 0; i &lt; L; ++i)        scanf(&quot;%d%d&quot;, &amp;b[i].val, &amp;b[i].num);    sort(b, b + L);    int ans = 0;    int idx = 0;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;    for(int i = 0; i &lt; L; ++i)    {        while(idx &lt; C &amp;&amp; b[i].val &gt;= a[idx].l)        {            q.push(a[idx].r);            idx++;        }        while(!q.empty() &amp;&amp; b[i].num)        {            if(q.top() &lt; b[i].val)            {                q.pop();                continue;            }            ans++;            b[i].num--;            q.pop();        }    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rand()与srand()生成随机数</title>
      <link href="2019/11/01/rand-%E4%B8%8Esrand-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>2019/11/01/rand-%E4%B8%8Esrand-%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>C / C++ 如何生成随机数？</p></blockquote><a id="more"></a><h3 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h3><blockquote><p>rand()函数是以一个数字(我们称之为”种子”seed)为基准，以某个递推公式推算出来的<strong>一系列</strong>数</p><p>我们假设这个公式为 <em>f ( seed )  =  [a, b, c …]</em> </p></blockquote><h3 id="试用rand"><a href="#试用rand" class="headerlink" title="试用rand()"></a>试用rand()</h3><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;int main(){    int a;    for(int i = 0; i &lt; 10; ++i)    {        a = rand();        cout &lt;&lt; a &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><p><img src="https://i.postimg.cc/3RKQDMY0/T20-K7-A4-IUFQ1-B8-1-G9-NUR.png" alt="result"></p><h3 id="出现问题"><a href="#出现问题" class="headerlink" title="出现问题"></a>出现问题</h3><blockquote><p>我们多次编译，输出前十个数字发现都是一样的，就是41,18467,6334…</p><p>原因：我们不给rand()函数传去种子的时候，种子的默认值为1，意味着</p><p><em>f ( 1 ) = [41, 18467, 6334, 26500…]</em></p><p>但这个集合里的数字很多，一般够用了</p><p>如果想要每次产生不一样的随机数，我们要给rand()函数传递种子</p></blockquote><h3 id="srand-seed"><a href="#srand-seed" class="headerlink" title="srand(seed)"></a>srand(seed)</h3><blockquote><p>srand == seed + rand</p><p>指为rand()函数传递种子，括号里的参数值为种子值</p></blockquote><h3 id="time"><a href="#time" class="headerlink" title="time()"></a>time()</h3><h3 id="srand-在for循环内外的区别"><a href="#srand-在for循环内外的区别" class="headerlink" title="srand()在for循环内外的区别"></a>srand()在for循环内外的区别</h3><blockquote><p>写着写着突然不想写了，rand()就挺好</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2796 Feel Good(单调栈)</title>
      <link href="2019/10/30/POJ-2796-Feel-Good-%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>2019/10/30/POJ-2796-Feel-Good-%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个序列，要求的是一个区间，这个区间的最小值乘以这个区间所有数字的和是最大值。求这个最大值与这个区间。</p></blockquote><a id="more"></a><h3 id="单调栈-前缀和"><a href="#单调栈-前缀和" class="headerlink" title="单调栈+前缀和"></a>单调栈+前缀和</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;#define ll long longconst int N = 100100;int h[N];int L[N], R[N];ll sum[N];stack&lt;int&gt; sk;///单调栈维护了一个单调递增序列///单调栈:栈内越靠近栈顶的下标所对应的高度越高///但栈内所存的，终究还是下标int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        memset(sum, 0, sizeof(sum));        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;h[i]);            sum[i] = sum[i - 1] + h[i];        }        while(!sk.empty())            sk.pop();        for(int i = 1; i &lt;= n; ++i)        {            while(!sk.empty() &amp;&amp; h[sk.top()] &gt;= h[i])                sk.pop();            if(sk.empty())                L[i] = 0;///最小下标 - 1            else                L[i] = sk.top();            sk.push(i);        }        while(!sk.empty())            sk.pop();        for(int i = n; i &gt;= 1; --i)        {            while(!sk.empty() &amp;&amp; h[sk.top()] &gt;= h[i])                sk.pop();            if(sk.empty())                R[i] = n + 1;///最大下标 + 1            else                R[i] = sk.top();            sk.push(i);        }        ll ans = 0, tem = 0, ansL = 1, ansR = 1;///初始化是针对&#39;0&#39;的,想好了再写        for(int i = 1; i &lt;= n; ++i)        {            tem = h[i] * (sum[ R[i] - 1 ] - sum[ L[i] ]);            if(ans &lt; tem)            {                ans = tem;                ansL = L[i] + 1;                ansR = R[i] - 1;            }        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; ansL &lt;&lt; &#39; &#39; &lt;&lt; ansR &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>注意初始化的值，注意if(empty)时的赋值</p><p>分别是：最小下标 - 1，最大下标 + 1</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再看欧拉筛</title>
      <link href="2019/10/26/%E5%86%8D%E7%9C%8B%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>2019/10/26/%E5%86%8D%E7%9C%8B%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>欧拉筛如何实现：每个合数仅被它的最小质因子筛掉？</p></blockquote><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 3e7+5;int p[N], cnt;bool vis[N];/// 1 表示合数 0 表示素数void Euler(int n){    cnt = 0;    for(int i = 2; i &lt;= n; ++i)    {        if(!vis[i])            p[++cnt] = i;        for(int j = 1; j &lt;= cnt &amp;&amp; p[j] * i &lt;= n; ++j)        {            vis[ p[j] * i ] = 1;            if(i % p[j] == 0)///确保每个合数只被它的最小质因子筛掉                break;        }    }}</code></pre><h3 id="欧拉筛做了什么？"><a href="#欧拉筛做了什么？" class="headerlink" title="欧拉筛做了什么？"></a>欧拉筛做了什么？</h3><blockquote><p>我们要知道从2到n哪些是素数，哪些是合数，欧拉筛就从2到n都遍历了一遍</p><p>遍历这一遍干了啥？</p><p>两步</p><p>①判断当前所访问的数字i有没有被前面的数字筛掉，若没有，则是素数，存下来</p><p>(对应第一个if)</p><p>②用已筛选出来的全部素数<strong>由小到大</strong>依次 x i (乘i),得到的乘积因为是合数被筛掉。</p><p>(对应for循环以及vis[] = 1，至于后面那个if，下面来讨论)</p></blockquote><h3 id="倘若没有if-i-p-j-0-break-会发生什么？"><a href="#倘若没有if-i-p-j-0-break-会发生什么？" class="headerlink" title="倘若没有if(i % p[j] == 0) break; 会发生什么？"></a>倘若没有if(i % p[j] == 0) break; 会发生什么？</h3><p><img src="https://i.postimg.cc/qBNSNyyq/Euler.png" alt="无if"></p><blockquote><p>我们看 i == 4 的时候</p><p>2 x 4 == 8，筛掉了8</p><p>进行一步if判断：i % p[j] == 0 ? (此时 j == 1  第1个素数 ：2 )</p><p>条件成立 (即 i % p[1] == 0 <strong>式①</strong>)</p><p>如果不停止，那么 j++，j 变成2，p[2]是一个更大的质数3 (质数就是素数)，</p><p>那么合数 A = i x p[j] (<strong>式②</strong>)是被<strong>当前这个较大的</strong>p[j]（也就是3）筛掉了</p><p><del>那么接下来，就是见证奇迹的时刻</del></p><p>我们看:</p><p>A是能被 i 整除的(式②)</p><p>i是能被p[1]整除的(式①)</p><p>那么A是能被p[1]整除的！！！</p><p>那么A的最小质因子应该是p[1]而非p[2]</p><p>那么<code>if(i % p[j] == 0)</code>就该break！</p><p><del>你品！你细品！</del></p><p>就像上面的例子</p><p>2 x 4 == 8筛掉8后执行if</p><p>4 % 2 == 0</p><p>那么3 x 4 得到的12既然能被4整除，必然能被2整除(因为4能被2整除)</p><p>当然现在没有更大的素数筛出来，退一步讲，即使5筛出来了也是这样</p><p>5 x 4 得到的20既然能被4整除，必然能被2整除，所以到此为止</p><p>后面4的倍数的最小质因子都是2，不要用更大的质数去筛了</p></blockquote><h3 id="欧拉筛与埃氏筛"><a href="#欧拉筛与埃氏筛" class="headerlink" title="欧拉筛与埃氏筛"></a>欧拉筛与埃氏筛</h3><blockquote><p>欧拉筛保证了每个合数只被筛过一次</p><p>(埃氏筛是用每个素数去筛掉它的倍数，像6会被2、3各筛一次，30会被2、3、5各筛一次)</p><p>节省了不必要的重复筛除，节省了时间</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の素数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与区间查询相关的ACM算法</title>
      <link href="2019/10/21/%E4%B8%8E%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E7%9A%84ACM%E7%AE%97%E6%B3%95/"/>
      <url>2019/10/21/%E4%B8%8E%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E7%9B%B8%E5%85%B3%E7%9A%84ACM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>算法竞赛中有很多与区间处理与查询的题目，随之产生了许多处理区间问题的算法</p></blockquote><a id="more"></a><h2 id="与区间处理与查询相关的算法"><a href="#与区间处理与查询相关的算法" class="headerlink" title="与区间处理与查询相关的算法"></a>与区间处理与查询相关的算法</h2><blockquote><ol><li>尺取：</li><li>前缀和：某段区间的和</li><li>莫队：</li><li>线段树：</li><li>树状数组：</li><li>主席树：</li><li>单调栈：</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1506 Largest Rectangle in a Histogram</title>
      <link href="2019/10/21/HDU-1506-Largest-Rectangle-in-a-Histogram/"/>
      <url>2019/10/21/HDU-1506-Largest-Rectangle-in-a-Histogram/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>可以理解为：在一幅柱状图里找出最大的矩形</p><p>也可以理解为：找一个最大的矩形去覆盖柱子且不能覆盖空白处</p></blockquote><a id="more"></a><h2 id="单调栈功能"><a href="#单调栈功能" class="headerlink" title="单调栈功能"></a>单调栈功能</h2><blockquote><p>1.利用单调栈，可以找到从左/右遍历第一个比它小/大的元素的位置</p><p>2.以自己为最小或最大值找到最大的区间(对应 单调递增/单调递减)同1.</p><p>3.给定一个区间，找到这个区间的最大或最小值</p><p>此题用到了功能2，功能2是在1的基础上的</p><p><strong>单调栈的维护是 O(n) 级的时间复杂度，因为所有元素只会进入栈一次，并且出栈后再也不会进栈了。</strong></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;#define ll long longconst int N = 100100;ll h[N];int L[N], R[N];stack&lt;int&gt; sk;///单调栈维护了一个单调递增序列，但它栈内元素甚至连单调都算不上///单调栈:栈内越靠近栈顶的下标所对应的高度越高///但栈内所存的，终究还是下标int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%lld&quot;, &amp;h[i]);        while(!sk.empty())            sk.pop();        for(int i = 0; i &lt; n; ++i)        {            while(!sk.empty() &amp;&amp; h[sk.top()] &gt;= h[i])                sk.pop();            if(sk.empty())                L[i] = -1;            else                L[i] = sk.top();            sk.push(i);        }        while(!sk.empty())            sk.pop();        for(int i = n - 1; i &gt;= 0; --i)        {            while(!sk.empty() &amp;&amp; h[sk.top()] &gt;= h[i])                sk.pop();            if(sk.empty())                R[i] = n;            else                R[i] = sk.top();            sk.push(i);        }        ll ans = 0;        for(int i = 0; i &lt; n; ++i)            ans = max(ans, h[i] * (R[i] - L[i] - 1));        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4135 Co-prime 容斥原理</title>
      <link href="2019/10/20/HDU-4135-Co-prime-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>2019/10/20/HDU-4135-Co-prime-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出区间[L, R]，给出数字N，求在该区间里与N互质的数字的个数</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>在区间[L, R]里与N互质的数字的个数</p><p>== 在区间[1, R]里与N互质的数字的个数</p><p>减去( - ) 在区间[1, L]里与N互质的数字的个数</p><p>所以可以自定义一个函数求出[1, up]里与N互质的数的个数</p><p>但是数字太多，依次找互质的数字不好找，但找不互质的容易</p><p>区间[1, up]里N的质因子的倍数与N不互质</p><p>找到一个质因子可找到一大堆它的倍数(与N不互质的数字)</p><p>像找2、3、5…的倍数时有重复(6,10,15)，这便用到容斥!</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longll factor[100005], cnt = 0;void get_factors(ll n)///①得到全集②进行容斥{    cnt = 0;    for(ll i = 2; i * i &lt;= n; ++i)    {        if(n % i == 0)        {            factor[cnt++] = i;            while(n % i == 0)                n /= i;        }    }    if(n != 1)        factor[cnt++] = n;}ll Rongchi_queue(ll up)///计算 1 ~ up 内有几个 与n不互质(n){    ll t = 0, q[100005], res = 0;    q[t++] = -1;    for(ll i = 0; i &lt; cnt; ++i)    {        ll up = t;        for(ll j = 0; j &lt; up; ++j)            q[t++] = q[j] * factor[i] * -1;    }    for(ll i = 1; i &lt; t; ++i)        res += up / q[i];    return res;}ll Rongchi_binary(ll up){    ll res = 0;    for(ll i = 1; i &lt; (1 &lt;&lt; cnt); ++i)    {        ll tem = 1, tot = 0;        for(ll j = 0; j &lt; cnt; ++j)            if(i &amp; (1 &lt;&lt; j))            {                tot++;                tem *= factor[j];            }        if(tot &amp; 1)            res += up / tem;        else            res -= up / tem;    }    return res;}ll sum = 0;void DFS(ll num, ll used, ll up, ll mu, ll sth){    if(used == up)    {        sum += sth / mu;        return;    }    if(num == cnt)        return ;    DFS(num + 1, used, up, mu, sth);    DFS(num + 1, used + 1, up, mu * factor[num], sth);}ll Rongchi_DFS(ll up){    ll res = 0;    for(ll i = 1; i &lt;= cnt; ++i)    {        sum = 0;        DFS(0, 0, i, 1, up);        if(i &amp; 1)            res += sum;        else            res -= sum;    }    return res;}int main(){    int t, tot = 1;    ll left, right, n;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%lld%lld%lld&quot;, &amp;left, &amp;right, &amp;n);        get_factors(n);//        ll ans = Rongchi_queue(right) - Rongchi_queue(left - 1);//        ll ans = Rongchi_binary(right) - Rongchi_binary(left - 1);        ll ans = Rongchi_DFS(right) - Rongchi_DFS(left - 1);        ans = right - (left - 1) - ans;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; tot++ &lt;&lt; &quot;: &quot;;        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学の容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 新生 AC题数统计</title>
      <link href="2019/10/20/SDNUOJ-%E6%96%B0%E7%94%9F-AC%E9%A2%98%E6%95%B0%E7%BB%9F%E8%AE%A1/"/>
      <url>2019/10/20/SDNUOJ-%E6%96%B0%E7%94%9F-AC%E9%A2%98%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>用于统计SDNUOJ上某（些）用户AC题目数量</p></blockquote><a id="more"></a><pre><code class="lang-python">import csvimport requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        headers = {&#39;user-agent&#39;: &#39;Mozilla/5.0&#39;}        r = requests.get(url, headers=headers)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;&quot;def solve(html):    soup = BeautifulSoup(html, &quot;html.parser&quot;)    soup = soup.find(&quot;div&quot;, style=&quot;float: left;&quot;)    soup = BeautifulSoup(str(soup), &quot;html.parser&quot;)    soup = soup.find_all(&quot;span&quot;)    soup = BeautifulSoup(str(soup[2]), &quot;html.parser&quot;)    soup = soup.find(&quot;a&quot;)    num.append(soup.string)    #print(soup.string)name = (&quot;张华伟&quot;, &quot;熊淑娴&quot;, &quot;李瑞琪&quot;, &quot;连泰杰&quot;, &quot;查程曦&quot;,        &quot;孔浩冉&quot;, &quot;隋龙宇&quot;, &quot;徐李添&quot;, &quot;许世豪&quot;, &quot;杨煜琦&quot;,&quot;程恩浩&quot;,        &quot;姬彬荃&quot;, &quot;王祥男&quot;, &quot;韩瑶瑶&quot;, &quot;孙海燕&quot;, &quot;王玉莹&quot;,        &quot;黄琪瑶&quot;, &quot;郭双&quot;, &quot;侯宛辰&quot;, &quot;付浩翔&quot;, &quot;温芯彧&quot;, &quot;张立坤&quot;,        &quot;王政&quot;, &quot;纪毅&quot;, &quot;李亚君&quot;, &quot;商累浩&quot;, &quot;邓博&quot;, &quot;王君宇&quot;,        &quot;陈子龙&quot;, &quot;王超&quot;, &quot;马丽媛&quot;, &quot;孔一帆&quot;, &quot;马国华&quot;, &quot;李荣奥&quot;,        &quot;刘怡萱&quot;, &quot;张继慧&quot;)users = [ &#39;2019zhanghuawei&#39;, &quot;19xiongshuxian&quot;, &quot;2019liruiqi&quot;, &quot;2019liantaijie&quot;, &quot;19zhachengxi&quot;,          &quot;2019konghaoran&quot;, &quot;19suilongyu&quot;, &quot;19xulitian&quot;, &quot;19xushihao&quot;, &quot;19yangyuqi&quot;, &quot;19chengenhao&quot;,          &quot;2019jibinquan&quot;, &quot;19wangxiangnan&quot;, &quot;19hanyaoyao&quot;, &quot;19sunhaiyan&quot;, &quot;2019wangyuying&quot;,          &quot;19huangqiyao&quot;, &quot;19&quot;, &quot;19houwanchen&quot;, &quot;19fuhaoxiang&quot;, &quot;19wenxinyu&quot;, &quot;19zhanglikun&quot;,          &quot;19WANGZHENG&quot;, &quot;2019jiyi&quot;, &quot;2019liyajun&quot;, &quot;shangleihao2019&quot;, &quot;2019dengbo&quot;, &quot;2019wangjunyu&quot;,          &quot;19chenzilong&quot;, &quot;19Wangchao&quot;, &quot;19maliyuan&quot;, &quot;19kongyifan&quot;, &quot;19maguohua&quot;, &quot;Visiter&quot;,          &quot;2019liuyixuan&quot;, &quot;19zhangjihui&quot;]dic_users_num = {}dic_name_both = {}num = []list_dic = []def main():    url = &quot;https://vjudge.net/user/&quot;    # username = input()    for username in users:        url = &quot;http://www.acmicpc.sdnu.edu.cn/user/info/&quot;        url += username        html = getText(url)        #print(username, end=&#39; : &#39;)        solve(html)    for i, s in enumerate(users):        dic_users_num[s] = num[i]    with open(&quot;19AC_2019_10_20.csv&quot;, &quot;w&quot;, newline=&#39;&#39;, encoding=&#39;utf-16&#39;) as csvfile:       csvwriter = csv.writer(csvfile, delimiter=&#39;,&#39;)       csvwriter.writerow([&#39;姓名&#39;, &#39;OJ用户名&#39;, &#39;AC数&#39;])       i = 0       for key, value in dic_users_num.items():           csvwriter.writerow([name[i], key, value])           print(&quot;第&quot; + str(i) + &quot;个用户完成&quot;)           i += 1if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><blockquote><p>打开.csv文件后数据是依据’,’分割的，此时新建一个excel，选择“数据”-&gt;”导入”-&gt;”按，分割”，再加以排序</p></blockquote><p><img src="https://i.postimg.cc/tRSTWF8z/CO2-MWO5-QTE-WU7-UK5-S3-H.png" alt="result"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3904 Sky Code 容斥原理</title>
      <link href="2019/10/19/POJ-3904-Sky-Code-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/"/>
      <url>2019/10/19/POJ-3904-Sky-Code-%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出数字N，给出N个数字，从中找出四个数字，它们的公因数只有“1”，问能找到多少组？</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>测试四个数字的公因数是否只有“1”并不好实现，要检测多次。</p><p>试着从 (是 = 总 - 非) 方面想</p><p>对每个数字进行①质因数分解(准公因子)</p><p>同时记录下②不同质因子之间相乘所构成的重公因子</p><p>统计所有③准公因子与重公因子出现的次数（假设为num[i]）</p><p>计算④组合数C(num[i], 4) 即为以num[i]为公因子的四个数的组合数目</p><p>但是在这里面，计算2、3、6会有重复，于是便有了<strong>容斥</strong></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll __int64int factor[10005], cnt = 0;map&lt;int, int&gt; Count;map&lt;int, int&gt; Num;void get_factors(int n){    cnt = 0;    for(int i = 2; i * i &lt;= n; ++i)    {        if(n % i == 0)        {            factor[cnt++] = i;            while(n % i == 0)                n /= i;        }    }    if(n != 1)        factor[cnt++] = n;}void Rongchi(int n)///队列版{    get_factors(n);    int t = 0, q[10005], flag[10005];    q[t++] = 1;    memset(flag, -1, sizeof(flag));    for(int i = 0; i &lt; cnt; ++i)    {        int up = t;        for(int j = 0; j &lt; up; ++j)///一层循环一种集合        {            q[t] = q[j] * factor[i];            Count[ q[t] ]++;            flag[t] = -flag[j];            Num[ q[t] ] = (flag[t] == 1 ? 1 : 0);            t++;        }    }}void Rongchi(int n)///二进制版{    get_factors(n);    for(int i = 1; i &lt; (1 &lt;&lt; cnt); ++i)///一层循环一种集合    {        int tem = 1, tot = 0;        for(int j = 0; j &lt; cnt; ++j)            if(i &amp; (1 &lt;&lt; j))            {                tot++;                tem *= factor[j];            }        Count[tem]++;        Num[tem] = tot;    }}///num : 当前针对第几个元素///used : 在此之前拿取了多少个元素///up : 目标是取几个元素///mu : 已取元素之积void DFS(int num, int used, int up, int mu){    if(used == up)    {        Count[mu]++;        if(up &amp; 1)            Num[mu] = 1;        else            Num[mu] = 0;        return;    }    if(num == cnt)        return ;    DFS(num + 1, used, up, mu);    DFS(num + 1, used + 1, up, mu * factor[num]);}void Rongchi(int n)///DFS版{    get_factors(n);    int mu = 1;    for(int i = 1; i &lt;= cnt; ++i)///子集内含有的元素个数(实现奇加偶减)        DFS(0, 0, i, 1);}ll C(ll n)///这里n虽不到10000,若用int,n^4会爆{    return n * (n - 1) * (n - 2) * (n - 3) / 24;}int main(){    int n, a;    while(~scanf(&quot;%d&quot;, &amp;n))    {        Count.clear();        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a);            Rongchi(a);        }        ll ans = 0;        map&lt;int, int&gt; ::iterator it = Count.begin();        for(; it != Count.end(); ++it)        {            int idx = it -&gt; first;            if(Num[idx] &amp; 1)                ans += C(Count[idx]);            else                ans -= C(Count[idx]);        }        cout &lt;&lt; C(n) - ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="实现容斥的三种模板"><a href="#实现容斥的三种模板" class="headerlink" title="实现容斥的三种模板"></a>实现容斥的三种模板</h1><h3 id="①队列式"><a href="#①队列式" class="headerlink" title="①队列式"></a>①队列式</h3><blockquote><p>巧妙地运用了<strong>负负得正</strong>来决定<strong>奇加偶减</strong></p></blockquote><h3 id="②二进制"><a href="#②二进制" class="headerlink" title="②二进制"></a>②二进制</h3><blockquote><p>巧妙地运用了一个n元集合有 2 ^ n 个子集的性质，去掉空集从1开始，保留全集到2 ^ n结束，对这2 ^ n个数，以一个自增计数器 i 的每个二进制形式决定每个集合的构成。从 i 的二进制形式的右边向左边看，第 j 位上有1表示当前集合含有全集里的第 j 个元素，那么i的二进制里1的个数自然而然地反映了当集合内的元素个数，实现<strong>奇加偶减</strong></p></blockquote><h2 id="③-DFS"><a href="#③-DFS" class="headerlink" title="③.DFS"></a>③.DFS</h2><blockquote><p>直接对子集中含有元素的个数进行枚举，可根据自增变量实现<strong>奇加偶减</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 组合数学の容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3616 Milking Time(类最长递增子序列)</title>
      <link href="2019/09/11/POJ-3616-Milking-Time-%E7%B1%BB%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2019/09/11/POJ-3616-Milking-Time-%E7%B1%BB%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>奶牛有N个小时的产奶时间，农夫有M个时间段可用于挤牛奶，奶牛在相应的时间段有不同的产奶量，每挤一次牛奶必须休息R分钟，求最多能挤奶多少？</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>将每一段的右界加上R作为新的右界。如果前一段区间的右界 &lt;= 后一段区间的左界，那么两段可以同时取得。但由于每段的权值未知，可能存在与之冲突的一个时间段的权值较之更大，所以要择优。</p><p>对每个时间段dp，dp[i]表示选择了第i个时间段，整个过程可以达到的最大挤奶量</p><p>初始化<code>dp[i] = a[i].val</code></p><p>对之前的区间遍历(前提：排好序)，若<code>a[j].r &lt;= a[i].l</code></p><p>那么当前区间最优值可从<code>dp[j] + a[i].val</code>和<code>dp[i]</code>中取max，这里像是最长递增子序列的dp过程：</p><ol><li>对某组有序的元素dp</li><li>初始化dp[i] = a[i]</li><li>遍历 i 之前的元素 j ，若 a[j]  &lt;=  a[i] 表示 i 前面可连上 j (此时 i 地状态可更新为更优值<code>dp[i] = max(dp[i], dp[j] + a[i])</code>)</li></ol><p>此类算法可解决的问题？</p><ol><li>有序的多个元素(可以是数字、区间)</li><li>某些元素之间满足某种关系就具有某种“可连接性”，且“连接”可能引起最优值的更新</li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int l, r, val;} a[1005];bool cmp(node a, node b){    return a.l &lt; b.l;}int dp[1005];int main(){    int n, m, len;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;len);    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;a[i].l, &amp;a[i].r, &amp;a[i].val);        a[i].r += len;    }    sort(a, a + m, cmp);    for(int i = 0; i &lt; m; ++i)    {        dp[i] = a[i].val;        for(int j = 0; j &lt; i; ++j)            if(a[j].r &lt;= a[i].l)                dp[i] = max(dp[i], dp[j] + a[i].val);    }    int ans = -0x3f3f3f3f;    for(int i = 0; i &lt; m; ++i)        ans = max(ans, dp[i]);    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2385 Apple Catching(动态规划)</title>
      <link href="2019/09/09/POJ-2385-Apple-Catching-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2019/09/09/POJ-2385-Apple-Catching-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有两棵苹果树,编号为1,2。每一秒,这两棵苹果树中的其中一棵会掉一个苹果。</p><p>每一秒,你可以选择在当前苹果树下接苹果,或者迅速移动到另外一棵苹果树下接苹果(移动时间可以忽略不计)。</p><p>但由于却乏锻炼,你最多移动W次.问在T秒内,你最多能收集多少个苹果.</p><p>假设你开始站在1号苹果树下.</p></blockquote><a id="more"></a><h2 id="DP步骤"><a href="#DP步骤" class="headerlink" title="DP步骤"></a>DP步骤</h2><blockquote><ol><li>状态设定</li><li>初始化</li><li>状态转移</li><li>DP优化(可无)</li></ol></blockquote><h2 id="一-状态设定"><a href="#一-状态设定" class="headerlink" title="一.状态设定"></a>一.状态设定</h2><blockquote><ol><li>根据<strong>DP要素</strong>决定<strong>DP维数</strong></li><li>根据<strong>数据范围</strong>合理选择<strong>DP对象</strong></li><li>根据难易程度选择<strong>DP顺序</strong></li></ol></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>1DP要素：时间T、移动次数W(根据输入Input也能看出来)</p><p>2DP对象：数据都比较小，就是对T、W进行动态规划</p><p>3DP顺序：</p><p>先T后W：dp[t][w]前t秒移动w次的最优结果</p><p>先W后T：dp[w][t]移动w次…t秒…怪怪的…</p><p>其实存在时间元素时，这一元素一般放在第一维</p></blockquote><h2 id="二-初始化"><a href="#二-初始化" class="headerlink" title="二.初始化"></a>二.初始化</h2><blockquote><p>我们dp从1开始时看0状态是不是0，是则初始化为0，否则初始化为相应值，本题初始状态默认为0</p></blockquote><h2 id="三-状态转移"><a href="#三-状态转移" class="headerlink" title="三.状态转移"></a>三.状态转移</h2><blockquote><p>dp[i][j]表示前i秒移动j次能接到的最多的苹果数</p><p>我们发现在设计的DP里“移动”是一个必定发生的事件，移动 对应 状态改变。那么移动之前怎么由之前的状态向之后的状态过渡呢？</p><p>前一个状态(第i - 1秒)也有两种决策：j(第i - 1秒移动，最多数目)，j - 1(第i - 1秒不动，最多数目)，分别对应dp[i - 1][j]和dp[i - 1][j - 1]，那么移动前的dp[i][j]取两者max。</p><p>另外根据移动次数判断在哪棵树下，根据输入判断此刻在这棵树下是否能接到苹果，能则dp[i][j]++</p></blockquote><h2 id="DP与递归"><a href="#DP与递归" class="headerlink" title="DP与递归"></a>DP与递归</h2><blockquote><p>dp前i秒移动w次，我们并不需要知道那w次是在哪几秒里的，但是不耽误DP，这就是它(DP)的神秘之处——理论AC就能AC，不需要知道过程</p><p>这与递归函数的设计是极为相似的：</p><ol><li>在设计之初便想好了它的功能与元素对应关系(各形参、DP各维的意义)，先理论AC再手动实现</li><li>像是一个封装好的东西，明明就是你自己封装的，你也知道它怎么用，就是不甚清楚它的运行过程、各处细节，但偏偏就是能用</li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int a[1005];int dp[1005][40];int main(){    int t, w;    scanf(&quot;%d%d&quot;, &amp;t, &amp;w);    for(int i = 1; i &lt;= t; ++i)        scanf(&quot;%d&quot;, &amp;a[i]);    for(int i = 1; i &lt;= t; ++i)        for(int j = 0; j &lt;= w; ++j)///可取0可取w        {            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]);            if( ((j &amp; 1) &amp;&amp; (a[i] == 2)) || (j % 2 == 0 &amp;&amp; a[i] == 1) )                dp[i][j]++;        }    cout &lt;&lt; dp[t][w] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h2 id="四-DP优化"><a href="#四-DP优化" class="headerlink" title="四.DP优化"></a>四.DP优化</h2><blockquote><p>转移方程<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1]);</code>i完全是由i - 1转移来的，那么正序遍历可省略第一维</p></blockquote><h2 id="Code-Improved"><a href="#Code-Improved" class="headerlink" title="Code(Improved)"></a>Code(Improved)</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int a[1005];int dp[40];int main(){    int t, w;    scanf(&quot;%d%d&quot;, &amp;t, &amp;w);    for(int i = 1; i &lt;= t; ++i)        scanf(&quot;%d&quot;, &amp;a[i]);    for(int i = 1; i &lt;= t; ++i)        for(int j = 0; j &lt;= w; ++j)///可取0可取w        {            dp[j] = max(dp[j], dp[j - 1]);            if( ((j &amp; 1) &amp;&amp; (a[i] == 2)) || (j % 2 == 0 &amp;&amp; a[i] == 1) )                dp[j]++;        }    cout &lt;&lt; dp[w] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2229 Sunsets (动态规划)</title>
      <link href="2019/09/06/POJ-2229-Sunsets-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2019/09/06/POJ-2229-Sunsets-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个正整数N，用多个2的整数幂之和表示出来，求共有几种方案</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>像完全背包，只不过这里要求方案数</p><p>dp[i][j] 表示安排前n个物品到容量为m的背包中的方案数</p><p>dp[i][j] = dp[i - 1][j] + dp[i][ j - w[i] ] （01背包中 + dp[i - 1][j - w[i] ]）</p><ol><li>将前(i - 1)个物品安排到 j 容量的背包方案数（不放第i个物品了）</li><li>将前 i 个物品安排到(j - w[i])容量的背包方案数（第i个物品再放一个进去）</li></ol><p>然后按照顺序可以省去第一维</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000005;int w[N], dp[N];int main(){    int n, tot = 0;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; (1 &lt;&lt; i) &lt;= n; ++i)        w[tot++] = (1 &lt;&lt; i);    dp[0] = 1;    for(int i = 0; i &lt; tot; ++i)        for(int j = w[i]; j &lt;= n; ++j)            dp[j] = (dp[j] + dp[j - w[i]]) % 1000000000;    cout &lt;&lt; dp[n] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DPの背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3190 Stall Reservations(贪心)</title>
      <link href="2019/09/03/POJ-3190-Stall-Reservations-%E8%B4%AA%E5%BF%83/"/>
      <url>2019/09/03/POJ-3190-Stall-Reservations-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N个区间，将其不重叠地放在数轴上，至少需要几个数轴？</p><p>[1, 2]，[2, 3]算作重叠</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>贪心：若一个区间能接在另一个区间的后面，则二者可共用一个数轴</p><p>按区间左界从小到大排序，左界相同右界小的在前</p><p>第一个占用一条数轴，放入某个容器里。从第二个开始遍历，找出容器里(容器里都是安排好的区间)右界最小的区间，若其小于当前区间的左界，则当前区间可与该区间共用同一数轴，将那个区间拿出来，把这个区间放进去</p><p>每次都要找出容器中右界最小的区间，那么该容器可用优先队列充当</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int l, r, id, after_id, num;    bool operator &lt;(const node &amp; a)const    {        if(a.r == r)            return a.l &lt; l;        return a.r &lt; r;    }} a[60005];bool cmp(node a, node b){    if(a.l != b.l)        return a.l &lt; b.l;    return a.r &lt; b.r;}bool cmp_id(node a, node b){    return a.id &lt; b.id;}int main(){    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)        scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r), a[i].id = i;    sort(a, a + n, cmp);    for(int i = 0; i &lt; n; ++i)        a[i].after_id = i;    int ans = 1;    a[0].num = ans;    priority_queue&lt;node&gt; q;    q.push(a[0]);    for(int i = 1; i &lt; n; ++i)    {        if(!q.empty() &amp;&amp; a[i].l &gt; q.top().r)        {            a[i].num = a[ q.top().after_id ].num;            q.pop();        }        else            a[i].num = ++ans;        q.push(a[i]);    }    sort(a, a + n, cmp_id);    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; n; ++i)        cout &lt;&lt; a[i].num &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1328 Radar Installation(贪心)</title>
      <link href="2019/09/02/POJ-1328-Radar-Installation-%E8%B4%AA%E5%BF%83/"/>
      <url>2019/09/02/POJ-1328-Radar-Installation-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>x轴上方有N个岛屿，现在要在x轴上安装尽可能少的雷达(覆盖半径为d)来覆盖所有岛屿，求最少雷达数目</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>思维定势，先想到确定最优雷达位置覆盖第一个岛屿，再检测该雷达是否能覆盖其余岛屿，能则测试下一个岛屿，不能则放下一个雷达，后来实现起来麻烦且难做对。</p><p>逆向思维：根据岛屿位置推出雷达可放范围</p><p>得到一个个区间，问题转化为用最少的点占领所有的区间(保证每个区间上都有个被选中的点)，画图得出贪心选择方案</p></blockquote><h2 id="什么时候需运用逆向思维"><a href="#什么时候需运用逆向思维" class="headerlink" title="什么时候需运用逆向思维"></a>什么时候需运用逆向思维</h2><blockquote><p>问题涉及<strong>两个</strong>相互依赖的事物，按照定势思维想不清楚，则站在另一个对立的角度想想，大胆猜测。问题在于很多时候我们并不能意识到自己的思维定势</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    double x, y;}a[1005];struct interval{    double l, r;}b[1005];bool cmp(interval a, interval b){    return a.l &lt; b.l;}int main(){    int n, cnt = 1;    double d;    while(~scanf(&quot;%d%lf&quot;, &amp;n, &amp;d))    {        if(n == 0 &amp;&amp; d == 0)            break;        bool flag = 1;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lf%lf&quot;, &amp;a[i].x, &amp;a[i].y);            if(a[i].y &gt; d)                flag = 0;        }        if(!flag)        {            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt++ &lt;&lt; &quot;: &quot;;            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        }        else        {            for(int i = 0; i &lt; n; ++i)            {                double tem = sqrt(d * d - a[i].y * a[i].y);                b[i].l = a[i].x - tem;                b[i].r = a[i].x + tem;            }            sort(b, b + n, cmp);            double right = b[0].r;            int pos = 1, ans = 1;            while(pos &lt; n)            {                while(b[pos].l &lt;= right)                {                    right = min(right, b[pos].r);                    pos++;                }                if(pos &lt; n)                {                    ans++;                    right = b[pos].r;                }            }            cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt++ &lt;&lt; &quot;: &quot;;            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2376 Cleaning Shifts(贪心)</title>
      <link href="2019/09/02/POJ-2376-Cleaning-Shifts-%E8%B4%AA%E5%BF%83/"/>
      <url>2019/09/02/POJ-2376-Cleaning-Shifts-%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有一段从1到n的区间，现有多条线段(左右界不同，有重合区域)，求最少需几条线段才能覆盖整个大区间？</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>我知道选择一个区间要尽可能选右界大的，于是我按右界排序，后来发现做不了……这题应该明确：在左界能承接上一个区间的前提下选右界最大的。我一直难以做到左右兼顾，按左界排序？按右界排序？先左后右？先右后左?没有合适的排序方式。后来发现贪心有它的前提和选择。</p><p>贪心前提：左界承接前段</p><p>贪心选择：右界选择最右</p><p>我们得先满足前提，后贪心选择。</p><p>那就按左界从小到大排序，保证左边的是满足前提的，while去遍历</p><p>遍历过程中用<code>right = max(right, a[pos].r)</code>来贪心选择最右的</p><p>更新右界，再从上次停止的位置起重复上述过程</p><p>Attention：</p><p>上次停止的位置(设为pos)是满足条件的最右的位置，更新后的右界(设为right)是遍历过程中最右的界线，right  &gt;= a[pos].r &gt;= a[pos].l，所以这个方法只需要遍历一遍，O(n)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int l, r;} a[25005];bool cmp(node a, node b){    return a.l &lt; b.l;}int main(){    int n, t;    scanf(&quot;%d%d&quot;, &amp;n, &amp;t);    for(int i = 0; i &lt; n; ++i)        scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r);    sort(a, a + n, cmp);    int r = 0, pos = 0, ans = 0;    while(r &lt; t)    {        int rmax = -1;        while(a[pos].l &lt;= r + 1)        {            rmax = max(rmax, a[pos].r);            pos++;        }        if(rmax == -1)        {            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            return 0;        }        ans++;        r = rmax;    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}///4 10///1 5///2 10///9 10///3 9</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3169 Layout(最短路解差分约束)</title>
      <link href="2019/08/30/POJ-3169-Layout-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%A7%A3%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
      <url>2019/08/30/POJ-3169-Layout-%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%A7%A3%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N头牛(1~N)按序号排成一排</p><p>L个最大距离限制：某两头牛至多相距某个距离</p><p>D个最小距离限制：某两头牛至少相距某个距离</p><p>求第一头牛与第n头牛之间的最大距离</p></blockquote><a id="more"></a><h2 id="差分约束系统"><a href="#差分约束系统" class="headerlink" title="差分约束系统"></a>差分约束系统</h2><blockquote><p>如果一个系统由n个变量和m个约束条件组成，</p><p>形成m个形如 ai - aj ≤ k 的不等式(i,j∈[1,n],k为常数),</p><p>则称其为差分约束系统</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote><p>给定n个变量和m个不等式，</p><p>每个不等式的形式为 x[i] - x[j] &lt;= a[k] (0 &lt;= i, j &lt; n, 0 &lt;= k &lt; m， a[k]已知)，</p><p>求 x[i] - x[j] 的最大值。</p><p>例如当n = 4，m = 5，给出如下图所示的不等式组，求x3 - x0的最大值</p></blockquote><p><img src="https://i.loli.net/2019/08/30/Pp7mu4U2gWhZAME.png" alt="picture"></p><blockquote><p>观察x3 - x0的性质，我们如果可以通过不等式的两两加和得到c个形如 x3 - x0 &lt;= Ti 的不等式，那么 min{ Ti | 0 &lt;= i &lt; c } 就是我们要求的x3 - x0的最大值</p><p>x3 - x0 &lt;= 8                (3)</p><p>x3 - x0 &lt;= 9                (2)+(5)</p><p>x3 - x0 &lt;= 7                (1)+(4)+(5)</p><p>要同时满足，答案取7</p></blockquote><h2 id="求差分约束系统转为求单源最短路"><a href="#求差分约束系统转为求单源最短路" class="headerlink" title="求差分约束系统转为求单源最短路"></a>求差分约束系统转为求单源最短路</h2><pre><code class="lang-c">x[i] - x[j] &lt;= a[k]</code></pre><blockquote><p>令dis[i] = x[i]，令i = v， j = u， a[k] = w(j, i)</p></blockquote><pre><code class="lang-c">dis[v] - dis[u] &lt;= w(u, v)-&gt; dis[v] &lt;= dis[u] + w(u, v)</code></pre><blockquote><p>似最短路</p></blockquote><pre><code class="lang-c">前L条边：    dis[v] - dis[u] &lt;= w(u, v)    add(u, v, w);后D条边：    dis[v] - dis[u] &gt;= w(u, v)    统一采用 &lt;= (两边同乘 -1)    dis[u] - dis[v] &lt;= - w(u, v)    add(v, u, -w);隐藏边：    dis[i + 1] - dis[i] &gt;= 0    dis[i] - dis[i + 1] &lt;= 0    add(i + 1, i, 0);</code></pre><blockquote><p>相应转化后，要求1到n最大距离</p><p>最大对应到题目上，（L个）每个最大距离都取等号，才能对应“最大”</p><p>那为什么是求最短路(最小距离)呢？</p><p>x3 - x0 &lt;= 8</p><p>x3 - x0 &lt;= 9</p><p>x3 - x0 &lt;= 7</p><p>这里多条路只能选最短的那条（因为要同时满足三个不等式），这就对应起来了</p></blockquote><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><ol><li>存在负环：dis[n]可无限小， -1</li><li>图不连通：dis[n] == INF，   -2</li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;const int inf = 0x3f3f3f3f;struct node///存放“边”{    int from, to, w, pre;} a[N * N &lt;&lt; 1];int head[N], cnt, dis[N], times[N], tot, sum, n, L, D;bool vis[N];///vis[i]：0表示i不在队列里，1表示i在队列里void init()///受n影响，应安排在n被赋值之后{    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = inf, times[i] = 0, vis[i] = 0, head[i] = -1;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}bool spfa(int start){    deque&lt;int&gt; q;    dis[start] = 0;///到自己的距离为0    vis[start] = 1;    q.push_front(start);    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];        for(int i = head[first]; ~ i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;         ///极值优化             ///平均值优化                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                    if(++times[t] &gt; n)                        return 0;                }            }        }    }    return 1;}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;L, &amp;D);    init();    int u, v, w;    for(int i = 0; i &lt; L; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);    }    for(int i = 0; i &lt; D; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(v, u, -w);    }    for(int i = 1; i &lt; n; ++i)        add(i + 1, i, 0);    if(spfa(1))    {        if(dis[n] == inf)            cout &lt;&lt; &quot;-2&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; dis[n] &lt;&lt; &#39;\n&#39;;    }    else        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>部分原文来自：</p><p><a href="http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html" target="_blank" rel="noopener">http://www.cppblog.com/menjitianya/archive/2015/11/19/212292.html</a></p><p><a href="https://blog.csdn.net/my_sunshine26/article/details/72849441" target="_blank" rel="noopener">https://blog.csdn.net/my_sunshine26/article/details/72849441</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 技巧の差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2255 奔小康赚大钱(最大权值完全匹配KM算法)</title>
      <link href="2019/08/30/HDU-2255-%E5%A5%94%E5%B0%8F%E5%BA%B7%E8%B5%9A%E5%A4%A7%E9%92%B1-%E6%9C%80%E5%A4%A7%E6%9D%83%E5%80%BC%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8DKM%E7%AE%97%E6%B3%95/"/>
      <url>2019/08/30/HDU-2255-%E5%A5%94%E5%B0%8F%E5%BA%B7%E8%B5%9A%E5%A4%A7%E9%92%B1-%E6%9C%80%E5%A4%A7%E6%9D%83%E5%80%BC%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8DKM%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>KM算法：求二分图的最佳匹配，可以做到O(N^3)</p><p>最佳匹配：<strong>带权</strong>二分图的<strong>权值最大</strong>的<strong>完备匹配</strong>称为最佳匹配</p></blockquote><a id="more"></a><h2 id="算法过程模拟"><a href="#算法过程模拟" class="headerlink" title="算法过程模拟"></a>算法过程模拟</h2><blockquote><p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenruo/p/5264235.html</a></p></blockquote><h3 id="Code-Template"><a href="#Code-Template" class="headerlink" title="Code(Template)"></a>Code(Template)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAXN = 305;const int INF = 0x3f3f3f3f;int love[MAXN][MAXN];   /// 记录每个妹子和每个男生的好感度int ex_girl[MAXN];      /// 每个妹子的期望值int ex_boy[MAXN];       /// 每个男生的期望值bool vis_girl[MAXN];    /// 记录每一轮匹配匹配过的女生bool vis_boy[MAXN];     /// 记录每一轮匹配匹配过的男生int match[MAXN];        /// 记录每个男生匹配到的妹子 如果没有则为-1int slack[MAXN];        /// 记录每个汉子如果能被妹子倾心最少还需要多少期望值int N;bool dfs(int girl){    vis_girl[girl] = true;    for (int boy = 0; boy &lt; N; ++boy)    {        if (vis_boy[boy])            continue; /// 每一轮匹配 每个男生只尝试一次        int gap = ex_girl[girl] + ex_boy[boy] - love[girl][boy];        if (gap == 0)    /// 如果符合要求        {            vis_boy[boy] = true;            /// 找到一个没有匹配的男生 或者该男生的妹子可以找到其他人            if (match[boy] == -1 || dfs( match[boy] ))///这里类似匈牙利算法            {                match[boy] = girl;                return true;            }        }        else            slack[boy] = min(slack[boy], gap);            /// slack 可以理解为该男生要得到女生的倾心 还需多少期望值 取最小值    }    return false;}int KM(){    memset(match, -1, sizeof match);    /// 初始每个男生都没有匹配的女生    memset(ex_boy, 0, sizeof ex_boy);   /// 初始每个男生的期望值为0    /// 每个女生的初始期望值是与她相连的男生最大的好感度    for (int i = 0; i &lt; N; ++i)    {        ex_girl[i] = love[i][0];        for (int j = 1; j &lt; N; ++j)            ex_girl[i] = max(ex_girl[i], love[i][j]);    }    /// 尝试为每一个女生解决归宿问题    for (int i = 0; i &lt; N; ++i)    {        memset(slack, INF, sizeof(slack));    /// 因为要取最小值 初始化为无穷大        while (1)        {            /// 为每个女生解决归宿问题的方法是 ：如果找不到就降低期望值，直到找到为止            /// 记录每轮匹配中男生女生是否被尝试匹配过            memset(vis_girl, false, sizeof vis_girl);            memset(vis_boy, false, sizeof vis_boy);            if (dfs(i))                break;  /// 找到归宿 退出            /// 如果不能找到 就降低期望值            /// 最小可降低的期望值            int d = INF;            for (int j = 0; j &lt; N; ++j)                if (!vis_boy[j])                    d = min(d, slack[j]);            for (int j = 0; j &lt; N; ++j)            {                /// 所有访问过的女生降低期望值                if (vis_girl[j])                    ex_girl[j] -= d;                /// 所有访问过的男生增加期望值                if (vis_boy[j])                    ex_boy[j] += d;                /// 没有访问过的boy 因为girl们的期望值降低，距离得到女生倾心又进了一步！                else                    slack[j] -= d;            }        }    }    /// 匹配完成 求出所有配对的好感度的和    int res = 0;    for (int i = 0; i &lt; N; ++i)        res += love[ match[i] ][i];    return res;}int main(){    while (~scanf(&quot;%d&quot;, &amp;N))    {        for (int i = 0; i &lt; N; ++i)            for (int j = 0; j &lt; N; ++j)                scanf(&quot;%d&quot;, &amp;love[i][j]);        printf(&quot;%d\n&quot;, KM());    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图のKM算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3254 Corn Fields(状态压缩DP)</title>
      <link href="2019/08/29/POJ-3254-Corn-Fields-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/"/>
      <url>2019/08/29/POJ-3254-Corn-Fields-%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N x M 的01矩阵，1表示该处可种植作物，0表示不可以。另外相邻两块地不能同时种植作物，问有几种种植作物的方案(并没有规定种几棵作物)</p></blockquote><a id="more"></a><h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><pre><code class="lang-c++">for(int i = 0; i &lt; (1 &lt;&lt; n); ++i)</code></pre><blockquote><p>用一个数来表示一组数，以降低表示状态所需的维数的解题手段，就叫做状态压缩</p></blockquote><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><blockquote><p>以dp[i][state(j)]来表示对于前i行，第i行采用第j种状态时可以得到的可行方案总数</p><p>dp[i][state(j)]=dp[i - 1][state(k1)]+dp[i - 1][state(k2)]+……+dp[i - 1][state(kn)]</p><p>kn即为上一行可行状态的编号，上一行共有n种可行状态</p><p>(把不可行状态排除掉：同行相邻、同列相邻、理想与现实冲突) </p><p>最终ans=dp[m][state(k1)]+dp[m][state(k2)]+……+dp[m][state(kn)]; </p><p>原文出处：<a href="https://blog.csdn.net/harrypoirot/article/details/23163485" target="_blank" rel="noopener">https://blog.csdn.net/harrypoirot/article/details/23163485</a></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int MOD = 100000000;bool e[15][15], in[1 &lt;&lt; 14];int dp[15][1 &lt;&lt; 14], n, m;///dp[i][state(j)]来表示对于前i行，第i行采用第j种状态时可以得到的可行方案总数///检测理想方案是否与现实冲突bool solve(int S, int l)///S -&gt; set   l -&gt; line{    for (int i = 1; i &lt;= m; i++)        if (!e[l][i] &amp;&amp; (S &amp; (1 &lt;&lt; (m - i)))) /// 如果本来不能种,该状态种了            return false;    return true;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= m; j++)            cin &gt;&gt; e[i][j];    ///初始化(1):找出所有理想方案里的可行方案    for (int S = 0; S &lt; (1 &lt;&lt; m); S++)        if((S &amp; (S &lt;&lt; 1)) == 0)///同一行里无相邻的1            in[S] = true;    ///初始化(2):找出所有理想方案中不与现实冲突的方案    for (int S = 0; S &lt; (1 &lt;&lt; m); S++)        if (in[S] &amp;&amp; solve(S, 1))            dp[1][S] = 1;    /// (j &amp; S)筛选掉同列的状态 ;    for (int i = 2; i &lt;= n; i++)        for (int j = 0; j &lt; (1 &lt;&lt; m); j++)            for (int S = 0; S &lt; (1 &lt;&lt; m); S++)                if (in[j] &amp;&amp; solve(j, i) &amp;&amp; !(j &amp; S))                    dp[i][j] = (dp[i][j] + dp[i - 1][S]) % MOD;    int ans = 0;    for (int S = 0; S &lt; (1 &lt;&lt; m); S++)        ans = (ans + dp[n][S]) % MOD;    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><blockquote><ol><li>状态设定</li><li>状态转移</li><li>初始化(边界处理)</li></ol><p>状态转移方程一定要仔细推敲，不可一带而过，要思考为什么这么做，掌握一个套路，遇见这类问题能快速的识别出问题的本质，找出状态转移方程和DP的边界条件。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> DPの状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNU 1032 1194 1422 四维DP</title>
      <link href="2019/08/27/SDNUOJ-1032-1194-1422-%E5%9B%9B%E7%BB%B4DP/"/>
      <url>2019/08/27/SDNUOJ-1032-1194-1422-%E5%9B%9B%E7%BB%B4DP/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>两枚棋子从(1, 1)走到(m,n)，只能向下或向右走，不能走同一格</p><p>求路径上权值和的最大值。         (1, 1)与(m, n)处权值为0</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>两个二维DP同时进行 -&gt; 四维DP</p><p>单独处理走到同一格的情况</p></blockquote><!--more--><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int mp[51][51];int dp[51][51][51][51];int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            scanf(&quot;%d&quot;,&amp;mp[i][j]);    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            for (int k = 1; k &lt;= n; ++k)                for (int l = 1; l &lt;= m; ++l)                {                    int a = max(dp[i - 1][j][k - 1][l], dp[i - 1][j][k][l - 1]);                    int b = max(dp[i][j - 1][k - 1][l], dp[i][j - 1][k][l - 1]);                    dp[i][j][k][l] = mp[i][j] + mp[k][l] + max(a, b);                    if(i == k &amp;&amp; j == l)                        dp[i][j][k][l] -= mp[i][j];                }    cout &lt;&lt; max(dp[n - 1][m][n][m - 1], dp[n][m - 1][n - 1][m]) + mp[n][m] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(Hexo+github博客)不含livere的主题安装livere</title>
      <link href="2019/08/22/Hexo-github%E5%8D%9A%E5%AE%A2-%E4%B8%8D%E5%90%ABlivere%E7%9A%84%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85livere/"/>
      <url>2019/08/22/Hexo-github%E5%8D%9A%E5%AE%A2-%E4%B8%8D%E5%90%ABlivere%E7%9A%84%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85livere/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>今天SJY师哥给我发消息说我的博客gitment不能用，我一看还真是。其实最初也不是很想用gitment的，因为只有github用户才能评论。奈何我所用的hexo主题只有gitment这一个评论方式，觉得安装别的会挺麻烦就凑合着用了。然而该来的躲不过，gitment出了些问题，我看别人的解决方案也不太懂，于是试着安装了livere……</p></blockquote><a id="more"></a><h2 id="一-Livere官网注册"><a href="#一-Livere官网注册" class="headerlink" title="一.Livere官网注册"></a>一.Livere官网注册</h2><blockquote><p><a href="https://www.livere.com/" target="_blank" rel="noopener">livere(来必力)官网</a></p></blockquote><h2 id="二-登录后点击安装-City版"><a href="#二-登录后点击安装-City版" class="headerlink" title="二.登录后点击安装(City版)"></a>二.登录后点击安装(City版)</h2><h2 id="三-选择一般网站"><a href="#三-选择一般网站" class="headerlink" title="三.选择一般网站"></a>三.选择一般网站</h2><p><img src="https://i.postimg.cc/NLqKpKrQ/QTN-L-M-0-UP5-8-LB-E.png" alt="example"></p><blockquote><p>注意到这里有个<strong>data-uid</strong></p></blockquote><h2 id="四-修改到主题文件里的配置文件-config-yml"><a href="#四-修改到主题文件里的配置文件-config-yml" class="headerlink" title="四.修改到主题文件里的配置文件(_config.yml)"></a>四.修改到主题文件里的配置文件(_config.yml)</h2><blockquote><ol><li>添加以下代码</li></ol></blockquote><pre><code class="lang-yaml">Livere:  livere_uid: &#39;这里填上面那个data-uid&#39;</code></pre><blockquote><ol><li>将原来的评论系统false+注释</li></ol></blockquote><p><img src="https://i.postimg.cc/3JsqFYS9/9-0-Z-MSP-6-FT-JZKI0-R.png" alt="example"></p><h2 id="五-添加livere-ejs文件"><a href="#五-添加livere-ejs文件" class="headerlink" title="五.添加livere.ejs文件"></a>五.添加livere.ejs文件</h2><blockquote><p>我之前就是一直不知道 .ejs 文件怎么新建，没有专业工具怎么搞，今天突然想到，复制一个ejs文件不就行了吗……</p><p>找到主题文件里的layout/_partial，任意复制一个ejs文件，可以临时粘贴在桌面上，重命名为livere，打开(可以用sublime，这里用别的估计也行)，删掉原来的内容，将<strong>一般网站</strong>里的代码粘贴进去并保存，剪贴回partial文件里</p></blockquote><h2 id="六-修改post-ejs文件"><a href="#六-修改post-ejs文件" class="headerlink" title="六.修改post.ejs文件"></a>六.修改post.ejs文件</h2><blockquote><p>在主题文件下的layout文件里有个post.ejs文件，打开添加一行代码</p></blockquote><p><code>&lt;%- partial(&#39;_partial/livere&#39;, {post: page, index: true}) %&gt;</code></p><h2 id="七-博客更新部署，查看效果"><a href="#七-博客更新部署，查看效果" class="headerlink" title="七.博客更新部署，查看效果"></a>七.博客更新部署，查看效果</h2><pre><code class="lang-js">hexo cleanhexo ghexo shexo d</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1456 Supermarket(贪心+并查集)</title>
      <link href="2019/08/16/POJ-1456-Supermarket-%E8%B4%AA%E5%BF%83-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2019/08/16/POJ-1456-Supermarket-%E8%B4%AA%E5%BF%83-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>超市里有N个商品. 第i个商品必须在保质期(第di天)之前卖掉, 若卖掉可让超市获得pi的利润.  每天只能卖一个商品. 现在你要让超市获得最大的利润</p></blockquote><a id="more"></a><blockquote><p>链接： <a href="http://poj.org/problem?id=1456" target="_blank" rel="noopener">http://poj.org/problem?id=1456</a></p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>最主要的是贪心思想：</p><p>保质期长的商品早卖晚卖对自身无影响，但保质期短的商品却必须早卖</p><p>如此一来，贪心体现在：当前选中的最贵的商品最大限度地晚卖</p><p>若当前最贵的在保质期内：</p><p>若保质期的最后一天未被标记，则在那一天卖掉它，标记这一天</p><p>若保质期的最后一天标记了(卖了别的商品)，那就在前一天卖掉它，不行再往前推一天，总之(在保质期内)越晚越好</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);void Debug(char * s){    cout &lt;&lt; &quot;-------------  &quot; &lt;&lt; s &lt;&lt; &quot;  -------------&quot; &lt;&lt; &#39;\n&#39;;}typedef pair&lt;int, int&gt; P;bool cmp(P a, P b){    return a.first &gt; b.first;}int pre[10005];int found(int x){    if(pre[x] == -1)        return x;    return pre[x] = found(pre[x]);}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        memset(pre, -1, sizeof(pre));        int price, day;        vector&lt;P&gt; vec;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d%d&quot;, &amp;price, &amp;day);            vec.push_back(P(price, day));        }        sort(vec.begin(), vec.end(), cmp);        ll ans = 0;        for(int i = 0; i &lt; n; ++i)        {            int num = found(vec[i].second);            if(num &gt; 0)            {                ans += vec[i].first;                pre[num] = num - 1;            }        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>found函数压缩的过程是标记的过程</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
            <tag> 基本算法の贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 获取Vjudge用户AC题数</title>
      <link href="2019/08/16/Python-%E8%8E%B7%E5%8F%96Vjudge%E7%94%A8%E6%88%B7AC%E9%A2%98%E6%95%B0/"/>
      <url>2019/08/16/Python-%E8%8E%B7%E5%8F%96Vjudge%E7%94%A8%E6%88%B7AC%E9%A2%98%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>根据用户名，统计Vjudge某些用户AC题数目</p></blockquote><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-python">import bs4import requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        r = requests.get(url)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;&quot;def solve(html):    soup = BeautifulSoup(html, &quot;html.parser&quot;)    for tr in soup.find(&#39;table&#39;).children:        if isinstance(tr, bs4.element.Tag):            th = tr.find(&quot;th&quot;)            if th.string == &quot;Overall solved&quot;:                a = tr.find(&#39;a&#39;)                print(a.string)                breakusers = [ &#39;A_Wanderer&#39;, &#39;2017RenYaochen&#39;, &#39;2017liuyidi&#39;, &#39;Create_miracles&#39;, &#39;ltrbless&#39;,          &#39;The__Flash&#39;, &#39;lanzongwei&#39;, &#39;18wangxin&#39;, &#39;2018muyu&#39;, &#39;tianjian2017&#39;,          &#39;shenmafuyun&#39;, &#39;xiaobian&#39;, &#39;Moon1129&#39;, &#39;ignb&#39;, &#39;18XiWenjuan&#39;, &#39;gw76999&#39;,          &#39;2018SongYihao&#39;, &#39;18yanmingfu&#39;, &#39;18qinpeng&#39;, &#39;2018fenggen&#39;, &#39;Thankyou&#39; ]def main():    url = &quot;https://vjudge.net/user/&quot;    # username = input()    for username in users:        url = &quot;https://vjudge.net/user/&quot;        url += username        html = getText(url)        print(username, end=&#39; : &#39;)        solve(html)if __name__ == &quot;__main__&quot;:    main()</code></pre><p><img src="https://i.postimg.cc/CKzYzHPt/FGFWT-07-L-S2-Q-FH-8-V.png" alt="result"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定向爬虫:中国大学排名</title>
      <link href="2019/08/16/%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D/"/>
      <url>2019/08/16/%E5%AE%9A%E5%90%91%E7%88%AC%E8%99%AB-%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6%E6%8E%92%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>url：<a href="http://www.zuihaodaxue.com/" target="_blank" rel="noopener">http://www.zuihaodaxue.com/</a></p></blockquote><a id="more"></a><p><img src="https://i.postimg.cc/nLZpT375/Q9-M-NLMA7-D-NU-P6-8-A.png" alt="details"></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-python">import bs4import requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        kv = { &#39;user-agent&#39;: &#39;Mozilla/5.0&#39; }        r = requests.get(url, headers=kv)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;&quot;def fillUnivList(ulist, html):    soup = BeautifulSoup(html, &#39;html.parser&#39;)    for tr in soup.find(&#39;tbody&#39;).children: # 找到第一个tbody标签,遍历子节点        if isinstance(tr, bs4.element.Tag): # 去除（非标签类型）字符串类型（标签树中有标签类型、字符串类型）            tds = tr(&#39;td&#39;) # find_all            ulist.append([ tds[0].string, tds[1].string, tds[2].string ])def printUnivList(ulist, num):    tplt = &quot;{0:^10}\t{1:{3}^10}\t{2:^10}&quot; # .format前的输入格式不要乱填空格    print(tplt.format(&quot;排名&quot;,&quot;学校名称&quot;,&quot;省市&quot;,chr(12288)))    for i in range(num):        u = ulist[i]        print(tplt.format(u[0], u[1], u[2], chr(12288)))def main():    uinfo = []    url = &quot;http://www.zuihaodaxue.com/zuihaodaxuepaiming2019.html&quot;    html = getText(url)    fillUnivList(uinfo, html)    printUnivList(uinfo, 20) # 打印前20所if __name__ == &quot;__main__&quot;:    main()</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019牛客暑期多校训练营(第九场)D折半枚举</title>
      <link href="2019/08/15/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%9C%BA-D%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE/"/>
      <url>2019/08/15/2019%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5-%E7%AC%AC%E4%B9%9D%E5%9C%BA-D%E6%8A%98%E5%8D%8A%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出N( &lt;= 36)和一个sum值，给出N个数字，从中选几个和为sum</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>所有数字都有1(选取)、0(不选取)两种选择，所有状态就是2 ^ 36种</p><p>枚举所有状态必然超时</p><p>我们发现，2 ^ 36，底数为2(0/1两种状态)，幂不超过40而接近40</p><p>这些都指向-&gt;折半枚举</p><p>折半枚举适合的题目：每个数字(物品)只有选取与不选取两种选择，数字(物品)数目不超过40但接近于40(2 ^ 20可遍历)</p><p>所以要对  (N &lt;=40 、 N：0/1）敏感，反应出这是折半枚举</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);#define Debug cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; &#39;\n&#39;;int n;ll num, a[40];bool vis[40];struct node{    vector&lt;int&gt; c;    ll sum;    bool operator&lt;(const node g)const    {        return sum &lt; g.sum;    }} e[1 &lt;&lt; 19];ll e_copy[1 &lt;&lt; 19];int main(){    scanf(&quot;%d%lld&quot;, &amp;n, &amp;num);    for(int i = 0; i &lt; n; ++i)        scanf(&quot;%lld&quot;, &amp;a[i]);    int mid = n / 2;    for(int i = 0; i &lt; (1 &lt;&lt; mid); ++i)    {        for(int j = 0; j &lt; mid; ++j)            if(i &gt;&gt; j &amp; 1)            {                e[i].c.push_back(j);                e[i].sum += a[j];            }    }    sort(e, e + (1 &lt;&lt; mid));    int idx = 1;    for(int i = 1; i &lt; (1 &lt;&lt; mid); ++i)        if(e[i - 1].sum &lt; e[i].sum)            e_copy[idx++] = e[i].sum;    node tem;    int ans;    for(int i = 0; i &lt; 1 &lt;&lt; (n - mid); ++i)    {        tem.sum = 0;        tem.c.clear();        for(int j = 0; j &lt; n - mid; ++j)            if(i &gt;&gt; j &amp; 1)            {                tem.c.push_back(j);                tem.sum += a[j + mid];            }        if(tem.sum &lt;= num)        {            int pos = lower_bound(e_copy, e_copy + idx, num - tem.sum) - e_copy;            if(pos != (1 &lt;&lt; mid) &amp;&amp; e_copy[pos] + tem.sum == num)            {                ans = pos;                break;            }        }    }    int sz = tem.c.size();    for(int i = 0; i &lt; sz; ++i)        vis[ tem.c[i] + mid ] = 1;    sz = e[ans].c.size();    for(int i = 0; i &lt; sz; ++i)        vis[ e[ans].c[i] ] = 1;    for(int i = 0; i &lt; n; ++i)        if(vis[i])            cout &lt;&lt; &#39;1&#39;;        else            cout &lt;&lt; &#39;0&#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="Code-of-TLE（DFS暴搜）"><a href="#Code-of-TLE（DFS暴搜）" class="headerlink" title="Code of TLE（DFS暴搜）"></a>Code of TLE（DFS暴搜）</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);#define Debug cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; &#39;\n&#39;;int n, cnt = -1;bool vis[40], flag;ll sum, a[40];void DFS(ll rest){    cnt++;    if(rest == 0 || flag == 1)    {        flag = 1;        cnt--;        return ;    }    if(cnt &gt;= n || rest &lt; 0)    {        cnt--;        return ;    }    vis[cnt] = 1;    rest -= a[cnt];    DFS(rest);    if(flag)    {        cnt--;        return ;    }    vis[cnt] = 0;    rest += a[cnt];    DFS(rest);    cnt--;}int main(){    scanf(&quot;%d%lld&quot;, &amp;n, &amp;sum);    for(int i = 0; i &lt; n; ++i)        scanf(&quot;%lld&quot;, &amp;a[i]);    flag = 0;    memset(vis, 0, sizeof(vis));    ll rest = sum;    DFS(rest);    for(int i = 0; i &lt; n; ++i)        if(vis[i])            cout &lt;&lt; &#39;1&#39;;        else            cout &lt;&lt; &#39;0&#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の折半枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About BeautifulSoup</title>
      <link href="2019/08/14/Python-About-BeautifulSoup/"/>
      <url>2019/08/14/Python-About-BeautifulSoup/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><ol><li>BeautifulSoup的基本元素</li><li>HTML内容遍历方法</li><li>HTML格式化</li><li>信息标记与内容查找方法</li></ol></blockquote><a id="more"></a><h2 id="1-BeautifulSoup五种基本元素"><a href="#1-BeautifulSoup五种基本元素" class="headerlink" title="1.BeautifulSoup五种基本元素"></a>1.BeautifulSoup五种基本元素</h2><p><img src="https://i.postimg.cc/k5DMMh8d/KST4684-CH5-OCBCE0-N-3-QP0-J.png" alt="Five elements"></p><pre><code class="lang-python">import requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        kv = { &#39;user-agent&#39;: &#39;Mozilla/5.0&#39; }        r = requests.get(url, headers=kv)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &#39;Error&#39;def solve(txt):    soup = BeautifulSoup(txt, &#39;html.parser&#39;)    print(soup.title)    print(soup.a) # 标签(只返回了第一个标签内容)    print(type(soup.a)) # &lt;class &#39;bs4.element.Tag&#39;&gt;    print(soup.a.name) # 标签名字    print(type(soup.a.name)) # &lt;class &#39;str&#39;&gt;    print(soup.a.parent.name)    print(soup.a.parent.parent.name)    print(soup.a.attrs) # 标签属性    print(type(soup.a.attrs)) # &lt;class &#39;dict&#39;&gt;    print(soup.a.attrs[&#39;href&#39;]) # 采用字典的方式提取信息    print(soup.a.string)    print(type(soup.a.string)) # &lt;class &#39;bs4.element.NavigableString&#39;&gt;    newsoup = BeautifulSoup(&#39;&lt;b&gt;&lt;!--This is a comment--&gt;&lt;/b&gt;&lt;p&gt;This is not a comment&lt;/p&gt;&#39;, &#39;html.parser&#39;)    print(newsoup.b.string) # This is a comment 自动去掉了注释标志    print(type(newsoup.b.string)) # &lt;class &#39;bs4.element.Comment&#39;&gt;    print(newsoup.p.string) # This is not a comment    print(type(newsoup.p.string)) # &lt;class &#39;bs4.element.NavigableString&#39;&gt;def main():    url = &quot;https://www.csdn.net/&quot;    txt = getText(url)    solve(txt)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="2-HTML内容的三种遍历"><a href="#2-HTML内容的三种遍历" class="headerlink" title="2.HTML内容的三种遍历"></a>2.HTML内容的三种遍历</h2><p><img src="https://i.postimg.cc/CxGrBFGG/WEU1-LUYANSV-7-N-4-KFSARF.png" alt="下行遍历"></p><p><img src="https://i.postimg.cc/XJJszdTL/O-K-5-LFKZPB-PO-POO-S8.png" alt="上行遍历"></p><p><img src="https://i.postimg.cc/yx3vVB6S/YA-RC-BI-R31-Y-TBJR8-V5-WS.png" alt="平行遍历"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-python">import requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        kv = { &#39;user-agent&#39;: &#39;Mozilla/5.0&#39; }        r = requests.get(url, headers=kv)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &#39;Error&#39;def down(demo):    soup = BeautifulSoup(demo, &#39;html.parser&#39;)    print(soup.head)    print(soup.head.contents) # head标签子节点（包括：标签节点、字符串节点(像&#39;\n&#39;)）的列表    print(type(soup.head.contents)) # &lt;class &#39;list&#39;&gt;    print(soup.body)    print(soup.body.contents)    print(len(soup.body.contents))    print(soup.body.contents[1])    for child in soup.body.children: # 循环遍历子节点(迭代类型只能用在for...in...结构中)        print(child)    for grandchild in soup.body.descendants: # 循环遍历所有子孙节点(迭代类型)        print(grandchild)def up(demo):    soup = BeautifulSoup(demo, &#39;html.parser&#39;)    for parent in soup.a.parents: # 节点的&quot;先辈&quot;标签,没有则None        if parent is None:            print(parent)        else:            print(parent.name)    print(soup.title.parent) # 节点的父亲标签    print(soup.html.parent) # html为最高标签，父节点为自己def parallel(demo):    soup = BeautifulSoup(demo, &#39;html.parser&#39;)    print(soup.a.next_sibling)    print(soup.a.next_sibling.next_sibling)    print(soup.a.previous_sibling)    print(soup.a.previous_sibling.previous_sibling)    print(soup.a.parent)    for sibling in soup.a.next_siblings: # 迭代类型，遍历后序节点        print(sibling)    for sibling in soup.a.previous_siblings: # 迭代类型，遍历前序节点        print(sibling)def main():    url = &quot;https://fireworks99.github.io/&quot;    demo = getText(url)    # down(demo)    # up(demo)    parallel(demo)if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="3-HTML格式化prettify"><a href="#3-HTML格式化prettify" class="headerlink" title="3.HTML格式化prettify"></a>3.HTML格式化prettify</h2><pre><code class="lang-python">import requestsfrom bs4 import BeautifulSoup# 爬取网页的通用代码框架def getText(url):    try:        r = requests.get(url)        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;Error occurred&quot;if __name__ == &quot;__main__&quot;:    url = &quot;https://fireworks99.github.io/&quot;    demo = getText(url)    soup = BeautifulSoup(demo, &#39;html.parser&#39;)    print(soup.prettify())    print(soup.a.prettify())</code></pre><h2 id="4-信息标记与内容查找方法"><a href="#4-信息标记与内容查找方法" class="headerlink" title="4.信息标记与内容查找方法"></a>4.信息标记与内容查找方法</h2><p><img src="https://i.postimg.cc/Pr6rpRyX/KI76-T14-B-XKV782-Z50-W-R.png" alt="XML"></p><p><img src="https://i.postimg.cc/Qdw8SKvv/99-53-XDG3-PKB-PGV9-B-F-E.png" alt="JSON"></p><p><img src="https://i.postimg.cc/j5rsY0xX/G7-3-QJWSSH71-O0-G-OAB-K.png" alt="YAML"></p><p><img src="https://i.postimg.cc/cCx06R8t/KLBV-Q5-H9-LBO44-MUMI-WO.png" alt="compare"></p><p><img src="https://i.postimg.cc/QMc3b4QW/DX94-TRUCPAHU-KZXTK87-D.png" alt="查找"></p><p><img src="https://i.postimg.cc/630Ns81W/68-P-I-BEMW-GTW-Z-G.png" alt="参数"></p><p><img src="https://i.postimg.cc/7hZrqqpg/3-ZG-6-6-5-BHBH-U-B-AN.png" alt="替代"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python网络爬虫与信息提取</title>
      <link href="2019/08/13/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/"/>
      <url>2019/08/13/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%8E%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><ol><li>request.get()</li><li>处理异常</li><li>通用框架</li><li>模拟浏览器访问</li><li>向搜索引擎提交关键词获取搜索结果</li><li>网络图片(视频、动画等二进制资源)的爬取与存储</li><li>大量图片的爬取与存储</li><li>IP地址归属地的自动查询</li></ol></blockquote><a id="more"></a><h2 id="一-request-get"><a href="#一-request-get" class="headerlink" title="一.request.get()"></a>一.request.get()</h2><pre><code class="lang-python">import requests# 构造一个向服务器请求资源的Request对象，返回一个包含服务器资源的Response对象(即r)r = requests.get(&quot;http://www.baidu.com&quot;)# Response对象的五种属性print(r.status_code )print(r.encoding) # 猜测编码方式print(r.apparent_encoding) # 分析编码方式r.encoding = r.apparent_encodingprint(r.text)print(r.content) # HTTP响应内容的二进制形式(还原图片等)</code></pre><h2 id="二-处理异常"><a href="#二-处理异常" class="headerlink" title="二.处理异常"></a>二.处理异常</h2><pre><code class="lang-python">import requests# 爬取网页的通用代码框架&quot;&quot;&quot;网络连接有风险处理异常很重要&quot;&quot;&quot;def getText(url):    try:        r = requests.get(url, timeout = 30)        r.raise_for_status()  # 如果不是200， 引发HTMLError异常,跳到except        r.encoding = r.apparent_encoding # 这步好像挺耗时的        return r.text    except:        return &quot;Error occurred&quot;if __name__ == &quot;__main__&quot;:    url = &quot;https://fireworks99.github.io/&quot;    print(getText(url))</code></pre><h2 id="三-通用代码框架"><a href="#三-通用代码框架" class="headerlink" title="三.通用代码框架"></a>三.通用代码框架</h2><pre><code class="lang-python">import requests# 爬取网页的通用代码框架def getText(url):    try:        r = requests.get(url)        r.raise_for_status()        return &quot;Succeed&quot;    except:        return &quot;Error occurred&quot;if __name__ == &quot;__main__&quot;:    url = &quot;https://fireworks99.github.io/&quot;    print(getText(url))    r = requests.head(url) # 用较少的网络流量获取概要信息    print(r.headers)    print(r.text) # 空了</code></pre><h2 id="四-模拟浏览器访问"><a href="#四-模拟浏览器访问" class="headerlink" title="四.模拟浏览器访问"></a>四.模拟浏览器访问</h2><pre><code class="lang-python">import requestsurl = &quot;https://www.amazon.cn/dp/B072Z88B9T/ref=zg_bs_116169071_2?_encoding=UTF8&amp;psc=1&amp;refRID=7S6CK24KSH7ARE601YXF&quot;r = requests.get(url)print(r.status_code) # 503&quot;&quot;&quot;r.encoding = r.apparent_encodingprint(r.text)# &quot;出现错误&quot; API造成&quot;&quot;&quot;&quot;&quot;&quot;print(r.request.headers)# {&#39;User-Agent&#39;: &#39;python-requests/2.19.1&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;}爬虫告诉亚马逊的服务器：此次访问是一个python的requests库的一个程序制造的(User-Agent)那么亚马逊的服务器可以通过 来源审查 拒绝这样的访问&quot;&quot;&quot;&quot;&quot;&quot;更改头部信息，模拟浏览器向网站发送请求&quot;&quot;&quot;kv = { &#39;user-agent&#39;: &#39;Mozilla/5.0&#39; } # 标准浏览器身份标识字段r = requests.get(url, headers = kv)print(r.status_code) # 200print(r.request.headers)# {&#39;user-agent&#39;: &#39;Mozilla/5.0&#39;, &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;, &#39;Accept&#39;: &#39;*/*&#39;, &#39;Connection&#39;: &#39;keep-alive&#39;}print(r.text)</code></pre><h2 id="五-提交关键词获取搜索结果"><a href="#五-提交关键词获取搜索结果" class="headerlink" title="五.提交关键词获取搜索结果"></a>五.提交关键词获取搜索结果</h2><pre><code class="lang-python">import requests&quot;&quot;&quot;向搜索引擎提交关键词并获取搜索结果百度关键词接口：http://www.baidu.com/s?wd=keyword360关键词接口：http://www.so.com/s?q=keyword&quot;&quot;&quot;keyword = &quot;Python&quot;try:    kv = { &#39;wd&#39;:keyword }    r = requests.get(&quot;http://www.baidu.com/s&quot;, params=kv)    print(r.request.url)    r.raise_for_status()    print(len(r.text))except:    print(&quot;Error occurred&quot;)try:    kv = { &#39;q&#39;:keyword }    r = requests.get(&quot;http://www.so.com/s&quot;, params=kv)    print(r.request.url)    r.raise_for_status()    print(len(r.text))except:    print(&quot;Error occurred&quot;)</code></pre><h2 id="六-网络图片的爬取与存储"><a href="#六-网络图片的爬取与存储" class="headerlink" title="六.网络图片的爬取与存储"></a>六.网络图片的爬取与存储</h2><pre><code class="lang-python">import osimport requestsurl = &quot;https://www.lifeofpix.com/wp-content/uploads/2019/08/DJI_0452-1600x1057.jpg&quot;root = &quot;E://pycharm//crawl//pictures//&quot;path = root + url.split(&#39;/&#39;)[-1] # url中以 &#39;/&#39; 分割的最后一部分try:    if not os.path.exists(root): # 根目录是否存在，不存在就建立        os.mkdir(root)    if not os.path.exists(path): # 文件是否存在，不存在才去爬取        r = requests.get(url)        with open(path, &#39;wb&#39;) as f:            f.write(r.content)# 图片是以二进制形式保存的,恰好 r.content返回的也是二进制的内容            f.close()            print(&quot;Succeed&quot;)    else:        print(&quot;File already exists!&quot;)except:    print(&quot;Crawl failed!&quot;)</code></pre><h2 id="七-网络图片批量爬取"><a href="#七-网络图片批量爬取" class="headerlink" title="七.网络图片批量爬取"></a>七.网络图片批量爬取</h2><pre><code class="lang-python">import osimport requestsfrom bs4 import BeautifulSoupdef getText(url):    try:        kv = {&#39;user-agent&#39;: &#39;Mozilla/5.0&#39;}        r = requests.get(url, headers = kv) # 知乎有来源审查        r.raise_for_status()        r.encoding = r.apparent_encoding        return r.text    except:        return &quot;Error&quot;if __name__ == &quot;__main__&quot;:    url = &quot;https://www.zhihu.com/question/63202062/answer/209514500&quot;    r = getText(url)    bs_obj = BeautifulSoup(r, features=&#39;html.parser&#39;)    pic_list = bs_obj.find_all(&quot;img&quot;)    img_list = []    idx = 0    for link in pic_list:        idx += 1        if idx % 2 == 0:   # 偶数项是我们需要的            img_list.append(link[&#39;src&#39;])        else:            pass    root = &quot;E://pycharm//crawl//pictures//&quot;    try:        if not os.path.exists(root):  # 根目录是否存在，不存在就建立            os.mkdir(root)        for url in img_list:            path = root + url.split(&#39;/&#39;)[-1]  # url中以 &#39;/&#39; 分割的最后一部分            if not os.path.exists(path):  # 文件是否存在，不存在才去爬取                r = requests.get(url)                with open(path, &#39;wb&#39;) as f:                    f.write(r.content)  # 图片是以二进制形式保存的,恰好 r.content返回的也是二进制的内容                    f.close()            else:                pass    except:        print(&quot;Crawl failed!&quot;)</code></pre><h2 id="八-IP地址归属地的自动查询"><a href="#八-IP地址归属地的自动查询" class="headerlink" title="八.IP地址归属地的自动查询"></a>八.IP地址归属地的自动查询</h2><pre><code class="lang-python">import requestsurl = &quot;http://m.ip138.com/ip.asp?ip=&quot; # APIaddress = input()try:    kv = { &#39;user-agent&#39;: &#39;Mozilla/5.0&#39; }    r = requests.get(url + address, headers=kv)    r.raise_for_status()    r.encoding = r.apparent_encoding    print(r.text[-500:]) # 约束范围空间，否则可能影响IDE的使用except:    print(&quot;Error&quot;)</code></pre><p><img src="https://i.postimg.cc/T10Sztpy/C3-NYO1-J-0-4-G0-SQT4-E.png" alt="API"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2665 K-th Number</title>
      <link href="2019/08/12/HDU-2665-K-th-Number/"/>
      <url>2019/08/12/HDU-2665-K-th-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出一个序列，查询某段区间里第k小的数字</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>跟区间有关的算法/数据结构有哪些？</p><p>尺取? 前缀和(与差分)? 莫队? 线段树? 树状数组? ……</p><p>而主席树，我认为是：以<strong>线段树</strong>为结构单元的<strong>前缀和</strong>序列</p></blockquote><h2 id="Study-Blog"><a href="#Study-Blog" class="headerlink" title="Study Blog"></a>Study Blog</h2><blockquote><ol><li><a href="https://www.cnblogs.com/LonecharmRiver/articles/9087536.html" target="_blank" rel="noopener">https://www.cnblogs.com/LonecharmRiver/articles/9087536.html</a></li><li><a href="https://www.cnblogs.com/zyf0163/p/4749042.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyf0163/p/4749042.html</a></li></ol></blockquote><h2 id="Code-of-HDU-2665-K-th-Number"><a href="#Code-of-HDU-2665-K-th-Number" class="headerlink" title="Code of HDU 2665 K-th Number"></a>Code of HDU 2665 K-th Number</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define M 200010int node_cnt, n, m;///节点标号、数组大小、查询个数int sum[M &lt;&lt; 5];///区间valint rt[M];///根节点标号int lc[M &lt;&lt; 5], rc[M &lt;&lt; 5];///当前结点左右子节点标号int a[M], b[M];///原序列和离散序列int p;///待修改点///引用版初始化 amazing! Identical with the old way.void build(int &amp; now, int l, int r)///通过引用，为传入的变量赋值{    now = ++node_cnt;    if(l == r)        return;    int mid = (l + r) &gt;&gt; 1;    build(lc[now], l, mid);    build(rc[now], mid + 1, r);}int Build(int l, int r)///非引用版初始化{    int now = ++node_cnt;    if(l &lt; r)    {        int mid = (l + r) &gt;&gt; 1;        lc[now] = Build(l, mid);        rc[now] = Build(mid + 1, r);    }    return now;}///单点修改int modify(int now, int l, int r)///返回新的根节点标号{    int nxt = ++node_cnt;    ///&quot;指向&quot; 原先的标号    lc[nxt] = lc[now];    rc[nxt] = rc[now];    sum[nxt] = sum[now] + 1;    if(l == r)///单点修改的终点        return nxt;    int mid = (l + r) &gt;&gt; 1;    if(p &lt;= mid)        lc[nxt] = modify(lc[nxt], l, mid);    else        rc[nxt] = modify(rc[nxt], mid + 1, r);    return nxt;}///u -&gt; node of l - 1///v -&gt; node of rint query(int u, int v, int l, int r, int k)///反回相应叶子节点标号{    int ans, mid = ((l + r) &gt;&gt; 1);    int x = sum[lc[v]] - sum[lc[u]];///左孩子比右孩子更单纯    if(l == r)        return l;    if(k &lt;= x)        ans = query(lc[u], lc[v], l, mid, k);    else        ans = query(rc[u], rc[v], mid + 1, r, k-x);    return ans;}int main(){    int t, l, r, k, q, ans;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i];        sort(b + 1, b + n + 1);        q = unique(b + 1, b + n + 1) - (b + 1);        node_cnt = 0;        build(rt[0], 1, q);        for(int i = 1; i &lt;= n; ++i)        {            p = lower_bound(b + 1, b + q + 1, a[i]) - b;            rt[i] = modify(rt[i - 1], 1, q);        }        while(m--)        {            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);            ans = query(rt[l - 1], rt[r], 1, q, k);            printf(&quot;%d\n&quot;, b[ans]);        }    }    return 0;}</code></pre><h2 id="Something-I-want-to-say"><a href="#Something-I-want-to-say" class="headerlink" title="Something I want to say"></a>Something I want to say</h2><blockquote><p>主席树：以线段树为结构单元的前缀和序列</p><p>其体现的有关<strong>前缀和</strong>的特点：</p><ol><li>以(前值)旧值更新(后值)新值</li><li>后值减(前值-1)代表中间区间的值</li></ol><p>code中建树函数build用到了<strong>引用</strong>(也有非引用版)</p><p>引用：给变量一个新名字，喊着他的新名字让他去做事等效于喊他原来的名字让他去做事</p><p>为什么不能一直喊他原名字呢？当他处于不同的空间需要有不同的名字以区分</p><p>引用常常用在递归中，往往是深层递归中他得到一个值，使得前一层的他有了同样的值</p><p>主席树每棵节点保存的是一颗线段树，(时空两方面)维护的区间相同，结构相同，保存的信息不同，因此具有了加减性(前缀和性质)</p></blockquote><h3 id="别名：可持久化线段树"><a href="#别名：可持久化线段树" class="headerlink" title="别名：可持久化线段树"></a>别名：可持久化线段树</h3><blockquote><p>可持久化，后一刻可以参考前一刻的状态，二者共同部分很多</p><p>一颗线段树的节点维护的是当前节点对应区间的信息</p><p>倘若每次区间都不一样，就会给处理带来一些困难</p><p>有时可以直接细分区间然后合并，此种情况线段树可以直接搞定</p><p>但有时无法通过直接划分区间来求解，如频繁询问区间第k小元素</p><p> 这时便需要用可持久化线段树</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の主席树 </tag>
            
            <tag> 计算几何の离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python爬取SDNUOJ两用户Solved problems查找遗漏的水题</title>
      <link href="2019/08/10/Python%E7%88%AC%E5%8F%96SDNUOJ%E4%B8%A4%E7%94%A8%E6%88%B7Solved-problems%E6%9F%A5%E6%89%BE%E9%81%97%E6%BC%8F%E7%9A%84%E6%B0%B4%E9%A2%98/"/>
      <url>2019/08/10/Python%E7%88%AC%E5%8F%96SDNUOJ%E4%B8%A4%E7%94%A8%E6%88%B7Solved-problems%E6%9F%A5%E6%89%BE%E9%81%97%E6%BC%8F%E7%9A%84%E6%B0%B4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>输入用户名，爬取SDNUOJ指定用户Information页面Solved Problems题号，通过对比，输出对方已解决而自己尚未解决的题目的题号</p><p>可执行文件下载链接：<a href="https://github.com/fireworks99/Tools/raw/master/OJ_compare_sloved.exe" target="_blank" rel="noopener">https://github.com/fireworks99/Tools/raw/master/OJ_compare_sloved.exe</a></p></blockquote><a id="more"></a><h2 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h2><blockquote><p>感谢LTR师哥( <a href="https://blog.csdn.net/ltrbless" target="_blank" rel="noopener">https://blog.csdn.net/ltrbless</a> )耐心指导，拿出自己珍贵的大把的时间悉心为我讲解细节，在我求“鱼”之时授我以“当下之鱼”及“来日之渔”</p><p>题目做腻了的时候看了看爬虫入门的东西，偶然想起某天MF(YMF <a href="https://solodance.top/" target="_blank" rel="noopener">https://solodance.top/</a> )与旁人闲聊时提到这个（爬取两用户Information比较得出自己遗漏的水题）有趣的东西，想着自己也试试。在此说明原Idea来自于他。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-python">import urllib.requestfrom bs4 import BeautifulSoupfro = &#39;http://www.acmicpc.sdnu.edu.cn/user/info/&#39;print(&quot;Please input your Username:&quot;)my_url = input()my_url = fro + my_urlprint(&quot;Please input his or her Username:&quot;)its_url = input()its_url = fro + its_url# print(my_url)# print(its_url)my_res = &quot;&quot;its_res = &quot;&quot;# 获得html文档try:    my_res = urllib.request.urlopen(my_url)    its_res = urllib.request.urlopen(its_url)except Exception as e:    print(e)if my_res is &quot;&quot;:    print(&quot;Your Username is wrong&quot;)elif its_res is &quot;&quot;:    print(&quot;His or her Username is wrong&quot;)else:    # print(my_res.getcode())    # print(its_res.getcode())    # 创建BeautifulSoup对象    my_bs = BeautifulSoup(my_res, features=&#39;html.parser&#39;, from_encoding=&#39;utf-8&#39;)    its_bs = BeautifulSoup(its_res, features=&#39;html.parser&#39;, from_encoding=&#39;utf-8&#39;)    # 找到所有 标签为&quot;div&quot;,class_ 属性为&quot;row&quot;的内容,返回一个列表    my_list = my_bs.find_all(&quot;div&quot;, class_=&quot;row&quot;)    its_list = its_bs.find_all(&quot;div&quot;, class_=&quot;row&quot;)    # print(my_list[4]) # 共七个元素，我们发现第五个是我们想要的,它本身是一个标签(Tag)    # print(type(my_list))    # print(type(my_list[4]))    # 将该标签通过str强转为字符串作为文本，再次构建一个BeautifulSoup对象    # my_soup = BeautifulSoup(unicode(my_list[4]), features=&#39;html.parser&#39;) # py2 -&gt; unicode / py3 -&gt; str    my_soup = BeautifulSoup(str(my_list[4]), features=&#39;html.parser&#39;)    its_soup = BeautifulSoup(str(its_list[4]), features=&#39;html.parser&#39;)    # 在此范围内查找所有的&#39;a&#39;标签，即链接    my_soup = my_soup.find_all(&#39;a&#39;)    its_soup = its_soup.find_all(&#39;a&#39;)    # print(my_soup.find_all(&#39;a&#39;))    # 用  .string  取出其中的NavigableString（可操纵字符串）对象，即已通过题目的题号,生成列表    my_sloved = []    for i in my_soup:        my_sloved.append(i.string)    its_sloved = []    for i in its_soup:        its_sloved.append(i.string)    for i in its_sloved:        if i not in my_sloved:            print(i)        else:            continue    print(&quot;No more!&quot;)</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><blockquote><ol><li><p>确定所爬 url：<a href="http://www.acmicpc.sdnu.edu.cn/user/info/" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/user/info/</a></p></li><li><p>审查元素</p><p><img src="https://i.postimg.cc/43qMCN6t/ZW10-FD6-ZDFF18-TD-9-H.png" alt="example"></p></li><li><p>鼠标指着某段代码会出现相应模块，我们当前指向即为所需部分(Solved Problems)</p></li><li><p>发现其Tag(标签)为”div”,class_属性为”row”</p><p>find_all所有这样的内容，返回一个my_list列表</p></li><li><p>其中第5个元素，即my_list[4]是我们想要的Solved模块，将其转为字符串文本，创建为一个新的BeautifulSoup对象</p></li><li><p>对新对象find_all(‘a’)，标签a为“链接类”标签</p><p><code>&lt;a href=&quot;/status/list?name=2018zhaobaole&amp;amp;pid=1025&amp;amp;type=10&quot;&gt;1025&lt;/a&gt;</code></p></li><li><p>后面的1025属于NavigableString(可操纵字符串)对象，可以通过<code>.string</code>直接访问</p></li><li><p>不懂的语法、函数去官方文档(BeautifulSoup4.2.0文档)找</p><p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="noopener">https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html</a></p></li><li><p>更多内容详见code</p></li></ol></blockquote><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><blockquote><p>使用上述代码时需要保证该Python Project中有beautifulsoup4解释器</p><p>pycharm如何安装beautifulsoup4：<a href="https://blog.csdn.net/huatian5/article/details/74502687" target="_blank" rel="noopener">https://blog.csdn.net/huatian5/article/details/74502687</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA 10480 Sabotage(最小割)</title>
      <link href="2019/08/09/UVA-10480-Sabotage-%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
      <url>2019/08/09/UVA-10480-Sabotage-%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个城市，M条连接城市的边，现在要切断城市1与城市2间的联络，求最小费用</p></blockquote><a id="more"></a><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><blockquote><p>一般的网络流知道了S(源点)T(汇点)，就默认了流向，所以路是单向的(两条边,w+0)</p><p>但这题不同，两城市是等价的，都是S都是T，所以路是双向的(两条边,w+w)</p><p>若是已知<strong>唯一</strong>的S(源点)T(汇点)，而题目又暗示(或明示)路是双向的(四条边w+0+w+0)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);const int N = 805;ll n, m, maxflow, deep[N], u[N], v[N];struct edge{    ll to, w, pre;} a[200005];int cnt = -1;ll head[N], start, over, q[N], fro, bac;///网络流中的单向边实际是添加两条边的///那么双向边对应实际添加四条边void add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].pre = head[from];    a[cnt].w = w;    head[from] = cnt;    a[++cnt].to = from;    a[cnt].pre = head[to];    a[cnt].w = w;    head[to] = cnt;}bool bfs(){    memset(deep, -1, sizeof(deep));    fro = bac = 0;    q[bac++] = start, deep[start] = 0;    while(fro &lt; bac)    {        ll first = q[fro++];        for(int i = head[first]; i != -1; i = a[i].pre)        {            ll v = a[i].to;            if(deep[v] &lt; 0 &amp;&amp; a[i].w &gt; 0)            {                deep[v] = deep[first] + 1;                q[bac++] = v;            }        }    }    return deep[over] &gt; 0;}ll DFS(ll s, ll cap){    if(s == over)        return cap;    ll f;    for(int i = head[s]; i != -1; i = a[i].pre)    {        ll to = a[i].to;        if(a[i].w &gt; 0 &amp;&amp; deep[to] == deep[s] + 1 &amp;&amp; (f = DFS(to, min(cap, a[i].w))) )        {            a[i].w -= f;            a[i ^ 1].w += f;            return f;        }    }    deep[s] = -1;    return 0;}void Dinic(){    ll temp;    while(bfs())        while((temp = DFS(start, INF)) &gt; 0)            maxflow += temp;}int main(){    while(~scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m))    {        if(n == 0 &amp;&amp; m == 0)            break;        ll cost;        start = 1, over = 2;        memset(head, -1, sizeof(head));        memset(u, 0, sizeof(u));        memset(v, 0, sizeof(v));        cnt = -1, maxflow = 0;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%lld%lld%lld&quot;, &amp;u[i], &amp;v[i], &amp;cost);            add(u[i], v[i], cost);        }        Dinic();        for(int i = 0; i &lt; m; ++i)        {            if((deep[ u[i] ] &lt; 0 &amp;&amp; deep[ v[i] ] &gt;= 0)                || (deep[ v[i] ] &lt; 0 &amp;&amp; deep[ u[i] ] &gt;= 0))                cout &lt;&lt; u[i] &lt;&lt; &#39; &#39; &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;;        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4289 Control(最小割)</title>
      <link href="2019/08/09/HDU-4289-Control-%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>2019/08/09/HDU-4289-Control-%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>道家学派的创始人老子认为<strong>一切事物都</strong>包含<strong>有</strong>和无、难和易、长和短、高和下、前和后等<strong>对立面，对立的双方能够相互转化</strong> </p></blockquote><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>某位妹妹要从S到T运输偷来的心，我们可以在某些途径城市安装监控以逮捕她。每个城市安装监控的费用不同，要保证逮捕到这位妹妹，<del>你被逮捕了，罪名:XXXX(某音刷多了)</del> ，安装监控的最少花费是多少？</p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>看上去像是要求一个连通图的割点，使得S到T不连通，可并没有体现“最”这一特点，完全是固定的一种方案。(而且S、T不属于割点，而此题可以监控S、T)</p><p>而我们知道，在一个已知S、T的网络图中，求完最大流的残余网络S到T不连通，符合题意。可题目求“最小”，奈何等于求“最大”？</p><p>老子认为：一切事物都有对立面，对立的双方可以互相转化。</p><p>我们知道，一条S到T的可行流的<strong>最大</strong>值，<strong>是</strong>这条路上容量<strong>最小</strong>边的容量</p><p>所以，最大即最小，最小即最大。</p><p>将原题中费用转为容量。求出最大流，便封锁了S到T的所有路。而这最大流，是各可行流中最小容量的和，即最小费用。</p><p>以上理解也可以作为(最大流 == 最小割)的理解,所以这题其实是在求最小割?(滑稽)</p><p>感性认识：</p><ol><li>假设最开始可行流就一条，那么最大流便是这条可行流上容量最小的边的容量，套到题目上，便是花费最少的监控所花费的金钱(即最小花费)</li><li>两条可行流、n条可行流也是这种情况</li></ol></blockquote><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><blockquote><p>这道题就是求最小割！使S到T不连通！瞎分析一顿，看别人说最大流就使劲往上套，试图说服自己……只不过最小割与最大流相等而已……仿佛给自己解释了一遍为什么最大流等于最小割</p></blockquote><h2 id="something"><a href="#something" class="headerlink" title="something"></a>something</h2><blockquote><p>算法竞赛要求参赛者熟练掌握各算法、数据结构，那是基础，而这种建模思想却是在其上更为珍贵的、更为有趣的东西</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);const int N = 805;int n, m, maxflow, deep[N];struct edge{    int to, w, pre;} a[200005];int cnt = -1;int head[N], start, over, q[N], fro, bac;///网络流中的单向边实际是添加两条边的///那么双向边对应实际添加四条边void add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].pre = head[from];    a[cnt].w = w;    head[from] = cnt;    a[++cnt].to = from;    a[cnt].pre = head[to];    a[cnt].w = 0;    head[to] = cnt;}bool bfs(){    memset(deep, -1, sizeof(deep));    fro = bac = 0;    q[bac++] = start, deep[start] = 0;    while(fro &lt; bac)    {        int first = q[fro++];        for(int i = head[first]; i != -1; i = a[i].pre)        {            int v = a[i].to;            if(deep[v] &lt; 0 &amp;&amp; a[i].w &gt; 0)            {                deep[v] = deep[first] + 1;                q[bac++] = v;            }        }    }    return deep[over] &gt; 0;}int DFS(int s, int cap){    if(s == over)        return cap;    int f;    for(int i = head[s]; i != -1; i = a[i].pre)    {        int to = a[i].to;        if(a[i].w &gt; 0 &amp;&amp; deep[to] == deep[s] + 1 &amp;&amp;(f = DFS(to, min(cap, a[i].w))) )        {            a[i].w -= f;            a[i ^ 1].w += f;            return f;        }    }    deep[s] = -1;    return 0;}void Dinic(){    int temp;    while(bfs())        while((temp = DFS(start, INF)) &gt; 0)            maxflow += temp;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        int cost, u, v;        memset(head, -1, sizeof(head));        cnt = -1, maxflow = 0;        scanf(&quot;%d%d&quot;, &amp;start, &amp;over);///真起点与伪终点        over += n;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;cost);            add(i, i + n, cost);        }        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            add(u + n, v, INF);            add(v + n, u, INF);        }        Dinic();        cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>图论一顿套模板，只把main函数里输入添边改一下就行……</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2212 打表</title>
      <link href="2019/08/08/HDU-2212-%E6%89%93%E8%A1%A8/"/>
      <url>2019/08/08/HDU-2212-%E6%89%93%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>int范围内找出：各位数字的阶乘和等于原数字的数</p></blockquote><a id="more"></a><h2 id="暴力打表"><a href="#暴力打表" class="headerlink" title="暴力打表"></a>暴力打表</h2><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);void Debug(char * s){    cout &lt;&lt; &quot;-------------  &quot; &lt;&lt; s &lt;&lt; &quot;  -------------&quot; &lt;&lt; &#39;\n&#39;;}ll fac[20];void get_fac(){    fac[0] = 1;    for(int i = 1; i &lt;= 12; ++i)        fac[i] = fac[i - 1] * i;}bool check(ll n){    int tem = n;    ll res = 0;    while(tem)    {        res += fac[tem % 10];        tem /= 10;    }    if(res == n)        return 1;    return 0;}int main(){    freopen(&quot;00out.txt&quot;, &quot;w&quot;, stdout);    get_fac();    for(ll i = 1; i &lt;= 2147483647; ++i)        if(check(i))            cout &lt;&lt; i &lt;&lt; &#39;,&#39;;    return 0;}</code></pre><blockquote><p>定向输出到文件中</p></blockquote><p><img src="https://i.postimg.cc/zv7wgDGc/NC-FIS2-PM-M7-X4-S-0-3-3-S.png" alt="time"></p><p><img src="https://i.postimg.cc/Dw8QSTkx/4-OTFM-GU-SHD-UVB-47-DL.png" alt="output"></p><blockquote><p>当输出数据量较大时这种方法更为合适</p><p>将数据复制下来粘贴到新程序的数组里</p><p>复制时去掉最后的那个逗号</p></blockquote><h3 id="new-code"><a href="#new-code" class="headerlink" title="new code"></a>new code</h3><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;int a[] = {1,2,145,40585};///去掉最后一个逗号int main(){    int sz = sizeof(a) / sizeof(int);    for(int i = 0; i &lt; sz; ++i)        cout &lt;&lt; a[i] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の暴力打表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LightOJ 1234 Harmonic Number调和数</title>
      <link href="2019/08/08/LightOJ-1234-Harmonic-Number%E8%B0%83%E5%92%8C%E6%95%B0/"/>
      <url>2019/08/08/LightOJ-1234-Harmonic-Number%E8%B0%83%E5%92%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p><img src="https://i.postimg.cc/28JbXLMx/AS-ZS5-HHMF-Y5-G7-ZLE-DR-F.png" alt="Harmonic Number"></p></blockquote><a id="more"></a><blockquote><p>欧拉给出了Harmonic数近似公式(n较大时)：</p><p><strong>f(n) ≈ ln(n) + 1.0 / (2 * n) + C</strong> </p><p>其中C为欧拉常数约等于0.57721566490153286060651209 </p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;const double Euler = 0.57721566490153286060651209;#define Close ios::sync_with_stdio(false);double a[10005];int main(){    for(int i = 1; i &lt;= 10000; ++i)        a[i] = a[i - 1] + 1.0 / i;    int t, n, cnt = 1;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        if(n &lt;= 10000)            printf(&quot;Case %d: %.10f\n&quot;, cnt++, a[n]);        else        {            double ans = log(n) + 1.0 / (2 * n) + Euler;            printf(&quot;Case %d: %.10f\n&quot;, cnt++, ans);        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4292 Food(最大流再优化?)</title>
      <link href="2019/08/08/HDU-4292-Food-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%86%8D%E4%BC%98%E5%8C%96/"/>
      <url>2019/08/08/HDU-4292-Food-%E6%9C%80%E5%A4%A7%E6%B5%81%E5%86%8D%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>与POJ 3281 Dining相似，人、食物、饮料，不同的是现在食物、饮料数目不止一份</p></blockquote><a id="more"></a><blockquote><p>最大流建图：</p><ol><li>人 拆点(每人匹配一食物一饮料)</li><li>食物与人之间的容量设为1或INF都行</li></ol></blockquote><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote><ol><li>字符串用<code>scanf(&quot;%s&quot;, str)</code>比循环getchar快？</li><li>main函数调用其他函数耗时？add里写两份</li><li>BFS出口改了……</li><li>DFS形式改了，添加了一句<code>deep[s] = -1;</code></li><li>犯的大错误：<img src="https://i.postimg.cc/G28XRK4M/UTHIIFDK9-WFJMOW-H-FZJD.png" alt="bug"></li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);const int N = 805;int nn, ff, dd, maxflow, deep[N];struct edge{    int to, w, pre;} a[200005];int cnt = -1;int head[N], start, over, q[N], fro, bac;void add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].pre = head[from];    a[cnt].w = w;    head[from] = cnt;    a[++cnt].to = from;    a[cnt].pre = head[to];    a[cnt].w = 0;    head[to] = cnt;}bool bfs(){    memset(deep, -1, sizeof(deep));    fro = bac = 0;    q[bac++] = start, deep[start] = 0;    while(fro &lt; bac)    {        int first = q[fro++];//        if(first == over)//            return true;        for(int i = head[first]; i != -1; i = a[i].pre)        {            int v = a[i].to;            if(deep[v] &lt; 0 &amp;&amp; a[i].w &gt; 0)            {                deep[v] = deep[first] + 1;                q[bac++] = v;            }        }    }//    return false;    return deep[over] &gt; 0;}int DFS(int s, int cap){    if(s == over)        return cap;    int f;    for(int i = head[s]; i != -1; i = a[i].pre)    {        int to = a[i].to;        if(a[i].w &gt; 0 &amp;&amp; deep[to] == deep[s] + 1 &amp;&amp;                    (f = DFS(to, min(cap, a[i].w))) )        {            a[i].w -= f;            a[i ^ 1].w += f;            return f;        }    }    deep[s] = -1;    return 0;}void Dinic(){    int temp;    while(bfs())        while((temp = DFS(start, INF)) &gt; 0)            maxflow += temp;}int main(){    while(scanf(&quot;%d%d%d&quot;, &amp;nn, &amp;ff, &amp;dd) != EOF)    {        memset(head, -1, sizeof(head));        int tem;        cnt = -1, maxflow = start = 0;        over = 1 + dd + 2 * nn + ff;        for(int i = 1; i &lt;= ff; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            add(start, i, tem);        }        for(int i = 1; i &lt;= nn; ++i)            add(i + ff, i + nn + ff, 1);        for(int i = 1; i &lt;= dd; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            add(i + 2 * nn + ff, over, tem);        }        char str[805];        for(int i = 1; i &lt;= nn; ++i)        {            scanf(&quot;%s&quot;, str);            for(int j = 0; j &lt; ff; ++j)                if(str[j] == &#39;Y&#39;)                    add(j + 1, i + ff, 1);        }        for(int i = 1; i &lt;= nn; ++i)        {            scanf(&quot;%s&quot;, str);            for(int j = 0; j &lt; dd; ++j)                if(str[j] == &#39;Y&#39;)                    add(i + nn + ff, j + 1 + 2 * nn + ff, 1);        }        Dinic();        cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4280 ISland Transport(最大流Dinic优化)</title>
      <link href="2019/08/08/HDU-4280-ISland-Transport-%E6%9C%80%E5%A4%A7%E6%B5%81DInic%E4%BC%98%E5%8C%96/"/>
      <url>2019/08/08/HDU-4280-ISland-Transport-%E6%9C%80%E5%A4%A7%E6%B5%81DInic%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>T组样例，n点，m条双向边(独特，网络流多为单向边+反向边),输入n个点的坐标，找出从最左边的点到最右边的点的最大流</p></blockquote><a id="more"></a><h2 id="最大流模板题（卡超时）"><a href="#最大流模板题（卡超时）" class="headerlink" title="最大流模板题（卡超时）"></a>最大流模板题（卡超时）</h2><blockquote><p>用Dinic的话：</p><ol><li>数组开的够大，注意边的数目不同于点的数目</li><li>BFS里的queue改用数组模拟（STL耗时）</li><li>DFS采用“无cut[]”写法+flow == 0封锁优化</li><li>tem = DFS &gt; 0时才加到答案里，等于0时不加</li><li>多组输入cnt(边的计数器)一定要初始化，否则越攒越多TLE</li></ol></blockquote><h3 id="Code-Dinic略优化"><a href="#Code-Dinic略优化" class="headerlink" title="Code(Dinic略优化)"></a>Code(Dinic略优化)</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;const int INF = 0x3f3f3f3f;typedef long long ll;int n, m, start, over;int maxflow, deep[N];///deep深度struct Edge{    int to, w, pre;} a[N &lt;&lt; 2];//int cur[N];int cnt = -1, head[N];///cnt in this way can save the time///我也试过cnt初始化为0，最后加个++cnt，但TLEvoid add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;}///数组模拟队列bool bfs()///update deep[]{//    memset(deep, INF, sizeof(deep));    memset(deep, -1, sizeof(deep));    int q[N &lt;&lt; 1];    int fro, bac;    fro = bac = 0;    q[bac++] = start, deep[start] = 0;    while(fro &lt; bac)    {        int first = q[fro];        if(first == over)            return true;        for(int i = head[first]; ~i; i = a[i].pre)        {            if(deep[ a[i].to ] == -1 &amp;&amp; a[i].w &gt; 0)            {                deep[ a[i].to ] = deep[first] + 1;                q[bac++] = a[i].to;            }        }        fro++;    }    return false;}///没有用cur[]数组......int DFS(int s, int cap){    if(s == over)        return cap;    int flow = 0, f;    for(int i = head[s]; ~i; i = a[i].pre)    {        int to = a[i].to;        if(deep[to] == deep[s] + 1 &amp;&amp; a[i].w)        {            f = DFS(to, min(cap - flow, a[i].w));            a[i].w -= f;            a[i ^ 1].w += f;            flow += f;            if(flow == cap)                break;        }    }    ///TLE -&gt; AC    if(flow == 0)///某层DFS里某个flow为0        deep[s] = -2;///封锁这个flow，避免无用的重复搜索    return flow;}void Dinic(){    int tem = 0;    while(bfs())        while((tem = DFS(start, INF) )&gt; 0)            maxflow += tem;///不直接+DFS,可优化200ms}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        ///TLE -&gt; AC        maxflow = 0, cnt = -1;///多组输入cnt不初始化固然TLE        memset(head, -1, sizeof(head));        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        start = over = 1;        int x, y, z, x_min = INF, x_max = -INF;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);            if(x &lt; x_min)                start = i, x_min = x;            if(x &gt; x_max)                over = i, x_max = x;        }        for(int i = 1; i &lt;= m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);            add(x, y, z);            add(y, x, z);///双向边的网络流(网络流通常单向边)        }        Dinic();        cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LightOJ 1245 Harmonic Number调和数</title>
      <link href="2019/08/07/LightOJ-1245-Harmonic-Number%E8%B0%83%E5%92%8C%E6%95%B0/"/>
      <url>2019/08/07/LightOJ-1245-Harmonic-Number%E8%B0%83%E5%92%8C%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>计算</p></blockquote><p><img src="https://i.postimg.cc/W3Md9G8b/B1-O34-GBXGJJD6-H5-U0-B-EQK.png" alt="Harmonic Number"></p><a id="more"></a><blockquote><p>画图，画出函数图像：y = n/x，以 y = x对称(以n == 5为例)</p></blockquote><p><img src="https://i.postimg.cc/KvgS6Fbt/9-WW-V8-UI5-R-P3-G-CK.png" alt="y = 5 / x"></p><blockquote><p>可以用 横坐标表示i 从该点画一条垂直的线</p><p>这条线上的所有整数点的个数就是 n / i</p><p>那么n / 1 + n / 2 + n / 3 + …… n / (n-2) + n / (n-1) + n / n </p><p>可以表示为方程的曲线与坐标轴围成的面积内的整数点的个数</p><p>对称，求左边梯形内点数，乘2减去重叠的那部分</p><p>部分原文链接：<a href="https://blog.csdn.net/weixin_43237242/article/details/88780203" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43237242/article/details/88780203</a></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">int main(){    int t, n, cnt = 1;;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        ll ans = 0;        int tem = sqrt(n);        for(int i = 1; i &lt;= tem; ++i)            ans += n / i;        ans &lt;&lt;= 1;        ans -= tem * tem;        printf(&quot;Case %d: %lld\n&quot;, cnt++, ans);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3281 Dining(最大流最小割)</title>
      <link href="2019/08/07/POJ-3281-Dining-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
      <url>2019/08/07/POJ-3281-Dining-%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>农夫为他的 N (1 ≤ N ≤ 100) 牛准备了 F (1 ≤ F ≤ 100)种食物和 D (1 ≤ D ≤ 100) 种饮料。每头牛都有各自喜欢的食物和饮料，而每种食物或饮料只能分配给一头牛。最多能有多少头牛可以同时得到喜欢的食物和饮料？</p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>不可以二分图匹配，因为牛要匹配两种东西，求其跟每种东西的最大匹配，取交集也不是，取并集也不是，需建模用最大流解决</p><ol><li><p>多源点、多汇点要建立超源点、超汇点</p></li><li><p>牛置于中间，左放食物右放饮料（或反过来）</p></li><li><p>连线权值为1，求最大流即答案</p><p>要注意：中间的牛要拆点</p></li></ol></blockquote><h2 id="关于拆点"><a href="#关于拆点" class="headerlink" title="关于拆点"></a>关于拆点</h2><p><img src="https://i.postimg.cc/k5rkV8S2/W8-4-YM-D6-O0-TE3-NZF1-2.png" alt="不拆点的弊端"></p><blockquote><p>很明显,一头牛同时匹配了多种食物饮料,最大流是2,但答案是1(只满足了一头牛)</p></blockquote><p><img src="https://i.postimg.cc/3Nds0HKB/DY3-YH-O-F3-H-2-CZ8-B.png" alt="拆点的好处"></p><blockquote><p>限流：限制流经每头牛的流量最大为1</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);void Debug(char * s){    cout &lt;&lt; &quot;-------------  &quot; &lt;&lt; s &lt;&lt; &quot;  -------------&quot; &lt;&lt; &#39;\n&#39;;}const int N = 1005;int n;///网络流中最重要的是建模构图，其中全局变量总点数n要计算清楚int maxflow, deep[N];struct edge{    int from, to, w, pre;} a[N * N];queue&lt;int&gt; q;int cnt = -1;int head[N], cur[N];void add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].from = from;    a[cnt].pre = head[from];    a[cnt].w = w;    head[from] = cnt;}bool bfs(int s, int t){    memset(deep, INF, sizeof(deep));    while(!q.empty())        q.pop();    for(int i = 0; i &lt;= n; ++i)        cur[i] = head[i];    deep[s] = 0;    q.push(s);    while(!q.empty())    {        int first = q.front();        q.pop();        for(int i = head[first]; ~i; i = a[i].pre)        {            if(deep[ a[i].to ] == INF &amp;&amp; a[i].w)///w在此处用来做标记 是正图还是返图            {                deep[ a[i].to ] = deep[first] + 1;                q.push(a[i].to);            }        }    }    if(deep[t] &lt; INF)        return 1;    return 0;}int dfs(int now, int t, int limit){    if(!limit || now == t)        return limit;    int flow = 0, f;    for(int i = cur[now]; ~i; i = a[i].pre)    {        cur[now] = i;        if(deep[ a[i].to ] == deep[now] + 1)            if(f = dfs(a[i].to, t, min(limit, a[i].w)))            {                flow += f;                limit -= f;                a[i].w -= f;                a[i ^ 1].w += f;                if(!limit)                    break;            }    }    return flow;}///bfs分层，dfs增广、处理残余网络、反向边void Dinic(int s, int t){    int temp;    while(bfs(s, t))    {        while((temp = dfs(s, t, INF)) &gt; 0)            maxflow += temp;    }}int main(){    memset(head, -1, sizeof(head));    int nn, ff, dd;    scanf(&quot;%d%d%d&quot;, &amp;nn, &amp;ff, &amp;dd);    n = 2 * nn + ff + dd + 2;    for(int i = 1; i &lt;= ff; ++i)    {        add(0, i, 1);        add(i, 0, 0);    }    for(int i = 1; i &lt;= dd; ++i)    {        add(i + 2 * nn + ff, 1 + dd + 2 * nn + ff, 1);        add(1 + dd + 2 * nn + ff, i + 2 * nn + ff, 0);    }    int num_f = 0, num_d = 0, idx = 0;    for(int i = 1; i &lt;= nn; ++i)    {        scanf(&quot;%d%d&quot;, &amp;num_f, &amp;num_d);        for(int j = 1; j &lt;= num_f; ++j)        {            scanf(&quot;%d&quot;, &amp;idx);            add(idx, i + ff, 1);            add(i + ff, idx, 0);        }        for(int j = 1; j &lt;= num_d; ++j)        {            scanf(&quot;%d&quot;, &amp;idx);            add(i + nn + ff, idx + 2 * nn + ff, 1);            add(idx + 2 * nn + ff, i + nn + ff, 0);        }        add(i + ff, i + nn + ff, 1);        add(i + nn + ff, i + ff, 0);    }    Dinic(0, 1 + dd + 2 * nn + ff);    cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><ol><li><p>n（总点数）的计算出错了</p></li><li><p>添边时超级源点0写成了1</p></li><li><p>i为序号写成了idx(idx在其他地方做过序号)</p><p>所以要分清“同类”</p></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2516 Minimum Cost(最小费用最大流)</title>
      <link href="2019/08/07/POJ-2516-Minimum-Cost-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>2019/08/07/POJ-2516-Minimum-Cost-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>N个买家，M个卖家，K种货物</p><p>接下来N行，每行K个数值，表示每个买家对于K种货物的需求</p><p>接下来M行，每行K个数值，表示每个卖家对于K种货物的拥有量</p><p>接下来K个矩阵，每个矩阵代表那种货物的有关运输费用</p><p>(第k个矩阵第i行第j列的数值,表示第j个卖家运输单位第k种货物到第i个买家的费用)</p></blockquote><a id="more"></a><blockquote><p>题目链接：<a href="http://poj.org/problem?id=2516" target="_blank" rel="noopener">http://poj.org/problem?id=2516</a> （题目老是AC不了怎么办-&gt;去Discuss区看看，我就是不知怎么WA的，去讨论区看，说数组开小了给WA，我开大一些还真AC了，什么鬼……）</p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>K种货物分别分析</p><p>多源点多汇点-&gt;建立超级源点与超级汇点</p><p>连接超源到各卖家的路，费用0，容量等于卖家货物量</p><p>连接超汇到各买家的路，费用0，容量等于买家需求量</p><p>连接卖家与买家间的路，费用对应题目中的费用，容量INF</p><p>在可行的前提下，最小费用最大流，原来是最小费用固定流，因为买家到超汇的容量被设为需求量，所以直接求最大流即为该固定流</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;const int N = 305;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;typedef long long ll;void Debug(char * s){    cout &lt;&lt; &quot;-------------  &quot; &lt;&lt; s &lt;&lt; &quot;  -------------&quot; &lt;&lt; &#39;\n&#39;;}int A, B, C;int n, m;struct edge{    int to, w, cap, rev;};vector&lt;edge&gt; vec[N];int h[N], dis[N];int fro_v[N], fro_e[N];int t[105][105], s[105][105], cost[55][305][305];int tt[105], ss[105];void add(int from, int to, int w, int cap){    int from_sz = vec[from].size(), to_sz = vec[to].size();    vec[from].push_back( (edge)    {        to, w, cap, to_sz    } );    vec[to].push_back( (edge)    {        from, -w, 0, from_sz    } );}int min_cost_flow(int s, int t){    int flow = 0;    ll res = 0;    memset(h, 0, sizeof(h));    memset(fro_v, 0, sizeof(fro_v));    memset(fro_e, 0, sizeof(fro_e));    while(1)    {        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;        memset(dis, INF, sizeof(dis));        dis[s] = 0;        q.push(P(0, s));        while(!q.empty())        {            P now = q.top();            q.pop();            int to = now.second;            if(dis[to] &gt; now.first)                continue;            for(int i = 0; i &lt; vec[to].size(); ++i)            {                edge &amp; nxt = vec[to][i];                if(nxt.cap &gt; 0 &amp;&amp; dis[nxt.to] &gt; dis[to] + nxt.w + h[to] - h[nxt.to])                {                    dis[nxt.to] = dis[to] + nxt.w + h[to] - h[nxt.to];                    fro_v[nxt.to] = to;                    fro_e[nxt.to] = i;                    q.push(P(dis[nxt.to], nxt.to));                }            }        }        if(dis[t] == INF)            return res;        for(int v = 0; v &lt;= n; ++v)            h[v] += dis[v];        int d = INF;        for(int v = t; v != s; v = fro_v[v])            d = min(d, vec[fro_v[v] ][ fro_e[v] ].cap);        flow += d;        res += d * h[t];        for(int v = t; v != s; v = fro_v[v])        {            edge &amp; nxt = vec[ fro_v[v] ][ fro_e[v] ];            nxt.cap -= d;            vec[v][nxt.rev].cap += d;        }    }    return res;}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C))    {        n = A + B + 1;        ll ans = 0;        if(A == 0 &amp;&amp; B == 0 &amp;&amp; C == 0)            break;        memset(tt, 0, sizeof(tt));        memset(ss, 0, sizeof(ss));        memset(s, 0, sizeof(s));        memset(t, 0, sizeof(t));        memset(cost, 0, sizeof(cost));        ///循环赋值时,变量出现顺序 必须跟 欲赋值矩阵维度先后对应        for(int i = 1; i &lt;= A; ++i)            for(int j = 1; j &lt;= C; ++j)                scanf(&quot;%d&quot;, &amp;t[B + i][j]), tt[j] += t[B + i][j];        for(int i = 1; i &lt;= B; ++i)            for(int j = 1; j &lt;= C; ++j)                scanf(&quot;%d&quot;, &amp;s[i][j]), ss[j] += s[i][j];        for(int k = 1; k &lt;= C; ++k)            for(int i = 1; i &lt;= A; ++i)                for(int j = 1; j &lt;= B; ++j)                    scanf(&quot;%d&quot;, &amp;cost[k][B + i][j]);        bool flag = 1;        for(int k = 1; k &lt;= C; ++k)            if(tt[k] &gt; ss[k])            {                flag = 0;                puts(&quot;-1&quot;);                break;            }        if(!flag)            continue;        for(int i = 1; i &lt;= C; ++i)        {            for(int j = 0; j &lt; N; ++j)                vec[j].clear();            for(int j = 1; j &lt;= B; ++j)                add(0, j, 0, s[j][i]);            for(int j = 1; j &lt;= A; ++j)                add(B + j, B + A + 1, 0, t[B + j][i]);            for(int j = 1; j &lt;= B; ++j)                for(int l = 1; l &lt;= A; ++l)                    add(j, B + l, cost[i][B + l][j], INF);            int tem =  min_cost_flow(0, B + A + 1);            ans += tem;        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最小费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UOJ 117 欧拉回路(输出路径)</title>
      <link href="2019/08/05/UOJ-117-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/"/>
      <url>2019/08/05/UOJ-117-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E8%BE%93%E5%87%BA%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>一张无向图(或有向图),找出(若能找出)欧拉回路并输出路径。可能有重边、自环。</p></blockquote><a id="more"></a><blockquote><p>题目链接：<a href="http://uoj.ac/problem/117" target="_blank" rel="noopener">http://uoj.ac/problem/117</a></p></blockquote><h3 id="Code-代码赏析"><a href="#Code-代码赏析" class="headerlink" title="Code 代码赏析"></a>Code 代码赏析</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);#define Debug cout &lt;&lt; &quot;-----------------&quot; &lt;&lt; &#39;\n&#39;;const int N = 200010;int n, m, cnt, num_max;int ecnt = 1, head[N], pre[N * 2], to[N * 2];///链式前向星int in[N], out[N];int top, ans[N * 2];bool vis[N * 2];void add(int u, int v){    ecnt++;    pre[ecnt] = head[u];    head[u] = ecnt;    to[ecnt] = v;}void DFS(int now, bool flag){    for(int &amp; e = head[now]; e; e = pre[e])    {        if(vis[e])            continue;        cnt++;        vis[e] = 1;        if(flag)            vis[e ^ 1] = 1;        int t = e;        DFS(to[e], flag);        ans[++top] = t;    }}int main(){    int t, u, v;    scanf(&quot;%d&quot;, &amp;t);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        add(u, v);        in[v]++, out[u]++;        if(t == 1)            add(v, u), in[u]++, out[v]++;        num_max = max(num_max, max(u, v));    }    if(t == 1)    {        for(int i = 1; i &lt;= num_max; ++i)            if(in[i] &amp; 1)            {                puts(&quot;NO&quot;);                return 0;            }    }    if(t == 2)    {        for(int i = 1; i &lt;= num_max; ++i)            if(in[i] != out[i])                {                    puts(&quot;NO&quot;);                    return 0;                }    }    if(t == 1)        DFS(num_max, 1);    else        DFS(num_max, 0);    if(cnt == m)    {        puts(&quot;YES&quot;);        for(int i = top; i &gt;= 1; --i)        {            if(t == 2)                cout &lt;&lt; ans[i] - 1 &lt;&lt; &#39; &#39;;            else            {                if(ans[i] &amp; 1)                    putchar(&#39;-&#39;);                cout &lt;&lt; ans[i] / 2 &lt;&lt; &#39; &#39;;            }        }    }    else        puts(&quot;NO&quot;);    return 0;}</code></pre><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><blockquote><p>从main()函数开始解释：</p><ol><li><p>(非结构体)链式前向星添加边:</p><p>未参与排序的结构体是没有灵魂的(slow)，数组完全可以代替</p><p>ecnt计数(边数)：从2开始计数？</p><p>原因①：vis[e] 、vis[e ^ 1]这种方法规定边从偶数(0/2/4/etc)开始存</p><p>原因②：链式前向星遍历时以-1结束，此处不愿memset(-1)，便是以0结束，所以e == 0被占用作为循环结束标志，0不可用只能从2开始计数</p></li><li><p>添边的同时统计入度与出度：</p><p>对于存在欧拉回路的无向图：入度(==出度)不存在奇数</p><p>对于存在欧拉回路的有向图：每个点的入度必须等于出度</p></li><li><p>添边的同时记录出现过的最大的结点标号(num_max)？</p><p>题目给出数字n，代表有n个点，但不一定所有点都会被提及，所以num_max可以作为DFS入口。另外，测试每个点入度与出度是否合理的时候，num_max可以做遍历上限，省去不必要的遍历</p></li><li><p>DFS套圈法(cnt计数判连通)：</p><p>这里用了引用(&amp;)，通过改变head数组的值实现“边的删除”以保证O(E)的复杂度</p><p>用题解中的一句话来说：对于访问过的边不能直接打标记跳过(如果一直给自环那么dfs循环边就是n方)，但还是要标记的</p></li><li><p>输出答案：</p><p>对于有向图，输出边的编号减一，因为我们的边是从2开始存的，题目从1开始</p><p>对于无向图，若边的标号为偶数，便是题目所给的u到v的走法，若为奇数，则是我们添的从v到u的辅助边走法。因为题目给的一条边我们对应填了两条，所以要 / 2</p></li></ol></blockquote><p>受 <a href="https://blog.csdn.net/qq_35649707/article/details/75578102" target="_blank" rel="noopener">https://blog.csdn.net/qq_35649707/article/details/75578102</a> 启发</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论の欧拉路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>头文件</title>
      <link href="2019/08/05/A%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
      <url>2019/08/05/A%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;sstream&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define eps 1e-8#define PI acos(-1.0)#define ll long longusing namespace std;const int mod = 1e9 + 7;const int INF = 0x3f3f3f3f;#define Close ios::sync_with_stdio(false);void Debug(char * s){    cout &lt;&lt; &quot;-------------  &quot; &lt;&lt; s &lt;&lt; &quot;  -------------&quot; &lt;&lt; &#39;\n&#39;;}int main(){    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看清本质</title>
      <link href="2019/08/05/A%E7%9C%8B%E6%B8%85%E6%9C%AC%E8%B4%A8/"/>
      <url>2019/08/05/A%E7%9C%8B%E6%B8%85%E6%9C%AC%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一些本质性的东西"><a href="#一些本质性的东西" class="headerlink" title="一些本质性的东西"></a>一些本质性的东西</h2><blockquote><p>被封装起来的高级的数据结构是具有囊括性的，能应付多方面的问题。但如果只是用他的某一面，很可能这一需求可以由更低级、更基础的数据结构实现，这时再去用那个高级的数据结构便是没有灵魂的，那个低级、基础的数据结构更快更高效</p></blockquote><a id="more"></a><blockquote><ol><li>不参与排序、不作为一个整体存于STL中的结构体是没有灵魂的，多个数组（同下标一组）可以代替</li><li>BFS里对象类型为int的queue是没有灵魂的，数组+两个移动指针可以模拟</li><li>单纯的<code>map&lt;string, int&gt; mp</code>在时间方面是没有灵魂的，哈希可以代替，另外字典树(哈希树的变种)也可以更好地代替</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P3381 最小费用最大流(模板)</title>
      <link href="2019/08/03/%E6%B4%9B%E8%B0%B7-P3381-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%A8%A1%E6%9D%BF/"/>
      <url>2019/08/03/%E6%B4%9B%E8%B0%B7-P3381-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><blockquote><p>原来最小费用最大流只是在最小费用流的基础上去掉固定流f，任其找最短路去增广，直到不能找到最短路了(<code>dis[t] == INF</code>)就退出</p></blockquote><a id="more"></a><h3 id="洛谷P3381最小费用最大流"><a href="#洛谷P3381最小费用最大流" class="headerlink" title="洛谷P3381最小费用最大流"></a>洛谷P3381最小费用最大流</h3><p><img src="https://i.postimg.cc/rpxFY8t9/Z-NQ36-Y-8-GY2-E2-MP-EX1-W.png" alt="Dijkstra is also slow"></p><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;const int N = 5005;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;///first:最短距离 second:节点编号typedef long long ll;struct edge{ int to, w, cap, rev; };int n, m, s, t;ll flow, res;vector&lt;edge&gt; vec[N];int h[N], dis[N];///节点的势 最短距离int fro_v[N], fro_e[N];///vector 的 第一维和第二维///用于确定最短路中点k前面那条边void add(int from, int to, int w, int cap){    int from_sz = vec[from].size(), to_sz = vec[to].size();    vec[from].push_back( (edge){ to, w, cap, to_sz } );    vec[to].push_back( (edge){ from, -w, 0, from_sz } );}void min_cost_flow(int s, int t){    memset(h, 0, sizeof(h));    while(1)    {        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;        memset(dis, INF, sizeof(dis));        dis[s] = 0;        q.push(P(0, s));        while(!q.empty())        {            P now = q.top();            q.pop();            int to = now.second;            if(dis[to] &lt; now.first)                continue;            for(int i = 0; i &lt; vec[to].size(); ++i)            {                edge &amp; nxt = vec[to][i];                if(nxt.cap &gt; 0 &amp;&amp; dis[nxt.to] &gt; dis[to] + nxt.w + h[to] - h[nxt.to])                {                    dis[nxt.to] = dis[to] + nxt.w + h[to] - h[nxt.to];                    fro_v[nxt.to] = to;                    fro_e[nxt.to] = i;                    q.push(P(dis[nxt.to], nxt.to));                }            }        }        if(dis[t] == INF)            return ;        for(int v = 0; v &lt;= n; ++v)            h[v] += dis[v];        int d = INF;        for(int v = t; v != s; v = fro_v[v])            d = min(d, vec[ fro_v[v] ][ fro_e[v] ].cap);        flow += d;        res += d * h[t];///There is a h[t] in Dijkstra, not a dis[t](in Bellman_Ford).        for(int v = t; v != s; v = fro_v[v])///更新残余网络，建反向边        {            edge &amp; nxt = vec[ fro_v[v] ][ fro_e[v] ];            nxt.cap -= d;            vec[v][nxt.rev].cap += d;        }    }    return ;}int main(){    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t);    int ui, vi, wi, fi;    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d%d%d&quot;, &amp;ui, &amp;vi, &amp;wi, &amp;fi);        add(ui, vi, fi, wi);    }    min_cost_flow(s, t);    cout &lt;&lt; flow &lt;&lt; &#39; &#39; &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最小费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小费用流(沿Dijkstra最短路增广)</title>
      <link href="2019/08/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%B2%BFDijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%A2%9E%E5%B9%BF/"/>
      <url>2019/08/02/%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%B2%BFDijkstra%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%A2%9E%E5%B9%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="最小费用流"><a href="#最小费用流" class="headerlink" title="最小费用流"></a>最小费用流</h2><blockquote><p>最小费用流问题：</p><p>在最大流问题的网络中，给边新加上费用，求流量为f时费用的最小值</p></blockquote><a id="more"></a><blockquote><p>最大流：残余网络上<strong>贪心</strong>增广</p><p>最小费用流：残余网络上<strong>沿着最短路</strong>增广</p></blockquote><h2 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h2><blockquote><p>残余网络中反向边的权值是原边权值的相反数，意味着会有负权边，所以一般用Bellman_Ford求最短路。但它时间复杂度较高，可以考虑导入“<strong>势</strong>”的概念用Dijkstra求最短路</p></blockquote><h2 id="Dijkstra最短路上增广（模板）"><a href="#Dijkstra最短路上增广（模板）" class="headerlink" title="Dijkstra最短路上增广（模板）"></a>Dijkstra最短路上增广（模板）</h2><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;const int N = 1005;const int INF = 0x3f3f3f3f;typedef pair&lt;int, int&gt; P;///first:最短距离 second:节点编号typedef long long ll;struct edge{ int to, w, cap, rev; };int n, m, s, t, flow;vector&lt;edge&gt; vec[N];int h[N], dis[N];///节点的势 最短距离int fro_v[N], fro_e[N];///vector 的 第一维和第二维///用于确定最短路中点k前面那条边void add(int from, int to, int w, int cap){    int from_sz = vec[from].size(), to_sz = vec[to].size();    vec[from].push_back( (edge){ to, w, cap, to_sz } );    vec[to].push_back( (edge){ from, -w, 0, from_sz } );}int min_cost_flow(int s, int t, int f){    ll res = 0;    memset(h, 0, sizeof(h));    while(f)///若没完成任务：就对残余网络搜索最短路进行增广    {        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; q;        memset(dis, INF, sizeof(dis));        dis[s] = 0;        q.push(P(0, s));        while(!q.empty())        {            P now = q.top();            q.pop();            int to = now.second;            if(dis[to] &lt; now.first)                continue;            for(int i = 0; i &lt; vec[to].size(); ++i)            {                edge &amp; nxt = vec[to][i];                if(nxt.cap &gt; 0 &amp;&amp; dis[nxt.to] &gt; dis[to] + nxt.w + h[to] - h[nxt.to])                {                    dis[nxt.to] = dis[to] + nxt.w + h[to] - h[nxt.to];                    fro_v[nxt.to] = to;                    fro_e[nxt.to] = i;                    q.push(P(dis[nxt.to], nxt.to));                }            }        }        if(dis[t] == INF)///还未完成任务（f减为0）就找不出可行流了            return -1;        for(int v = 0; v &lt;= n; ++v)            h[v] += dis[v];        int d = f;///保证f最终为0而非小于0        ///即使新的最大流&gt;f, 也只取f        for(int v = t; v != s; v = fro_v[v])            d = min(d, vec[ fro_v[v] ][ fro_e[v] ].cap);        f -= d;        res += d * h[t];///There is a h[t] in Dijkstra, not a dis[t](in Bellman_Ford).        for(int v = t; v != s; v = fro_v[v])///更新残余网络，建反向边        {            edge &amp; nxt = vec[ fro_v[v] ][ fro_e[v] ];            nxt.cap -= d;            vec[v][nxt.rev].cap += d;        }    }    return res;}int main(){    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    scanf(&quot;%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t, &amp;flow);    int ui, vi, wi, fi;    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d%d%d&quot;, &amp;ui, &amp;vi, &amp;wi, &amp;fi);        add(ui, vi, fi, wi);    }    cout &lt;&lt; min_cost_flow(s, t, flow) &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>详见《挑战程序设计竞赛（第2版）》Page225</p><p>本想找个模板题试试，结果模板题都是<strong>最小费用最大流</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最小费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉(回)路</title>
      <link href="2019/08/01/%E6%AC%A7%E6%8B%89-%E5%9B%9E-%E8%B7%AF/"/>
      <url>2019/08/01/%E6%AC%A7%E6%8B%89-%E5%9B%9E-%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS求连通图路径（模板）"><a href="#DFS求连通图路径（模板）" class="headerlink" title="DFS求连通图路径（模板）"></a>DFS求连通图路径（模板）</h2><blockquote><p>无向图是特殊的有向图</p><p>欧拉回路是特殊的欧拉路</p></blockquote><a id="more"></a><h2 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h2><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;int n, m;int cnt[N];int tot, ans[N];bool mp[N][N];void DFS(int num){    for(int i = 1; i &lt;= n; ++i)        if(mp[num][i])        {            mp[num][i] = mp[i][num] = 0;            DFS(i);            ans[++tot] = i;        }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(cnt, 0, sizeof(cnt));        memset(ans, 0, sizeof(ans));        memset(mp, 0, sizeof(mp));        tot = 0;        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            mp[u][v] = mp[v][u] = 1;            cnt[u]++, cnt[v]++;        }        int start = 0;        bool flag = 0;        for(int i = 1; i &lt;= n; ++i)        {            if(cnt[i] &amp; 1)            start = i, flag++;            if(flag &gt; 2)            {                cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; &#39;\n&#39;;                return 0;            }        }        if(!start)        {            cout &lt;&lt; &quot;欧拉回路&quot; &lt;&lt; &#39;\n&#39;;            start = 1;        }        else            cout &lt;&lt; &quot;欧拉路&quot; &lt;&lt; &#39;\n&#39;;        DFS(start);///从奇点开始搜        for(int i = 1; i &lt;= tot; ++i)            cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;        if(start != 1)            cout &lt;&lt; start &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 图论の欧拉路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1878 欧拉回路(无向图)</title>
      <link href="2019/08/01/HDU-1878-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E6%97%A0%E5%90%91%E5%9B%BE/"/>
      <url>2019/08/01/HDU-1878-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E6%97%A0%E5%90%91%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="欧拉路与欧拉回路"><a href="#欧拉路与欧拉回路" class="headerlink" title="欧拉路与欧拉回路"></a>欧拉路与欧拉回路</h2><blockquote><p>欧拉路：从图中任意一个点开始到图中任意一个点结束的路径，并且<strong>图中每条边通过的且只通过一次</strong> </p><p>欧拉回路：起点也是终点的欧拉路（也属于欧拉路，如同正方形属于矩形）</p></blockquote><a id="more"></a><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><blockquote><p>无向图的判断： </p><p>欧拉回路：每个顶点的度都为偶数</p><p>欧拉路：只有两个顶点度的个数为奇数，其余的都为偶数</p><p>有向图的判断： </p><p>欧拉回路：每个顶点的出度于入度都相等</p><p>欧拉路：一个出度 - 入度 == 1，一个入度 - 出度 == 1，其余点出度==入度 </p></blockquote><h2 id="前提：图是连通的"><a href="#前提：图是连通的" class="headerlink" title="前提：图是连通的"></a>前提：图是连通的</h2><blockquote><p>判连通：</p><ol><li>DFS：若图能连通，那么能访问完所有图中节点 </li><li>并查集</li></ol></blockquote><h3 id="HDU-1878-欧拉回路"><a href="#HDU-1878-欧拉回路" class="headerlink" title="HDU 1878 欧拉回路"></a>HDU 1878 欧拉回路</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1005;int n, m;int cnt[N];//int tot, ans[N];bool mp[N][N], vis[N];void DFS(int num){    vis[num] = 1;    for(int i = 1; i &lt;= n; ++i)        if(mp[num][i])        {            mp[num][i] = mp[i][num] = 0;            DFS(i);//            ans[++tot] = i;        }}int main(){    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        scanf(&quot;%d&quot;, &amp;m);        memset(cnt, 0, sizeof(cnt));//        memset(ans, 0, sizeof(ans));        memset(vis, 0, sizeof(vis));        memset(mp, 0, sizeof(mp));//        tot = 0;        int u, v;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);            mp[u][v] = mp[v][u] = 1;            cnt[u]++, cnt[v]++;        }        DFS(1);        bool flag = 0;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i])            {                flag = 1;                cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;                break;            }        if(flag)            continue;        flag = 0;        int num = 0;        for(int i = 1; i &lt;= n; ++i)            if(cnt[i] &amp; 1)            {                flag = 1;                cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;                break;            }        if(!flag)            cout &lt;&lt; &#39;1&#39; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>多用了一个ans数组存路径时会TLE</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 图论の欧拉路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1083 2063 ZOJ 4120(二分图匹配)</title>
      <link href="2019/07/31/HDU-1083-2063-ZOJ-4120-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
      <url>2019/07/31/HDU-1083-2063-ZOJ-4120-%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>确定是二分图求最大匹配时，对任意一方查找匹配均可</p></blockquote><a id="more"></a><h2 id="数组link"><a href="#数组link" class="headerlink" title="数组link"></a>数组link</h2><blockquote><p>记录：link[i] = v; <strong>选项i(下标)</strong> 分配给任务v(储存值)</p></blockquote><h2 id="数组vis"><a href="#数组vis" class="headerlink" title="数组vis"></a>数组vis</h2><blockquote><p>记录：在为任务v配对时 <strong>选项i(下标)</strong>是否被访问过</p><p>作用：为了替任务v争得选项to，在此处将选项to锁定，dfs寻找选项(to)   原来服务的任务(link[to])   <strong>其他</strong>可行的选项，体现了<strong>增广路的特点——反悔</strong></p></blockquote><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote><p>每次为任务选择选项时，每个选项要从头考虑（<code>memset(vis, 0, sizeo(vis))</code>），直到找到合适的选项为止</p></blockquote><h3 id="HDU-1083"><a href="#HDU-1083" class="headerlink" title="HDU 1083"></a>HDU 1083</h3><blockquote><p>题意：P课程各找一个课代表，N个人，每人至多担任一门课代表</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int p, n;int link[1005];///link[i] = v; 选项i 分配给任务vbool vis[1005];///在为任务v配对时 选项i是否被访问过vector&lt;int&gt; vec[1005];/*vis数组的作用：///为了替任务v争得选项to，在此处将选项to锁定，dfs寻找选项(to) 原来服务的任务(link[to]) 其他可行的选项体现了反悔这一增广路的特点*/bool dfs(int v){    for(int i = 0; i &lt; vec[v].size(); ++i)    {        int to = vec[v][i];        if(!vis[to])        {            vis[to] = 1;            if(link[to] == -1 || dfs(link[to]))            {                link[to] = v;                return 1;            }        }    }    return 0;}void slove(){    int ans = 0;    memset(link, -1, sizeof(link));    for(int i = 1; i &lt;= p; ++i)    {        memset(vis, 0, sizeof(vis));        if(dfs(i))            ans++;    }    if(ans == p)        cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;    else        cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int cnt, tem;        scanf(&quot;%d%d&quot;, &amp;p, &amp;n);        for(int i = 0; i &lt; 1005; ++i)            vec[i].clear();        for(int i = 1; i &lt;= p; ++i)        {            scanf(&quot;%d&quot;, &amp;cnt);            while(cnt--)            {                scanf(&quot;%d&quot;, &amp;tem);                vec[i].push_back(tem);            }        }        slove();    }    return 0;}</code></pre><h3 id="HDU-2063"><a href="#HDU-2063" class="headerlink" title="HDU 2063"></a>HDU 2063</h3><blockquote><p>题意：男女配对</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int k, m, n;int link[1005];bool vis[1005];vector&lt;int&gt; vec[1005];bool dfs(int v){    for(int i = 0; i &lt; vec[v].size(); ++i)    {        int to = vec[v][i];        if(!vis[to])        {            vis[to] = 1;            if(link[to] == -1 || dfs(link[to]))            {                link[to] = v;                return 1;            }        }    }    return 0;}void slove(){    int ans = 0;    memset(link, -1, sizeof(link));    for(int i = 1; i &lt;= m; ++i)    {        memset(vis, 0, sizeof(vis));        if(dfs(i))            ans++;    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    int girl, boy;    while(~scanf(&quot;%d&quot;, &amp;k) &amp;&amp; k)    {        for(int i = 0; i &lt; 1005; ++i)            vec[i].clear();        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);        for(int i = 0; i &lt; k; ++i)        {            scanf(&quot;%d%d&quot;, &amp;girl, &amp;boy);            vec[girl].push_back(boy);        }        slove();    }    return 0;}</code></pre><h3 id="ZOJ-1083-Tokens-on-the-Segments"><a href="#ZOJ-1083-Tokens-on-the-Segments" class="headerlink" title="ZOJ 1083 Tokens on the Segments"></a>ZOJ 1083 Tokens on the Segments</h3><blockquote><p>题意：一个直角坐标轴，y轴上从1到n共n个点，分别对应x轴上一段区间，从对应区间中为每个点匹配一个点，x轴上每个被选择的点不可重复</p></blockquote><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int n;map&lt;int, int&gt; link;map&lt;int, int&gt; vis;int l[N], r[N];bool dfs(int v){    for(int i = l[v]; i &lt;= r[v]; ++i)        if(!vis[i])        {            vis[i] = 1;            if(link[i] == 0 || dfs(link[i]))            {                link[i] = v;                return 1;            }        }    return 0;}void slove(){    int ans = 0;    link.clear();    for(int i = 1; i &lt;= n; ++i)    {        vis.clear();        if(dfs(i))            ans++;    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;,&amp;n);        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d%d&quot;, &amp;l[i], &amp;r[i]);        slove();    }    return 0;}</code></pre><blockquote><p>昨日种种皆成今我：利用一切可利用的时间学习，也不至于不会做，不至于打铁了</p><p>今日种种皆成新我：现在不珍惜时间多学多练，将来还是要被碾压、还是要打铁</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 二分图の匈牙利算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 4738 Caocao&#39;s Bridge(双连通+桥)</title>
      <link href="2019/07/29/HDU-4738-Caocao-s-Bridge-%E5%8F%8C%E8%BF%9E%E9%80%9A-%E6%A1%A5/"/>
      <url>2019/07/29/HDU-4738-Caocao-s-Bridge-%E5%8F%8C%E8%BF%9E%E9%80%9A-%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="桥"><a href="#桥" class="headerlink" title="桥"></a>桥</h2><blockquote><p>无向图中，如果去掉一条边，使得图被分成了几个部分，那么这条边就被称为桥</p></blockquote><a id="more"></a><h2 id="judge"><a href="#judge" class="headerlink" title="judge"></a>judge</h2><blockquote><p>不在环里的边都是桥</p><p>边(from, to)不在环里的标志：<code>low[to] &gt; time[from]</code></p></blockquote><h3 id="HDU-4738-曹操的桥"><a href="#HDU-4738-曹操的桥" class="headerlink" title="HDU 4738 曹操的桥"></a>HDU 4738 曹操的桥</h3><blockquote><p>无向图求桥</p><p>坑点：</p><ol><li>有重边</li><li>初始不连通</li><li>无人守至少1人去</li></ol></blockquote><h2 id="关于vector邻接表、二维邻接矩阵、链式前向星"><a href="#关于vector邻接表、二维邻接矩阵、链式前向星" class="headerlink" title="关于vector邻接表、二维邻接矩阵、链式前向星"></a>关于vector邻接表、二维邻接矩阵、链式前向星</h2><blockquote><ol><li><p>普通vector邻接表：无需遍历+没有边权</p></li><li><p>二维邻接矩阵：遍历找边+可存边权</p></li><li><p>链式前向星：无需遍历+可存边权</p></li><li><p>普通vector邻接表+二维邻接矩阵：(利用前者)无需遍历+(利用后者)可存边权</p></li><li><p>以结构体为储存类型的vector：无需遍历+可存边权</p><p>3、5较优，1有缺陷，2耗时间，4耗空间</p></li></ol></blockquote><h3 id="Code-of-this-problem（My-Code）"><a href="#Code-of-this-problem（My-Code）" class="headerlink" title="Code of this problem（My Code）"></a>Code of this problem（My Code）</h3><blockquote><p>关于处理重边：我用嵌套的map记录重边，重边中的任意一条边均非桥！最后处理时直接跳过</p></blockquote><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, area, bridge;int cnt, tot, low[1005], time[1005], head[1005];map&lt;int, map&lt;int, int&gt; &gt; mp;///重边中的任意一条均不是桥struct edge{    bool flag;    int from, to, w, pre;} a[2000005];void add(int from, int to, int w){    a[cnt].flag = 0;    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void Trajan(int x, int pre){    low[x] = time[x] = ++tot;    for(int i = head[x]; ~i; i = a[i].pre)    {        int to = a[i].to;//        if(i == (pre ^ 1))///处理重边的方法//            continue;        if(to == pre)            continue;        if(!time[to])        {            Trajan(to, x);            low[x] = min(low[x], low[to]);            if(low[to] &gt; time[x])            {                bridge++;                a[i].flag = a[i ^ 1].flag = 1;            }        }        else            low[x] = min(low[x], time[to]);    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        if(n == 0 &amp;&amp; m == 0)            break;        int u, v, w;        mp.clear();        cnt = tot = area = bridge = 0;        memset(low, 0, sizeof(low));        memset(time, 0, sizeof(time));        memset(head, -1, sizeof(head));        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add(u, v, w);            add(v, u, w);            mp[u][v]++,  mp[v][u]++;        }        for(int i = 1; i &lt;= n; ++i)///初始可能不连通的做法            if(!time[i])                area++, Trajan(i, -1);///计算连通块        if(area &gt; 1)        {            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;            continue;        }        if(bridge == 0)        {            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            continue;        }        int ans = 0x3f3f3f3f;        for(int i = 0; i &lt; 2 * m; ++i)        {            u = a[i].from;            v = a[i].to;            if(mp[u][v] &gt; 1)                continue;            if(a[i].flag &amp;&amp; a[i].w &lt; ans)                ans = a[i].w;        }        if(ans == 0x3f3f3f3f)        {            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            continue;        }        printf(&quot;%d\n&quot;, ans == 0 ? 1 : ans);    }    return 0;}</code></pre><blockquote><blockquote><p>另一种处理重边的方法<del>（很简洁但我不懂）</del>2020.4.8懂了</p></blockquote><p><code>if(i == (pre ^ 1)) continue;</code></p><p>Tarjan函数第二个参数，在上面我自己写的代码中，是x的父节点，在下面标准代码中，是连接x父节点与x(指向x)的那条边，<code>pre ^ 1</code>是pre的反向边，我们要略过反向边，但不能略过其他的重边(同样连接了x与其父节点)</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m, area, bridge;int cnt, tot, low[1005], time[1005], head[1005];struct edge{    bool flag;    int to, w, pre;} a[2000005];void add(int from, int to, int w){    a[cnt].flag = 0;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void Trajan(int x, int pre){    low[x] = time[x] = ++tot;    for(int i = head[x]; ~i; i = a[i].pre)    {        int to = a[i].to;        if(i == (pre ^ 1))            continue;        if(!time[to])        {            Trajan(to, i);///注意此处的i            low[x] = min(low[x], low[to]);            if(low[to] &gt; time[x])            {                bridge++;                a[i].flag = a[i ^ 1].flag = 1;            }        }        else            low[x] = min(low[x], time[to]);    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        if(n == 0 &amp;&amp; m == 0)            break;        int u, v, w;        cnt = tot = area = bridge = 0;        memset(low, 0, sizeof(low));        memset(time, 0, sizeof(time));        memset(head, -1, sizeof(head));        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add(u, v, w);            add(v, u, w);        }        for(int i = 1; i &lt;= n; ++i)            if(!time[i])                area++, Trajan(i, -1);        if(area &gt; 1)        {            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;            continue;        }        if(bridge == 0)        {            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            continue;        }        int ans = 0x3f3f3f3f;        for(int i = 0; i &lt; 2 * m; ++i)            if(a[i].flag &amp;&amp; a[i].w &lt; ans)                ans = a[i].w;        printf(&quot;%d\n&quot;, ans == 0 ? 1 : ans);    }    return 0;}</code></pre><blockquote><p>第二份代码里的形参，第二个已不是第一个的父节点，而是父节点的head值，一条边的标号</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の桥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1144 Network(双连通+割点)</title>
      <link href="2019/07/29/POJ-1144-NEtwork-%E6%97%A0%E5%90%91%E5%9B%BE-%E5%89%B2%E7%82%B9/"/>
      <url>2019/07/29/POJ-1144-NEtwork-%E6%97%A0%E5%90%91%E5%9B%BE-%E5%89%B2%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><blockquote><p>将这个点去掉，图就会被分成两个部分（或者以上），那么这个点就是一个割点</p></blockquote><a id="more"></a><h2 id="判断割点"><a href="#判断割点" class="headerlink" title="判断割点"></a>判断割点</h2><blockquote><ol><li>对根节点u，若其有两棵或两棵以上的子树，则该根结点u为割点； </li><li>对非叶子节点u（非根节点），若其子树的节点均没有指向u的祖先节点的回边，说明删除u之后，根结点与u的子树的节点不再连通；则节点u为割点。</li></ol></blockquote><h3 id="POJ-1144-Network（求割点个数）"><a href="#POJ-1144-Network（求割点个数）" class="headerlink" title="POJ 1144 Network（求割点个数）"></a>POJ 1144 Network（求割点个数）</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool flag[105];int ans, cnt, low[105], time[105];vector&lt;int&gt; v[105];void init(){    ans = cnt = 0;    memset(flag, 0, sizeof(flag));    memset(low, 0, sizeof(low));    memset(time, 0, sizeof(time));    for(int i = 0; i &lt;= 104; ++i)        v[i].clear();}void Trajan(int x, int pre){    int tem, sum = 0;    low[x] = time[x] = ++cnt;    for(int i = 0; i &lt; v[x].size(); ++i)    {        tem = v[x][i];        if(!time[tem])        {            Trajan(tem, x);            low[x] = min(low[x], low[tem]);            sum++;            if(x != pre &amp;&amp; low[tem] &gt;= time[x])                flag[x] = 1;            if(x == pre &amp;&amp; sum &gt; 1)                flag[x] = 1;        }        else            low[x] = min(low[x], time[tem]);    }}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        init();        int u, to;        while(~scanf(&quot;%d&quot;, &amp;u) &amp;&amp; u)        {            getchar();            char ch;            while(1)            {                scanf(&quot;%d%c&quot;, &amp;to, &amp;ch);                v[u].push_back(to);                v[to].push_back(u);                if(ch == &#39;\n&#39;)                    break;            }        }        Trajan(1, 1);//        for(int i = 1; i &lt;= n; ++i)//            if(!time[i])//                Trajan(i, i);        for(int i = 1; i &lt;= n; ++i)            if(flag[i])                ans++;        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>割点可能被重复标记，所以不能在找到割点时计数</p><p>而必须找出所有割点再数出个数</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の割点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ string 及其函数</title>
      <link href="2019/07/27/c-string-%E5%8F%8A%E5%85%B6%E5%87%BD%E6%95%B0/"/>
      <url>2019/07/27/c-string-%E5%8F%8A%E5%85%B6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="s-substr"><a href="#s-substr" class="headerlink" title="s.substr()"></a>s.substr()</h2><blockquote><p>substr有2种用法：</p><p>假设：string s = “0123456789”;</p><p>string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”</p><p>string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”</p><p>转自： <a href="https://blog.csdn.net/liuchuo/article/details/54599840" target="_blank" rel="noopener">https://blog.csdn.net/liuchuo/article/details/54599840</a></p></blockquote><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">自我感觉重要的几点：1.getline(cin, s)的赋值2.字符串数组的使用5.大小、判空6.末尾添加11.string查找#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;int len = 4;char ch = &#39;Y&#39;;int main(){    ///1.赋值    ///cin遇空格、tab、回车结束//    string s1;//    cin &gt;&gt; s1;//    cout &lt;&lt; s1 &lt;&lt; &#39;\n&#39;;    ///吃“回车”，相当于getchar(),避免影响后续输入//    cin.get();    ///一行字符串的输入//    string s2;//    getline(cin, s2);//    cout &lt;&lt; s2 &lt;&lt; &#39;\n&#39;;///2.字符串数组（竟然可以访问每个string里的每个字符！！！）    string a[10];    for(int i = 0; i &lt; 5; ++i)    {        getline(cin, a[i]);        if(i != 4)            cin.get();    }    for(int i = 0; i &lt; 5; ++i)    {        cout &lt;&lt; a[i] &lt;&lt; &#39;\n&#39;;    }    ///访问一个string里的字符    string s[5];    s[0] = &quot;ABCDE&quot;;    for(int i = 0; i &lt; 5; ++i)    {        cout &lt;&lt; s[0][i] &lt;&lt; &#39;\n&#39;;    }    ///3.初始化    cout &lt;&lt; &quot;1.初始化练习&quot; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;（1）.直接等于号赋值&quot; &lt;&lt; &#39;\n&#39;;    string s3 = &quot;嘤嘤嘤&quot;;    cout &lt;&lt; s3 &lt;&lt; &#39;\n&#39;;    ///复制粘贴    string s8;    cout &lt;&lt; &quot;（2）.字符串copy赋值&quot; &lt;&lt; &#39;\n&#39;;    s8 = s3;    cout &lt;&lt; s8 &lt;&lt; &#39;\n&#39;;    ///用指向已知字符串的字符指针 初始化 字符串    cout &lt;&lt; &quot;（3）.指向已知字符串的字符指针 初始化&quot; &lt;&lt; &#39;\n&#39;;    char * s = &quot;好傻好没用的做法&quot;;    string s4(s);    cout &lt;&lt; s4 &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;（4）.assign分配赋值——字符指针版&quot; &lt;&lt; &#39;\n&#39;;    s8.assign(s);    cout &lt;&lt; s8 &lt;&lt; &#39;\n&#39;;    ///一个汉字占两个字节从1开始    cout &lt;&lt; &quot;（5）.assign分配前10个字符（字节）赋值——字符指针版&quot; &lt;&lt; &#39;\n&#39;;    s8.assign(s, 10);    cout &lt;&lt; s8 &lt;&lt; &#39;\n&#39;;    ///另类复制粘贴    cout &lt;&lt; &quot;（6）.assign分配赋值——字符串版——相当于等于号copy&quot; &lt;&lt; &#39;\n&#39;;    s8.assign(s4);    cout &lt;&lt; s8 &lt;&lt; &#39;\n&#39;;    ///用n个字符 初始化 一个字符串    cout &lt;&lt; &quot;（8）.用len个ch字符初始化&quot; &lt;&lt; &#39;\n&#39;;    string s5(6, ch);    cout &lt;&lt; s5 &lt;&lt; &#39;\n&#39;;    ///用len个ch字符赋值    cout &lt;&lt; &quot;（9）.运用assign，用len个ch字符赋值&quot; &lt;&lt; &#39;\n&#39;;    string s9;    s9.assign(len, ch);    cout &lt;&lt; s9 &lt;&lt; &#39;\n&#39;;    ///另类赋值    string s10 = &quot;ABCDEFG&quot;;    string s11;    cout &lt;&lt; &quot;（10）.用assign三维截取赋值&quot; &lt;&lt; &#39;\n&#39;;    s11.assign(s10, 0, 4);    cout &lt;&lt; s11 &lt;&lt; &#39;\n&#39;;    ///迭代器赋值    cout &lt;&lt; &quot;（11）.用迭代器赋值&quot; &lt;&lt; &#39;\n&#39;;    s11.assign(s10.begin(), s10.end());    cout &lt;&lt; s11 &lt;&lt; &#39;\n&#39;;    ///4.字符操作    ///访问指定位置的字符（感觉很耗时!!!）//    string s6 = &quot;qaq&quot;;//    char b = s6[1];///输出a（字符串从0开始）//    cout &lt;&lt; b &lt;&lt; &#39;\n&#39;;  5.特性描述    string s7 = &quot;abcdefg&quot;;  当前容量 15 ？？？    cout &lt;&lt; s7.capacity() &lt;&lt; &#39;\n&#39;;  string 对象可存放的最大字符串长度（2147483647 = 2 ^ 31 - 1）    cout &lt;&lt; s7.max_size() &lt;&lt; &#39;\n&#39;;  字符串大小    cout &lt;&lt; s7.length() &lt;&lt; &#39;\n&#39;;  判空    cout &lt;&lt; s7.empty() &lt;&lt; &#39;\n&#39;;  重定大小，不足去补    s7.resize(10, &#39;A&#39;);    cout &lt;&lt; s7 &lt;&lt; &#39;\n&#39;;    s7.resize(5, &#39;B&#39;);    cout &lt;&lt; s7 &lt;&lt; &#39;\n&#39;;  6.string连接  算数相加    string s12 = &quot;HIJKLMN &quot;;    string s13 = &quot;OPQ &quot;;    s12 += s13;    cout &lt;&lt; s12 &lt;&lt; &#39;\n&#39;;  指向字符串的字符指针截取部分 添于末尾    s13.append(s, 10);    cout &lt;&lt; s13 &lt;&lt; &#39;\n&#39;;    s13.append(s);  迭代器添加    string s14 = &quot;s14 &quot;;    cout &lt;&lt; s14 &lt;&lt; &#39;\n&#39;;    s14.append(s7.begin(), s7.end());    cout &lt;&lt; s14 &lt;&lt; &#39;\n&#39;;  尾部添字符    string s15 = &quot;s15 &quot;;    s15.push_back(&#39;A&#39;);    cout &lt;&lt; s15 &lt;&lt; &#39;\n&#39;;  7.比较大小    string s16 = &quot;abcdefg&quot;;    string s17 = &quot;bcdefg&quot;;    cout &lt;&lt; (s16 == s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; (s16 != s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; (s16 &gt; s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; (s16 &gt;= s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; (s16 &lt; s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; (s16 &lt;= s17) &lt;&lt; &#39;\n&#39;;  大于返回1，小于返回-1，等于返回0    cout &lt;&lt; s16.compare(s17) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s17.compare(s16) &lt;&lt; &#39;\n&#39;;  拿出从s16（从0开始）的第1个字符开始连续6个字符与s17比较    cout &lt;&lt; s16.compare(1, 6, s17) &lt;&lt; &#39;\n&#39;;  类似的    cout &lt;&lt; s16.compare(3, 5, s17, 2, 5) &lt;&lt; &#39;\n&#39;;  8.string子串    string s18 = &quot;OPQRST&quot;;    string s19 = s18.substr(3, 3);///从下表3开始的连续3个字符    cout &lt;&lt; s19 &lt;&lt; &#39;\n&#39;;  9.string交换    cout &lt;&lt; &quot;s18: &quot; &lt;&lt; s18 &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;s19: &quot; &lt;&lt; s19 &lt;&lt; &#39;\n&#39;;    s18.swap(s19);    cout &lt;&lt; &quot;s18: &quot; &lt;&lt; s18 &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;s19: &quot; &lt;&lt; s19 &lt;&lt; &#39;\n&#39;;  10.字符串的流处理,头文件&lt;sstream&gt;    string str24(&quot;hello,this is a test&quot;);    istringstream is(str24);    string s20, s21, s22, s23;    is &gt;&gt; s20 &gt;&gt; s21 &gt;&gt; s22 &gt;&gt; s23;  s20=&quot;hello,this&quot;,s21=&quot;is&quot;,s22=&quot;a&quot;,s23=&quot;test&quot;    ostringstream os;    os &lt;&lt; s20 &lt;&lt; s21 &lt;&lt; s22 &lt;&lt;s23;    cout&lt;&lt; os.str() &lt;&lt; &#39;\n&#39;;  11.string的查找，查找成功时返回所在位置，  失败时返回string::npos的值，即是-1  括号内容为三维时，第三维是选取字符串的前几个字符    string s25 = &quot;ABCDEFGGGGGGHHHHHHIJKLMNOPQRSTUVWXYZ&quot;;  从0开始找‘G’    int pos = s25.find(&#39;G&#39;, 0);    cout &lt;&lt; pos &lt;&lt; &#39;\n&#39;;  从0开始找“GG”    cout &lt;&lt; s25.find(&quot;GG&quot;, 0) &lt;&lt; &#39;\n&#39;;  从0开始找“HHHHH”前4个字符所在位置    cout &lt;&lt; s25.find(&quot;HHHHH&quot;, 0, 4) &lt;&lt; &#39;\n&#39;;  反向查找（不要以为反向查找时，最后一个字符位置是0，往前一个是1，再2...）    cout &lt;&lt; &quot;反向查找,岂不是find_last_of？&quot; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s25.rfind(&#39;G&#39;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s25.rfind(&quot;GG&quot;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s25.rfind(&quot;HHHHH&quot;, string::npos, 4) &lt;&lt; &#39;\n&#39;;  查找第一次出现的位置（字符串下表从0开始）    string s26 = &quot;ABBCCCDDDDEEEEEFFFFFFGGGGGGG&quot;;    cout &lt;&lt; &quot;find_first_of检测&quot; &lt;&lt; &#39;\n&#39;;///相对于find它本身不是全匹配    cout &lt;&lt; s26.find_first_of(&#39;C&#39;, 0) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_of(&quot;DD&quot;, 0) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_of(&quot;DDGG&quot;, 0, 2) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;find_first_not_of检测&quot; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_not_of(&#39;A&#39;, 0) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_not_of(&#39;C&#39;, 0) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_not_of(&quot;DD&quot;, 0) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_first_not_of(&quot;DDGG&quot;, 0, 2) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;find_last_of检测&quot; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_of(&#39;C&#39;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_of(&quot;DD&quot;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_of(&quot;DDGG&quot;, string::npos, 2) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;find_last_not_of检测&quot; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_not_of(&#39;C&#39;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_not_of(&quot;DD&quot;, string::npos) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s26.find_last_not_of(&quot;DDGG&quot;, string::npos, 2) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;可以进行类似于upper_bound(0, num) - lower_bound(0, num)的操作&quot; &lt;&lt; &#39;\n&#39;;  12.string的替换  第一维：替换起始位置  第二维：从起始位置起连续几个字符被换掉  第三维：要换的新字符串  (有且仅有四维）第四维：截取新字符串前几个字符  (有且仅有五维）第四、五维：从位置几开始截取几个字符    string s27 = &quot;CCCCTTTTMMMMDDDD传统美德&quot;;    string s28;    s28 = s27.replace(0, 4, &quot;AAAA&quot;);    cout &lt;&lt; s28 &lt;&lt; &#39;\n&#39;;    string s29;    s29 = s27.replace(0, 4, &quot;BBBB&quot;, 2);    cout &lt;&lt; s29 &lt;&lt; &#39;\n&#39;;    string s30;    s30 = s27.replace(0, 4, &quot;DDDDEEEEFFFF&quot;, 4, 4);    cout &lt;&lt; s30 &lt;&lt; &#39;\n&#39;;  前两维同上，第三维是后面字符个数    string s31;    s31 = s27.replace(0, 4, 8, &#39;Z&#39;);    cout &lt;&lt; s31 &lt;&lt; &#39;\n&#39;;  据说以上操作中，位置可以换为迭代器  13.string的插入（位置可以换为迭代器）  维度意义同上    string s32 = &quot;tql wsl 天气冷 我睡了 &quot;;    string s33 = s32.insert(0, &quot;yyy 牙痒痒 &quot;);    cout &lt;&lt; s33 &lt;&lt; &#39;\n&#39;;    string s34 = s32.insert(0, 4, &#39;L&#39;);    cout &lt;&lt; s34 &lt;&lt; &#39;\n&#39;;    string s35 = s32.insert(0, &quot;ZBL&quot;, 2);    cout &lt;&lt; s35 &lt;&lt; &#39;\n&#39;;    string s36 = s32.insert(0, &quot;ZZZBBBLLL&quot;, 3, 3);    cout &lt;&lt; s36 &lt;&lt; &#39;\n&#39;;  14.string的删除    string s37 = &quot;Oh,my God!&quot;;    string s38 = s37;    string s39 = s37;    string s40 = s37;  只删除第二个    s38.erase(s38.begin() + 2);  从第二个开始删，保留最后一个    s39.erase(s39.begin() + 2, s39.end() - 1);  删除（包括）第三个字符以后的所有字符    s40.erase(3);    cout &lt;&lt; s38 &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s39 &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; s40 &lt;&lt; &#39;\n&#39;;  有s.clear()函数  15.补充：加法连接字符串    string s41 = &quot;ABC&quot;;    string s42 = &quot;DEF&quot;;  不能直接连接两个字符串，如：s43 = &quot;abc&quot; + &quot;def&quot;;    string s43 = s41 + &quot;GHI&quot;;  s44的运算自左至右，s41 + &quot;GHI&quot;组成一个s（字符串变量），再加“JKL&quot;    string s44 = s41 + &quot;GHI&quot; + &quot;JKL&quot;;    string s45 = s41 + s42;    s41 += &quot;Hello world!&quot;;    cout &lt;&lt; s43 &lt;&lt; &#39;\n&#39; &lt;&lt; s44 &lt;&lt; &#39;\n&#39; &lt;&lt; s45 &lt;&lt; &#39;\n&#39; &lt;&lt; s41 &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据类型のstring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1236 Network of Schools(强连通+缩点)</title>
      <link href="2019/07/27/POJ-1236-Network-of-Schools-%E5%BC%BA%E8%BF%9E%E9%80%9A-%E7%BC%A9%E7%82%B9/"/>
      <url>2019/07/27/POJ-1236-Network-of-Schools-%E5%BC%BA%E8%BF%9E%E9%80%9A-%E7%BC%A9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a>缩点</h2><blockquote><p>缩点就是要将两两之间可以相互到达的点，缩成一个点来表示（即求无向图的连通分量，或者有向图的强连通分量），他们的求法都是相同的，都是将无向图转化为有向图。 </p></blockquote><a id="more"></a><h1 id="Trajan算法求缩点"><a href="#Trajan算法求缩点" class="headerlink" title="Trajan算法求缩点"></a>Trajan算法求缩点</h1><blockquote><p>stack\<int\> st;</int\></p><p>int num;///num:强连通分量(连通块)的个数,缩点后点的个数</p><p>bool vis[105];///该点是否访问过</p><p>int inst[105];///该点是否在栈中</p><p>int time[105];///i点第一次被访问的时间</p><p>int low[105];///i点所在强连通分量子图中第一个被搜到的点的time值</p><p>int ltt[105];///i点属于第几个强连通分量(0表示不属于任何一个)</p><p>强连通分量内元素个数最少为1(该元素本身),这意味着每个元素都有从属的强连通分量</p></blockquote><h3 id="Code-Trajan"><a href="#Code-Trajan" class="headerlink" title="Code(Trajan)"></a>Code(Trajan)</h3><pre><code class="lang-c++">void Trajan(int x)///搜索x点及其子树{    int temp;    st.push(x);    inst[x] = vis[x] = 1;    low[x] = time[x] = ++t;    for(int i = 0; i &lt; v[x].size(); i++)    {        temp = v[x][i];        if(vis[temp] == 0)        {            Trajan(temp);            low[x] = min(low[x], low[temp]);        }        else if(inst[temp] == 1)///成环时            low[x] = min(low[x], time[temp]);        else///点temp访问过却不在当前栈里：属于已发现的强连通分量            continue;///这两个不能合二为一的原因：只有从此指彼的单向路    }    if(low[x] == time[x])    {        num++;///找到第num个强连通分量        while(!st.empty())        {            temp = st.top();            st.pop();            ltt[temp] = num;///temp结点属于第num个强连通分量            inst[temp] = 0;            if(temp == x)                break;        }    }}</code></pre><h2 id="POJ-1236"><a href="#POJ-1236" class="headerlink" title="POJ 1236"></a>POJ 1236</h2><blockquote><p>n所学校，它们通过单向边连接，如果A—&gt;B表示A学校可以传递信息给B学校</p><p>问题一：至少要向几个学校传递信息，才能保证所有学校都能收到信息；</p><p>问题二：至少要添加多少组关系，才能保证给任意一个学校原始信息后，其他所有学校都能收到信息</p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>问题一：缩点后数出入度为0的点的个数</p><p>问题二：缩点后求再次完成强连通最少添加几条边max(ain, aout)</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;stack&lt;int&gt; st;vector&lt;int&gt; v[105], nv[105];int n, t, num;///num:强连通分量(连通块)的个数,缩点后点的个数int ain, aout;bool vis[105];///该点是否访问过int inst[105];///该点是否在栈中int time[105];///i点第一次被访问的时间int low[105];///i点所在强连通分量子图中第一个被搜到的点的time值int ltt[105];///i点属于第几个强连通分量(0表示不属于任何一个)int in[105], out[105];void Trajan(int x)///搜索x点及其子树{    int temp;    st.push(x);    inst[x] = vis[x] = 1;    low[x] = time[x] = ++t;    for(int i = 0; i &lt; v[x].size(); i++)    {        temp = v[x][i];        if(vis[temp] == 0)        {            Trajan(temp);            low[x] = min(low[x], low[temp]);        }        else if(inst[temp] == 1)///成环时            low[x] = min(low[x], time[temp]);        else///点temp访问过却不在当前栈里：属于已发现的强连通分量            continue;///这两个不能合二为一的原因：只有从此指彼的单向路    }    if(low[x] == time[x])    {        num++;///找到第num个强连通分量        while(!st.empty())        {            temp = st.top();            st.pop();            ltt[temp] = num;///temp结点属于第num个强连通分量            inst[temp] = 0;            if(temp == x)                break;        }    }}///强连通分量内元素个数最少为1(该元素本身)///这意味着每个元素都有从属的强连通分量int main(){    int x, temp;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 1; i &lt;= n; i++)    {        while(scanf(&quot;%d&quot;, &amp;x), x != 0)            v[i].push_back(x);    }    t = num = 0;    for(int i = 1; i &lt;= n; i++)        if(vis[i] == 0)            Trajan(i);    for(int i = 1; i &lt;= n; i++)        for(int j = 0; j &lt; v[i].size(); j++)        {            temp = v[i][j];            if(ltt[i] != ltt[temp])                nv[ltt[i]].push_back(ltt[temp]);        }    for(int i = 1; i &lt;= num; i++)        for(int j = 0; j &lt; nv[i].size(); j++)            in[nv[i][j]]++, out[i]++;    ain = aout = 0;    for(int i = 1; i &lt;= num; i++)    {        if(in[i] == 0)            ain++;        if(out[i] == 0)            aout++;    }    printf(&quot;%d\n&quot;, ain);    if(num == 1)        printf(&quot;0\n&quot;);    else        printf(&quot;%d\n&quot;, max(ain, aout));        ///让所有缩点形成一个强连通图        ///假设 aout = max(ain, aout)        ///那么恰当选择(aout - 1)个出度为0的点逆向添边会减少缩点，最终形成一条单向链        ///此时按照链的方向添一条连接首尾的边就形成强连通图(一个标准有向环)    return 0;}</code></pre><blockquote><p>参考1： <a href="https://blog.csdn.net/jaihk662/article/details/52194288" target="_blank" rel="noopener">https://blog.csdn.net/jaihk662/article/details/52194288</a></p><p>参考2： <a href="https://blog.csdn.net/nhl19961226/article/details/79114287" target="_blank" rel="noopener">https://blog.csdn.net/nhl19961226/article/details/79114287</a></p><blockquote><p>Kosaraju求缩点</p></blockquote><p>将边反向建立后，强连通分量内的点，其可达性不受影响。</p><p>但不能沿着边访问到除了这个强连通分量之外的点</p></blockquote><pre><code class="lang-c++">#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int MAX_V = 10005;int V, ain, aout, in[MAX_V], out[MAX_V];vector&lt;int&gt; vs;vector&lt;int&gt; G[MAX_V];vector&lt;int&gt; rG[MAX_V];vector&lt;int&gt; nv[MAX_V];bool used[MAX_V];int cmp[MAX_V];void add_eage(int from, int to){    G[from].push_back(to);    rG[to].push_back(from);}void DFS(int v){    used[v] = 1;    for(int i = 0; i &lt; G[v].size(); ++i)        if(!used[ G[v][i] ])            DFS(G[v][i]);    vs.push_back(v);}void rDFS(int v, int k){    used[v] = 1;    cmp[v] = k;    for(int i = 0; i &lt; rG[v].size(); ++i)        if(!used[ rG[v][i] ])            rDFS(rG[v][i], k);}int scc(){    memset(used, 0, sizeof(used));    vs.clear();    for(int v = 1; v &lt;= V; ++v)        if(!used[v])            DFS(v);    memset(used, 0, sizeof(used));    int k = 0;    for(int i = vs.size() - 1; i &gt;= 0; --i)        if(!used[vs[i]])            rDFS(vs[i], ++k);    return k;}int main(){    int x, temp;    scanf(&quot;%d&quot;, &amp;V);    for(int i = 1; i &lt;= V; i++)    {        while(scanf(&quot;%d&quot;, &amp;x), x != 0)            add_eage(i, x);    }    int num = scc();    for(int i = 1; i &lt;= V; i++)        for(int j = 0; j &lt; G[i].size(); j++)        {            temp = G[i][j];            if(cmp[i] != cmp[temp])                nv[cmp[i]].push_back(cmp[temp]);        }    for(int i = 1; i &lt;= num; i++)        for(int j = 0; j &lt; nv[i].size(); j++)            in[nv[i][j]]++, out[i]++;    ain = aout = 0;    for(int i = 1; i &lt;= num; i++)    {        if(in[i] == 0)            ain++;        if(out[i] == 0)            aout++;    }    printf(&quot;%d\n&quot;, ain);    if(num == 1)        printf(&quot;0\n&quot;);    else        printf(&quot;%d\n&quot;, max(ain, aout));    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 连通图の缩点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1118 单词统计 JAVA(s.indexOf())</title>
      <link href="2019/07/26/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-JAVA-s-indexOf/"/>
      <url>2019/07/26/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-JAVA-s-indexOf/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给定一个字符串和若干个单词，统计这些单词在这个字符串中出现的次数。 </p></blockquote><a id="more"></a><blockquote><p>题目链接： <a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1118" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/problem/show/1118</a></p><p>这题用C++做的话要用AC自动机过：<a href="https://fireworks99.github.io/2019/07/24/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/#more" target="_blank" rel="noopener">https://fireworks99.github.io/2019/07/24/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/#more</a> </p><p>JAVA暴力可过……</p></blockquote><h1 id="S-indexof-s-pos"><a href="#S-indexof-s-pos" class="headerlink" title="S.indexof(s, pos)"></a>S.indexof(s, pos)</h1><blockquote><p>从指定的索引处开始，返回第一次出现的指定子字符串在此字符串中的索引，相当于c++的string里的s.find(str, pos)</p><p>其他相关函数：</p><ol><li>int indexOf(String str) ：返回第一次出现的指定子字符串在此字符串中的索引.</li><li>int lastIndexOf(String str) ：返回在此字符串中最右边出现的指定子字符串的索引.</li><li>int lastIndexOf(String str, int startIndex) ：从指定的索引处开始向后搜索，返回在此字符串中最后一次出现的指定子字符串的索引。 </li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-java">import java.util.Scanner;public class Main{    public static void main(String[] args)    {        Scanner in = new Scanner(System.in);        int n = in.nextInt();        String [] s = new String[10005];        for(int i = 0; i &lt; n; ++i)            s[i] = in.next();        String tem = in.next();        for(int i = 0; i &lt; n; ++i)        {            int cnt = 0;            int pos = tem.indexOf(s[i], 0);            while(pos != -1)            {                cnt++;                pos = tem.indexOf(s[i], pos + 1);            }            System.out.print(cnt);            if(i == n - 1)                System.out.println();            else                System.out.print(&#39; &#39;);        }        in.close();    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のJAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P3389 高斯消元法(模板)</title>
      <link href="2019/07/26/%E6%B4%9B%E8%B0%B7-P3389-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95-%E6%A8%A1%E6%9D%BF/"/>
      <url>2019/07/26/%E6%B4%9B%E8%B0%B7-P3389-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h1><blockquote><p>设增广矩阵C = (A, b)，其中A为方阵，高斯消元法是将系数矩阵A化为对角矩阵，然后用变化后的解向量中每一个元除以相应自变量的系数即可得到该自变量的估计值</p><p>代码须满足：方程个数 == 未知量的个数</p></blockquote><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;double a[105][105];int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n + 1; ++j)            scanf(&quot;%lf&quot;, &amp;a[i][j]);    for(int i = 1; i &lt;= n; ++i)    {        ///据说将系数绝对值最大的方程转移到被减的这一行，可以减小误差        ///1. 遍历行,选出该列最大系数        int mmax = i;        for(int j = i + 1; j &lt;= n; ++j)            if(fabs(a[j][i]) &gt; fabs(a[mmax][i]))                mmax = j;        ///2. 交换两行        for(int j = 1; j &lt;= n + 1; ++j)            swap(a[i][j],a[mmax][j]);        ///3. 特例特判(最大值等于0则说明该列都为0，肯定无解)        if(!a[i][i])        {            puts(&quot;No Solution&quot;);            return 0;        }        ///4. 将第i列除第i行的其余元素化为0        for(int j = 1; j &lt;= n; ++j)            if(j != i)            {                double temp = a[j][i] / a[i][i];                for(int k = i ; k &lt;= n + 1; ++k)                    a[j][k] -= a[i][k] * temp;            }    }///化增广矩阵，使系数变为对角矩阵    for(int i = 1; i &lt;= n; ++i)        printf(&quot;%.2f\n&quot;, a[i][n+1] / a[i][i]);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の高斯消元法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天踩的坑</title>
      <link href="2019/07/25/A%E4%BB%8A%E5%A4%A9%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
      <url>2019/07/25/A%E4%BB%8A%E5%A4%A9%E8%B8%A9%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h3 id="今天也进坑了吗？"><a href="#今天也进坑了吗？" class="headerlink" title="今天也进坑了吗？"></a>今天也进坑了吗？</h3><a id="more"></a><blockquote><ol><li><p>csv文件里的内容为字符串，强转类型才能处理</p></li><li><p>age、fare两项内容数据量不同，同时处理时其中一项内容读到了空白行…</p></li><li><p>可转int的字符串里混有可转float的字符串，清洗?</p></li></ol><p>2019-07-25</p><ol><li>学算法时测试别人的代码，本该输出一个两位小数，却输出了一个超长的大数，心想：<del>答案都不对还好意思贴出代码来？</del> 后来发现人家代码double是用%lf输出的，在我用的编译器里只能用%f</li></ol><p>2019-07-27</p><ol><li>忘记了 0! == 1而非0，不仅如此，固执的认为 2 % 1 == 1，我是真无语……</li></ol><p>2019-07-28</p><ol><li><img src="https://i.postimg.cc/8PLmJj6s/NRG9-FK-RJC-T33-C-WL6-P-Z5.png" alt="Debug two hours"></li></ol><p>2019-08-06</p><ol><li>0写成1了。程序设计就是这样，哪里j写成i了，0写成1了，l写成1了，一点手误就把直线变成折线了，目的地便不再是正确的答案了。十几个变量名字不许你弄混，明确每一个的意义。</li></ol><p>2019-08-07</p><ol><li>n &lt; 10000, 计算 n ^ 4</li></ol><pre><code class="lang-c++">ll function(int n){    return n * n * n * n;}</code></pre><blockquote><p>n x n x n x n 超过了int，此时返回一个溢出值，即使你定义返回值为long long也没用</p></blockquote><p>9.bool数组初始化为-1了!!!</p><ol><li><p>SDNUOJ 1334 </p><pre><code class="lang-c++">scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);//TLEscanf(&quot;%lld %lld&quot;, &amp;a, &amp;b);//AC</code></pre><p>少让程序为你做些东西！</p></li></ol></blockquote><h2 id="builtin-popcount-计算一个十进制数的二进制形式里有几个1"><a href="#builtin-popcount-计算一个十进制数的二进制形式里有几个1" class="headerlink" title="__builtin_popcount()计算一个十进制数的二进制形式里有几个1"></a>__builtin_popcount()计算一个十进制数的二进制形式里有几个1</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    char s[50];    scanf(&quot;%s&quot;, s);    long a = strtol(s, NULL, 2);    cout &lt;&lt; a &lt;&lt; &#39;\n&#39;;    int num = __builtin_popcount(a);    cout &lt;&lt; num &lt;&lt; &#39;\n&#39;;}/// s : 1101/// s : 13/// s : 3</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1134 Facebook Floyd闭包传递计数</title>
      <link href="2019/07/24/SDNUOJ-1134-Facebook-Floyd%E9%97%AD%E5%8C%85%E4%BC%A0%E9%80%92%E8%AE%A1%E6%95%B0/"/>
      <url>2019/07/24/SDNUOJ-1134-Facebook-Floyd%E9%97%AD%E5%8C%85%E4%BC%A0%E9%80%92%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>据说任意两个人之间最多只需要借助六个人就可以认识对方, 现在给你n个好友的关系，问你这其中每个人之间最多借助几个人就能认识对方？ </p></blockquote><a id="more"></a><blockquote><p>题目链接 ： <a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1134" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/problem/show/1134</a></p></blockquote><h3 id="Floyd闭包传递"><a href="#Floyd闭包传递" class="headerlink" title="Floyd闭包传递"></a>Floyd闭包传递</h3><blockquote><p>需要计数时，将bool型数组改为int，条件转移时对应题目改一下，相乘还是相加</p><p>Floyd不能“剪枝”，必须完整地执行完</p><p>新找到的路可能比当前最短路长，也可能更短，取二者min</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, m;int beat[205][205];map&lt;string, int&gt; mp;void floyd(){    for(int k = 1; k &lt;= n; ++k)        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(beat[i][k] &amp;&amp; beat[k][j])                    if(beat[i][j] == 0)                        beat[i][j] = beat[j][i] = beat[i][k] + beat[k][j];                    else                        beat[i][j] = beat[j][i] = min(beat[i][j], beat[i][k] + beat[k][j]);}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int cnt = 1;    string c, d;    memset(beat, 0, sizeof(beat));    for(int i = 0; i &lt; m; ++i)    {        cin &gt;&gt; c &gt;&gt; d;        if(!mp[c])            mp[c] = cnt++;        if(!mp[d])            mp[d] = cnt++;        beat[ mp[c] ][ mp[d] ] = beat[ mp[d] ][ mp[c] ] = 1;    }    floyd();    bool flag = 1;    int ans = 0;    for(int i = 1; i &lt;= n; ++i)        for(int j = i + 1; j &lt;= n; ++j)        {            if(beat[i][j] == 0 &amp;&amp; beat[j][i] == 0)            {                flag = 0;                break;            }            else if(beat[i][j] &gt; ans)                ans = beat[i][j];        }    if(flag)        cout &lt;&lt; ans - 1 &lt;&lt; &#39;\n&#39;;    else        cout &lt;&lt; &quot;No&quot; &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>用1表示两人原本就认识，最终答案减一即可。如果用0，0 + 0永远是0。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1118 单词统计(AC自动机)</title>
      <link href="2019/07/24/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>2019/07/24/SDNUOJ-1118-%E5%8D%95%E8%AF%8D%E7%BB%9F%E8%AE%A1-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给定一个字符串和若干个单词，统计这些单词在这个字符串中出现的次数。 </p></blockquote><a id="more"></a><blockquote><p>题目链接 ： <a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1118" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/problem/show/1118</a></p></blockquote><h3 id="Sample-Input1"><a href="#Sample-Input1" class="headerlink" title="Sample Input1"></a>Sample Input1</h3><pre><code class="lang-c++">5aabbaabababaababa</code></pre><h3 id="Sample-Output1"><a href="#Sample-Output1" class="headerlink" title="Sample Output1"></a>Sample Output1</h3><blockquote><p>4 2 2 2 1</p></blockquote><h3 id="Sample-Input2-可能卡的样例"><a href="#Sample-Input2-可能卡的样例" class="headerlink" title="Sample Input2(可能卡的样例)"></a>Sample Input2(可能卡的样例)</h3><pre><code class="lang-c++">3aaaaaaaaa</code></pre><h3 id="Sample-Output2"><a href="#Sample-Output2" class="headerlink" title="Sample Output2"></a>Sample Output2</h3><blockquote><p>2 2 2</p></blockquote><h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><blockquote><p>巧妙的数据结构（Trie） + 灵活的算法（KMP) = 巧妙灵活的算法(AC自动机)</p><p>真的是，二者结合地天衣无缝</p></blockquote><h2 id="By-the-way"><a href="#By-the-way" class="headerlink" title="By the way"></a>By the way</h2><blockquote><p>Trie里有个sum[N]数组是统计输入(Input)里单词重复出现次数的</p><p>此题询问最后给出的长字符串中输入(Input)的每个字符串出现次数的</p><p>好像说的不清楚，反正知道有那么两个东西不是一回事就行</p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p>此题要在主串里查询每个输入串(<strong>可能重复</strong>)出现次数</p><ol><li><p>用上Trie中的is[N]数组标记每个字符串结束处结点</p></li><li><p>开一个fro[N]数组记录答案（每个字符串出现次数）</p><p>最后遍历结点数(cnt)，剔除(is[i] == 0)的fro[i]，输出剩下的(本来就是有序的)</p><p>这个时候开始WA了，因为没处理像上方Input2那样的情况</p></li><li><p>我想了一个办法（我竟然能在一个较陌生的算法上搞小动作！！！）：</p><p>开一个amount[n]数组，记录每个输入字符串尾字母后的结束结点</p><p>最后只需要遍历输入串数(amo)一个个输出：</p></li></ol></blockquote><pre><code class="lang-c++">for(int i = 0; i &lt; amo; ++i)            printf(&quot;%d%c&quot;, fro[ amount[i] ], i == amo - 1 ? &#39;\n&#39; : &#39; &#39;);</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N =  5 * 1e5 + 9;bool is[N];int cnt = 0, amo = 0, fail[N], fro[N], trie[N][26];int amount[10005];void clean(int num){    fail[num] = 0, fro[num] = 0;    memset(trie[num], 0, sizeof(trie[num]));}void plug(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(!trie[root][x])        {            ++cnt;            clean(cnt);            trie[root][x] = cnt;        }        root = trie[root][x];    }    is[root] = 1;///    sum[root]++;统计单词在树中出现次数    amount[amo++] = root;}void getfail(){    queue&lt;int&gt; q;    for(int i = 0; i &lt; 26; ++i)        if(trie[0][i])            fail[ trie[0][i] ] = 0, q.push(trie[0][i]);    while(!q.empty())    {        int now = q.front();        q.pop();        for(int i = 0; i &lt; 26; ++i)        {            if(trie[now][i])            {                fail[ trie[now][i] ] = trie[ fail[now] ][i];                q.push(trie[now][i]);            }            else                trie[now][i] = trie[ fail[now] ][i];        }    }}void query(char * s){    int now = 0, len = strlen(s);    for(int i = 0; i &lt; len; ++i)    {        now = trie[now][ s[i] - &#39;a&#39; ];        for(int j = now; j ; j = fail[j])            if(is[j])                fro[j]++;    }}char s[1000005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        cnt = 0, amo = 0;        memset(is, 0, sizeof(is));        memset(amount, 0, sizeof(amount));        clean(0);        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%s&quot;, s);            plug(s);        }        getfail();        scanf(&quot;%s&quot;, s);        query(s);        for(int i = 0; i &lt; amo; ++i)            printf(&quot;%d%c&quot;, fro[ amount[i] ], i == amo - 1 ? &#39;\n&#39; : &#39; &#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串のAC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2222 Keywords Search</title>
      <link href="2019/07/23/HDU-2222-Keywords-Search/"/>
      <url>2019/07/23/HDU-2222-Keywords-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h1><blockquote><p>I have a Trie</p><p>I have a KMP</p><p>Uh, AC自动机！</p></blockquote><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote><p>AC自动机是以Trie的多模式匹配为基础，取了类似于KMP中nxt数组的作用，避免了Trie每次匹配失败的回溯过程，缩短了时间 </p></blockquote><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><blockquote><ol><li>建树（Trie）</li><li>BFS构造fail指针 (这里以及很多其他地方的“指针”是广义上的指针，只是一个int类型的变量存了一个值)</li><li>模式匹配（查询）</li></ol><p>学习博客： <a href="https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html" target="_blank" rel="noopener">https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html</a></p><p>理解博客： <a href="https://blog.csdn.net/bestsort/article/details/82947639" target="_blank" rel="noopener">https://blog.csdn.net/bestsort/article/details/82947639</a></p><p>(这篇博客里的模板没有初始化函数，做题会TLE，是的，没初始化也会TLE！)</p><p>（在Trie里，字母是存在 ‘边’ 上的，而他写在节点上了）</p><p>模板出处：<a href="https://www.cnblogs.com/KonjakJuruo/p/5686398.html" target="_blank" rel="noopener">https://www.cnblogs.com/KonjakJuruo/p/5686398.html</a></p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N =  2 * 1e6 + 9;int cnt = 0, fail[N], sum[N], trie[N][26];void clean(int num){    sum[num] = 0, fail[num] = 0;    memset(trie[num], 0, sizeof(trie[num]));}void plug(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(!trie[root][x])            {                ++cnt;                clean(cnt);                trie[root][x] = cnt;            }        root = trie[root][x];    }    sum[root]++;}void getfail(){    queue&lt;int&gt; q;    for(int i = 0; i &lt; 26; ++i)        if(trie[0][i])            fail[ trie[0][i] ] = 0, q.push(trie[0][i]);    while(!q.empty())    {        int now = q.front();        q.pop();        for(int i = 0; i &lt; 26; ++i)        {            if(trie[now][i])            {                fail[ trie[now][i] ] = trie[ fail[now] ][i];                q.push(trie[now][i]);            }            else                trie[now][i] = trie[ fail[now] ][i];        }    }}int query(char * s){    int now = 0, ans = 0, len = strlen(s);    for(int i = 0; i &lt; len; ++i)    {        now = trie[now][ s[i] - &#39;a&#39; ];        for(int j = now; j &amp;&amp; sum[j] != -1; j = fail[j])        {            ans += sum[j];            sum[j] = -1;///标记以示遍历过        }    }    return ans;}char s[1000005];int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int n;        scanf(&quot;%d&quot;, &amp;n);        clean(0);                       ///没有这个会TLE        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%s&quot;, s);            plug(s);        }        getfail();        scanf(&quot;%s&quot;, s);        cout &lt;&lt; query(s) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 字符串のAC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1251 统计难题 codevs 4189 字典</title>
      <link href="2019/07/22/HDU-1251-%E7%BB%9F%E8%AE%A1%E9%9A%BE%E9%A2%98-codevs-4189-%E5%AD%97%E5%85%B8/"/>
      <url>2019/07/22/HDU-1251-%E7%BB%9F%E8%AE%A1%E9%9A%BE%E9%A2%98-codevs-4189-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><blockquote><p>字典树，Trie树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串(但不仅限于字符串)。</p><p>所以经常被搜索引擎系统用于文本词频统计  </p></blockquote><a id="more"></a><blockquote><p>学习：<a href="https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html" target="_blank" rel="noopener">https://www.cnblogs.com/TheRoadToTheGold/p/6290732.html</a></p></blockquote><h3 id="HDU-1251（前缀出现次数）"><a href="#HDU-1251（前缀出现次数）" class="headerlink" title="HDU 1251（前缀出现次数）"></a>HDU 1251（前缀出现次数）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;char s[12];int tot, trie[400005][26], sum[400005];void plug(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(trie[root][x] == 0)            trie[root][x] = ++tot;        sum[ trie[root][x] ]++;  ///记下该前缀出现次数        root = trie[root][x];    }}int found(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(trie[root][x] == 0)            return 0;        root = trie[root][x];    }    return sum[root];}int main(){    while(gets(s))///保证接受&#39;空行&#39;这一输入    {        if(strlen(s) == 0)            break;        else            plug(s);    }    while(cin &gt;&gt; s)        cout &lt;&lt; found(s) &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="Codevs-4189（前缀（或整个单词）查找）"><a href="#Codevs-4189（前缀（或整个单词）查找）" class="headerlink" title="Codevs 4189（前缀（或整个单词）查找）"></a>Codevs 4189（前缀（或整个单词）查找）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2000005;char s[50];int tot, n;int trie[N][26];///bool is[N]; 查询整个单词时用到///s[]作为全局变量，这里可以省略形参void plug(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(trie[root][x] == 0)            trie[root][x] = ++tot;        root = trie[root][x];    }    ///is[root] = 1;}bool found(char * s){    int root = 0;    for(int i = 0; s[i]; ++i)    {        int x = s[i] - &#39;a&#39;;        if(trie[root][x] == 0)            return 0;        root = trie[root][x];    }    return 1;    ///查询整个单词时，return is[root];}int main(){    tot = 0;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)    {        cin &gt;&gt; s;        plug(s);    }    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)    {        cin &gt;&gt; s;        if(found(s))            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 p1494 小Z的袜子</title>
      <link href="2019/07/22/%E6%B4%9B%E8%B0%B7-p1494-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/"/>
      <url>2019/07/22/%E6%B4%9B%E8%B0%B7-p1494-%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>详见链接: <a href="https://www.luogu.org/problemnew/show/P1494" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1494</a></p></blockquote><a id="more"></a><h2 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h2><blockquote><p>学习一个算法，除了理解它的原理之外，要清楚它的特点，以此来思考适合解决何种问题</p><p>莫队算法：<strong>区间各元素属性和（累积）查询问题</strong></p></blockquote><h3 id="此题更新操作"><a href="#此题更新操作" class="headerlink" title="此题更新操作"></a>此题更新操作</h3><blockquote><p>分母就是n * n - n(表示两两袜子之间的随机组合)，分子是一个累加和 - n，累加的内容是该区间内每种颜色i出现次数sum[i]的平方</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int N = 50010;int n, m;///n个元素,m个询问;int num, bel[N];///分块个数，每块标号int a[N], sum[N];///元素值与其在相应区间上出现次数ll ans;///当前区间查询所得答案struct edge{    int l, r, id;    ll fro, bac;}e[N];bool cmp(edge a, edge b){    return bel[a.l] == bel[b.l] ? a.r &lt; b.r : a.l &lt; b.l;}bool cmp_id(edge a, edge b){    return a.id &lt; b.id;}ll gcd(ll a, ll b){    return b == 0 ? a : gcd(b, a % b);}void update(int x, int change){    ans -= sum[ a[x] ] * sum[ a[x] ];///减去原来的答案    sum[ a[x] ] += change;           ///更新    ans += sum[ a[x] ] * sum[ a[x] ];///加上更新后的答案}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    ///1.输入元素并分块    num = sqrt(n);    for(int i = 1; i &lt;= n; ++i)///下标需从1开始    {        scanf(&quot;%d&quot;, &amp;a[i]);        bel[i] = i / num + 1;    }    ///2.输入查询区间并记下id并排序    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;e[i].l, &amp;e[i].r);        e[i].id = i;    }    sort(e, e + m, cmp);    ///3.移动指针更新所查询区间    int l = 1, r = 0;    for(int i = 0; i &lt; m; ++i)    {        while(l &lt; e[i].l)            update(l, -1), ++l;        while(l &gt; e[i].l)            update(l - 1, 1), --l;        while(r &lt; e[i].r)            update(r + 1, 1), ++r;        while(r &gt; e[i].r)            update(r, -1), --r;        if(e[i].l == e[i].r)        {            e[i].fro = 0;            e[i].bac = 1;            continue;        }        e[i].fro = ans - (e[i].r - e[i].l + 1);        e[i].bac = 1LL * (e[i].r - e[i].l + 1) * (e[i].r - e[i].l);        ll tem = gcd(e[i].fro, e[i].bac);        e[i].fro /= tem;        e[i].bac /= tem;    }    ///4.排回原序输出答案    sort(e, e + m, cmp_id);    for(int i = 0; i &lt; m; ++i)        cout &lt;&lt; e[i].fro &lt;&lt; &#39;/&#39; &lt;&lt; e[i].bac &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>更多关于此题：<a href="https://www.cnblogs.com/Paul-Guderian/p/6933799.html" target="_blank" rel="noopener">https://www.cnblogs.com/Paul-Guderian/p/6933799.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の莫队算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷 P2709 小B的询问(分块莫队)</title>
      <link href="2019/07/22/%E6%B4%9B%E8%B0%B7-P2709-%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE-%E5%88%86%E5%9D%97%E8%8E%AB%E9%98%9F/"/>
      <url>2019/07/22/%E6%B4%9B%E8%B0%B7-P2709-%E5%B0%8FB%E7%9A%84%E8%AF%A2%E9%97%AE-%E5%88%86%E5%9D%97%E8%8E%AB%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h2><blockquote><p>首先，这是一个离线算法</p><p>何为“离线”？</p><p>是指主方独自运转，主方与外界没有任何交互，也就是说运转时不接受外界的信号(自然没有一一对应的反馈)——非即时反馈。</p></blockquote><a id="more"></a><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><blockquote><p>①.输入元素并分块(注意下标从1开始)</p><p>②.输入查询区间，记下id，并排序(cmp)</p><p>③.移动指针更新所查询区间</p><p>④.排回原序并输出答案(cmp_id)</p></blockquote><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><blockquote><p>推导出区间中增减一个元素后答案的变化</p></blockquote><h2 id="算法标志"><a href="#算法标志" class="headerlink" title="算法标志"></a>算法标志</h2><blockquote><p>四个while</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>小B有一个序列，包含N个1~K之间的整数。他一共有M个询问，每个询问给定一个区间[L..R]，求Sigma(c(i)^2)的值,其中i的值从1到K，其中c(i)表示数字i在[L..R]中的重复次数。小B请你帮助他回答询问。 </p><p>题目链接： <a href="https://www.luogu.org/problemnew/show/P2709" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P2709</a></p></blockquote><h3 id="关于update函数"><a href="#关于update函数" class="headerlink" title="关于update函数"></a>关于update函数</h3><blockquote><p>莫队算法解决的多为累加和问题，区间更新步骤：</p><p>1.减去原来的答案</p><p>2.更新</p><p>3.加上更新后的答案</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ll long longusing namespace std;const int N = 50010;int n, m, k;///n个元素,m个询问;int num, bel[N];///分块个数，每块标号int a[N], sum[N];///元素值与其在相应区间上出现次数ll ans;///当前区间查询所得答案struct edge{    int l, r, id;    ll val;}e[N];bool cmp(edge a, edge b){    return bel[a.l] == bel[b.l] ? a.r &lt; b.r : a.l &lt; b.l;}bool cmp_id(edge a, edge b){    return a.id &lt; b.id;}void update(int x, int change){    ans -= sum[ a[x] ] * sum[ a[x] ];///减去原来的答案    sum[ a[x] ] += change;           ///更新    ans += sum[ a[x] ] * sum[ a[x] ];///加上更新后的答案}int main(){    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);    ///1.输入元素并分块    num = sqrt(n);    for(int i = 1; i &lt;= n; ++i)///下标需从1开始    {        scanf(&quot;%d&quot;, &amp;a[i]);        bel[i] = i / num + 1;    }    ///2.输入查询区间并记下id并排序    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;e[i].l, &amp;e[i].r);        e[i].id = i;    }    sort(e, e + m, cmp);    ///3.移动指针更新所查询区间    int l = 1, r = 0;    for(int i = 0; i &lt; m; ++i)    {        while(l &lt; e[i].l)            update(l, -1), ++l;        while(l &gt; e[i].l)            update(l - 1, 1), --l;        while(r &lt; e[i].r)            update(r + 1, 1), ++r;        while(r &gt; e[i].r)            update(r, -1), --r;        e[i].val = ans;    }    ///4.排回原序输出答案    sort(e, e + m, cmp_id);    for(int i = 0; i &lt; m; ++i)        cout &lt;&lt; e[i].val &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の莫队算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1848 Fibonacci again and again</title>
      <link href="2019/07/20/HDU-1848-Fibonacci-again-and-again/"/>
      <url>2019/07/20/HDU-1848-Fibonacci-again-and-again/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>三堆石子，任取F[i]（斐波那契数）个，取光为胜</p></blockquote><a id="more"></a><blockquote><p>题目链接 : <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1848" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1848</a></p></blockquote><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><blockquote><p><strong>游戏和的SG函数等于各个游戏SG函数的Nim和</strong> </p></blockquote><h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><blockquote><p>首先定义mex(minimal excludant)运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如mex{0,1,2,4}=3、mex{2,3,5}=0、mex{}=0。</p><p>对于任意状态 x ， 定义 SG(x) = mex(S), 其中 S 是 x 后继状态的SG函数值的集合。</p><p>如 x 有三个后继状态分别为 SG(a),SG(b),SG(c)，那么SG(x) = mex{SG(a),SG(b),SG(c)}。</p><p>这样集合S的终态必然是空集，所以SG函数的终态为 SG(x) = 0,当且仅当 x 为必败点P时。</p><p>步骤：</p><p>1、使用 数组f 将 可改变当前状态 的方式记录下来。</p><p>2、然后我们使用 另一个数组 将当前状态x 的后继状态标记。</p><p>3、最后模拟mex运算，也就是我们在标记值中 搜索 未被标记值 的最小值，将其赋值给SG(x)。</p><p>4、我们不断的重复 2 - 3 的步骤，就完成了 计算1~n 的函数值。</p><p>原文出处： <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6921829.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/6921829.html</a></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 20;///改变当前状态的方案数const int MAXN = 10010;///石子数(状态数,对应打表上限n)int f[25];         ///1.预处理：可改变当前状态的方案数int SG[MAXN];     ///0 ~ n 的SG函数值（n是打表上限）bool st[MAXN];     /// i 后继状态的集合void getSG(int n){    memset(SG, 0, sizeof(SG));    ///SG[0] = 0;    for(int i = 1; i &lt;= n; ++i)///当前石子数    {        memset(st, 0, sizeof(st));        ///2.枚举f[N]中每种方案并标记        for(int j = 0; f[j] &lt;= i &amp;&amp; j &lt;= N; ++j)            st[ SG[ i - f[j] ] ] = 1;        ///3.模拟mex运算(最小的不属于集合st的非负整数)        for(int j = 0; ; ++j)            if(!st[j])            {                SG[i] = j;                break;            }    }}int main(){    f[0] = f[1] = 1;    for(int i = 2; i &lt;= 22; ++i)        f[i] = f[i - 1] + f[i - 2];    getSG(1000);    int a, b, c;    while(~scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c))    {        if(a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0)            break;        if(SG[a] ^ SG[b] ^ SG[c])            cout &lt;&lt; &quot;Fibo&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;Nacci&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>各量对应清楚，易写混，易RE</p><p>还有 == 优先级高于 ^(位运算的优先级仅优于赋值运算符、逗号运算符)</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>银联高校极客挑战赛 初赛 第一场</title>
      <link href="2019/07/20/%E9%93%B6%E8%81%94%E9%AB%98%E6%A0%A1%E6%9E%81%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
      <url>2019/07/20/%E9%93%B6%E8%81%94%E9%AB%98%E6%A0%A1%E6%9E%81%E5%AE%A2%E6%8C%91%E6%88%98%E8%B5%9B-%E5%88%9D%E8%B5%9B-%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://i.loli.net/2019/07/20/5d32bf45af9fe36355.png" alt="Description"></p><a id="more"></a><h2 id="这题的坑跟今年山东省赛（ACM）C题相同"><a href="#这题的坑跟今年山东省赛（ACM）C题相同" class="headerlink" title="这题的坑跟今年山东省赛（ACM）C题相同"></a>这题的坑跟今年山东省赛（ACM）C题相同</h2><blockquote><p>看题目描述最后一句话：在这M个赛季<strong>过程中</strong>，最高净胜场是多少？</p><p>是过程中，而不是整个赛季结束后！</p><p>若完成一个循环形式呈“盈利式”，则最佳状态取在首场“单位循环最佳收益”完成后</p><p>若完成一个循环形式呈“亏损式”，则最佳状态取在末场”单位循环最佳收益”完成后</p><p>关于“单位循环最佳收益”best：</p><p>如  +1 +1 +1 -1 -1 -1 + 2 -1</p><p>best取3，取在第三位后，而非第七位(+2)后</p><p>而“单位循环固定收益”basis为 1</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longint main(){    ll t, n, k, ck, m, cnt, num, num_max;    char ch;    scanf(&quot;%lld&quot;, &amp;t);    while(t--)    {        cnt = 0, num_max = num = 0;        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;k, &amp;m);        ck = k;        getchar();        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%c&quot;, &amp;ch);            if(ch == &#39;1&#39;)                cnt++, num++;            else            {                if(ck)                    ck--;                else                    num--;            }            if(num &gt; num_max)                num_max = num;        }        if(n - cnt &lt;= k)            cout &lt;&lt; m * cnt &lt;&lt; &#39;\n&#39;;        else        {            if(n - cnt - k &lt;= cnt)///卡用光仍有输场                cout &lt;&lt; (m - 1) * (2 * cnt - n + k) + num_max &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; (num_max &gt; 0 ? num_max : 0) &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><blockquote><p>省赛C题更狠，那题“单位循环最佳收益”与“单位循环固定收益”是不同向的！“收益”有了方向！</p><p>完成一个循环呈“盈利式”，但最佳状态也可能取在第一场的“单位循环最佳收益”完成后！</p><p>假设只有两次循环时，best = 5，与x轴夹角为0°，basis = 2， 与x轴夹角180°（接近180即可），这样一来，正确答案应为5，答案7 (2 + 5)就是错误答案了</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1850 Being a Good Boy in Spring</title>
      <link href="2019/07/20/HDU-1850-Being-a-Good-Boy-in-Spring/"/>
      <url>2019/07/20/HDU-1850-Being-a-Good-Boy-in-Spring/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>尼姆博弈求先手胜出方案数</p></blockquote><a id="more"></a><blockquote><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1850" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1850</a></p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>尼姆博弈，每堆数目异或和(flag),若为0则必败，输出0</p><p>若flag != 0，则有必胜方案</p><p>取 a1 ^ a2 ^ a3 ^ ··· ^ ak ^ ··· ^ an = flag</p><p>取 b = a1 ^ a2 ^ a3 ^ ··· ^ a[k - 1] ^ a[k + 1] ^ ··· ^an (略去ak)</p><p>则上式改为 b ^ ak = flag</p><p>若要从ak中取走c使flag = 0</p><p>则(ak - c) == b (两个相同的数字异或结果为0)</p><p> 上式三者皆为正整数，意味着需满足条件 <strong>ak &gt; b</strong></p><p>又∵ <strong>flag = b ^ ak</strong></p><p>∴ <strong>flag ^ ak = (b ^ ak) ^ ak = b &lt; ak</strong></p><p>如此一来，对于每一个a[i], 若<strong>flag ^ a[i] &lt; a[i]</strong>， 则有这样一种方案可行</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[1005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        int flag = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            flag ^= a[i];        }        if(!flag)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else        {            int cnt = 0;            for(int i = 0; i &lt; n; ++i)                if((flag ^ a[i]) &lt; a[i])                    cnt++;            cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1800 Flying to the Mars</title>
      <link href="2019/07/19/HDU-1800-Flying-to-the-Mars/"/>
      <url>2019/07/19/HDU-1800-Flying-to-the-Mars/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出n，与n个字符串，求出现次数最多的字符串出现的次数</p><p>（给出n个大数，求众数出现次数）</p></blockquote><a id="more"></a><blockquote><p>链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1800" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1800</a></p></blockquote><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>mapTLE了，即使<code>ios::sync_with_stdio(false);</code></p><p>而哈希是解决普通算法TLE的，尤其是mapTLE的</p><p>字符串的Hash才有点真正的密码的味道</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">///Hash 是解决 TLE 问题的，尤其是用mapTLE了///字符串的Hash才有点真正Hash的味道#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longchar s[40];string str;int has[3005];int hashit(char * s){    ll base = 131;    ll res = 0;    while(*s == &#39;0&#39;)  ///指针所指字符为‘0’        s++;    while(*s)         ///指针不指向NULL    {        res = res * base + *s;        s++;    }    return (res &amp; 0x7fffffff); ///取了res较低位的31位，符号位为0(正)}int Hashit(string str)///slower 312 ms than char * s{    ll base = 131;    ll res = 0;    int pos = str.find_first_not_of(&#39;0&#39;, 0);    if(pos == -1)        return 0;    int sz = str.size();    for(int i = pos; i &lt; sz; ++i)        res = res * base + str[i];    return (res &amp; 0x7fffffff);}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        map&lt;int, int&gt; mp;//        int ans = 0, tem = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%s&quot;, s);            has[i] = hashit(s);//            tem = hashit(s);//            mp[tem]++;//            if(mp[tem] &gt; ans)//                ans = mp[tem];//            cin &gt;&gt; str;//            has[i] = Hashit(str);        }        sort(has, has + n);        int tem = 1, ans = 1;        for(int i = 1; i &lt; n; ++i)        {            if(has[i] == has[i - 1])            {                tem++;                ans = max(ans, tem);            }            else                tem = 1;        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="一点发现"><a href="#一点发现" class="headerlink" title="一点发现"></a>一点发现</h3><blockquote><p>string 会比 char * s 慢</p><p>调用map 会比 数组改装 慢</p><p>结论：封装好的东西往往要比自己写的<strong>原生态</strong>的东西要慢 -&gt; 自己造轮子是合理的</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今日份的奇怪小发现</title>
      <link href="2019/07/19/%E4%BB%8A%E6%97%A5%E4%BB%BD%E7%9A%84%E5%A5%87%E6%80%AA%E5%B0%8F%E5%8F%91%E7%8E%B0/"/>
      <url>2019/07/19/%E4%BB%8A%E6%97%A5%E4%BB%BD%E7%9A%84%E5%A5%87%E6%80%AA%E5%B0%8F%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Interesting"><a href="#Interesting" class="headerlink" title="Interesting"></a>Interesting</h3><blockquote><ol><li>0x7fffffff = 2 ^ 31 - 1  （MAX_INT）</li><li>0x3f3f3f3f ≈ 1e9 （略小于MAX_INT的一半）</li><li>char 与 int 作四则运算时char类型<strong>自动</strong>转为其对应Ascall码值大小的int值</li><li>形参为string字符串的函数，可以传入char <em> s字符数组去执行（看来字符数组等级高于字符串，字符数组可<em>*自动</em></em>转字符串）</li><li>异或交换两个整数值的方法：不用swap，不借助第三者</li></ol></blockquote><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int sz(string s){    return s.length();}int sszz(char * s){    int num = 0;    while(*s)        num++, s++;    return num;}int main(){    int a = 0x7fffffff;///2 ^ 31 - 1    int b = 0x3f3f3f3f;/// ≈ 1e9    cout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; b &lt;&lt; &#39;\n&#39;;    ///char 与 int 作四则运算时    ///char类型自动转为其对应Ascall码值大小的int值    char ch = &#39;0&#39;;    cout &lt;&lt; sizeof(ch) &lt;&lt; &#39;\n&#39;;     /// 1    int c = 2;    int d = c * ch;    cout &lt;&lt; d &lt;&lt; &#39;\n&#39;;              /// 96 = 2 * 48    char e[100] = &quot;ABCD&quot;;    cout &lt;&lt; sizeof(e) &lt;&lt; &#39;\n&#39;;      /// 100    string str = &quot;XYZ&quot;;    cout &lt;&lt; sz(str) &lt;&lt; &#39;\n&#39;;//    cout &lt;&lt; sszz(str) &lt;&lt; &#39;\n&#39;;    ///报错    cout &lt;&lt; sz(e) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; sszz(e) &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="Code2"><a href="#Code2" class="headerlink" title="Code2"></a>Code2</h3><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){    srand((time(NULL)));    int a = rand();    int b = rand();    cout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; b &lt;&lt; &#39;\n&#39;;    a ^= b;    b ^= a;    a ^= b;    cout &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; b &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1425 sort 重温</title>
      <link href="2019/07/19/HDU-1425-sort-%E9%87%8D%E6%B8%A9/"/>
      <url>2019/07/19/HDU-1425-sort-%E9%87%8D%E6%B8%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个不同<strong>整数</strong>，从大到小输出前m个</p></blockquote><a id="more"></a><blockquote><p>数字多达百万，sort定然超时</p><p>我们在数轴上将输入的n个数字标记，从后向前遍历输出即可</p><p>这样省去了sort的时间，只要遍历的时间</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;//int main()//{//    int n, m, tem;//    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))//    {//        map&lt;int, bool&gt; mp;//        for(int i = 0; i &lt; n; ++i)//        {//            scanf(&quot;%d&quot;, &amp;tem);//            mp[tem] = 1;//        }//        int cnt = 0;//        for(int i = 500000; i &gt;= -500000 &amp;&amp; cnt &lt; m; --i)//            if(mp[i])//            {//                cout &lt;&lt; i &lt;&lt; &#39; &#39;;//                cnt++;//            }//        cout &lt;&lt; &#39;\n&#39;;//    }//    return 0;//}bool has[1000009];int main(){    int n, m, tem;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(has, 0, sizeof(has));        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            has[tem + 500000] = 1;        }        int cnt = 0;        for(int i = 1000000; i &gt;= 0 &amp;&amp; cnt &lt; m; --i)            if(has[i])            {                printf(&quot;%d%c&quot;, i - 500000,cnt == m - 1 ? &#39;\n&#39; : &#39; &#39;);                cnt++;            }    }    return 0;}</code></pre><blockquote><p>如上，我试过map，他不用坐标偏移，但更为耗时，毕竟使用哈希目的在于节约时间，所以哈希不要用map</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1496 Equations</title>
      <link href="2019/07/19/HDU-1496-Equations/"/>
      <url>2019/07/19/HDU-1496-Equations/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>a * x1 ^ 2 + b  * x2 ^ 2 + c * x3 ^ 2 + d * x4 ^ 2 = 0</p><p>给出a b c d，在一定范围内找出符合上述等式的方案数 </p></blockquote><a id="more"></a><h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><blockquote><p>前两项和作为一部分，遍历时hash数组记录结果，后两项和移到右边作为另一部分，遍历hash数组查找有无相同结果</p></blockquote><h3 id="数值区间决定hash空间"><a href="#数值区间决定hash空间" class="headerlink" title="数值区间决定hash空间"></a>数值区间决定hash空间</h3><blockquote><p>a、b、c、d区间对称，上限为50</p><p>x区间对称，上限为100，x * x上限为 10000</p><p>（x无需从-100开始遍历，因为需要的是x * x,所以只遍历正半轴即可，对于每一个可行的x，方案数乘2，因为有四个x（都是自变量），所以最终结果乘16 ）</p><p>a * x * x 上限为 500000，再加一个 b * x * x 上限 到达 1000000</p><p>因为a、b市对称区间，下限就到-1000000，进行坐标偏移，总共需要2000000的空间</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int has[2000100];int main(){    int a, b, c, d, ans;    while(~scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d))    {        if(a * b &gt; 0 &amp;&amp; b * c &gt; 0 &amp;&amp; c * d &gt; 0)        {            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;            continue;        }        ans = 0;        memset(has, 0, sizeof(has));        for(int i = 1; i &lt;= 100; ++i)            for(int j = 1; j &lt;= 100; ++j)                has[a * i * i + b * j * j + 1000000]++;        for(int i = 1; i &lt;= 100; ++i)            for(int j = 1; j &lt;= 100; ++j)                    ans += has[- c * i * i - d * j * j + 1000000];        cout &lt;&lt; ans * 16 &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希</title>
      <link href="2019/07/19/%E5%93%88%E5%B8%8C/"/>
      <url>2019/07/19/%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="About-Hash"><a href="#About-Hash" class="headerlink" title="About Hash"></a>About Hash</h2><blockquote><p>哈希是密码学的基础，理解哈希是理解数字签名和加密通信等技术的必要前提 </p><p> 哈希，英文是 hash ，本来意思是”切碎并搅拌“，有一种食物就叫 Hash ，就是把食材切碎并搅拌一下做成的。哈希函数的运算结果就是哈希值，通常简称为哈希。哈希函数有时候也翻译做散列函数 </p><p>原文出处： <a href="https://blog.csdn.net/xuhao885544/article/details/84751135" target="_blank" rel="noopener">https://blog.csdn.net/xuhao885544/article/details/84751135</a></p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2019/07/19/5d31095b03bfa42665.png" alt="The function of Hash"></p><h2 id="The-Job-of-Hash"><a href="#The-Job-of-Hash" class="headerlink" title="The Job of Hash"></a>The Job of Hash</h2><blockquote><p>给一个任意大小的数据生成出一个固定长度的数据，作为它的映射 </p></blockquote><h2 id="The-Features-of-Hash"><a href="#The-Features-of-Hash" class="headerlink" title="The Features of Hash"></a>The Features of Hash</h2><blockquote><ol><li>单向算法，给定数据 M 容易算出哈希值 X ，而给定 X 不能算出 M.(保证了安全问题)</li><li>独一无二，两个不同的数据，拥有不相同的哈希</li><li>长度固定，给定一种哈希算法，不管输入是多大的数据，输出长度都是固定的。 </li></ol></blockquote><h2 id="Collision"><a href="#Collision" class="headerlink" title="Collision"></a>Collision</h2><blockquote><p>由于哈希的长度是固定的，所以(输出)值域有限，而(输入)定义域无限，终会出现不同数据有相同哈希的情况，称为碰撞（collision）。</p><p>不同的哈希算法，哈希位数越多，也就基本意味着安全级别越高，或者说它的”抗碰撞性“就越好。 </p></blockquote><h2 id="The-Function-of-Hash"><a href="#The-Function-of-Hash" class="headerlink" title="The Function of Hash"></a>The Function of Hash</h2><blockquote><p>哈希的独一无二性，保证了如果数据在存储或者传输过程中有丝毫损坏，那么它的哈希就会变。哈希函数的最常见的一个作用就是进行完整性校验（ Integrity Check ），完整的意思是数据无损坏 </p></blockquote><h2 id="Application-example"><a href="#Application-example" class="headerlink" title="Application example"></a>Application example</h2><blockquote><p>网站注册: </p><p>当我们提交用户名密码的时候，用户名被会直接保存到网站的数据库中，但是密码却不是直接保存的，而是先把密码转换成哈希，保存到数据库中的其实是哈希。</p><p>所以，即使是公司后台管理人员，也拿不到用户的密码。这样，如果万一公司数据库泄露了，用户的密码依然是安全的。</p><p>而当用户自己登录网站的时候，输入密码提交到服务器，服务器上进行相同的哈希运算，因为输入数据没变，所以哈希也不会变，登录也就成功了</p></blockquote><h1 id="以下开启我的理解"><a href="#以下开启我的理解" class="headerlink" title="以下开启我的理解"></a>以下开启我的理解</h1><blockquote><p>a * x = b * y</p><p>输入a与b，x、y为某区间（假设为[1, 100]）内的整数，求共有多少方案满足上述等式</p></blockquote><h2 id="普通做法"><a href="#普通做法" class="headerlink" title="普通做法"></a>普通做法</h2><pre><code class="lang-c++">int ans = 0;for(int x = 1; x &lt;= 100; ++x)    for(int y = 1; y &lt;= 100; ++y)        if(a * x == b * y)            ans++;</code></pre><blockquote><p>复杂度O(n * n)</p><p>思考过程，会发现：</p><p>当x = 1时，我们用了O(n)的时间计算了每一个b * y（针对y的所有可能值），然后去跟a * x比较是否相等</p><p>然而，x = 2时，我们又用了O(n)的时间计算了每一个b * y</p><p>就这样，x = 3, 4, 5 …100时，我们做了n次<strong>重复</strong>计算，每次时间O(n)，就有了O(n * n)的时间复杂度</p><p>那么我们想着：第一次循环就记录下所有值，复杂度岂不降为O(n)?</p><p>于是就有了</p><blockquote><p>哈希</p></blockquote></blockquote><h2 id="哈希数组"><a href="#哈希数组" class="headerlink" title="哈希数组"></a>哈希数组</h2><blockquote><p>我们将枚举时的<strong>自变量(原象)</strong>作为哈希数组的<strong>下标</strong>，<strong>因变量(投影)</strong>作为哈希数组的<strong>储存值</strong>，这样可以将枚举过程的结果记录下来，省去了后续的重复枚举</p></blockquote><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><blockquote><p>因为自变量（原象）作为下标，而下标是非负整数，所以题目枚举的自变量必须为<strong>有界整数</strong>，为了保证“非负”，有时需要<strong>坐标偏移</strong></p></blockquote><pre><code class="lang-c++">int ans = 0;for(int i = 1; i &lt;= 100; ++i)    has[b * i]++;                //记录下所有的 b * yfor(int i = 1; i &lt;= 100; ++i)    ans += has[a * i];            //统计方案数</code></pre><blockquote><p>最后一行代码， a * x 有相等的 b * y时，<code>has[a * i] = 1</code>，方案数加一，否则<code>has[a * i] = 0</code>，方案数加零(不增)</p><p>对于此题，hash数组可以为bool类型，不过对于大多数题目，同一结果可能有不同的方案，hash数组必须用int类型 </p></blockquote><h2 id="总结Hash"><a href="#总结Hash" class="headerlink" title="总结Hash"></a>总结Hash</h2><blockquote><p>记录过程值，<strong>以空间换时间</strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の哈希 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于__int128</title>
      <link href="2019/07/18/%E5%85%B3%E4%BA%8E-int128/"/>
      <url>2019/07/18/%E5%85%B3%E4%BA%8E-int128/</url>
      
        <content type="html"><![CDATA[<h2 id="int128"><a href="#int128" class="headerlink" title="__int128"></a>__int128</h2><blockquote><p>编译器的gcc不支持这种数据类型，在codeblocks/Dev C++中无法编译</p><p>推荐在线编辑器 ：<a href="http://ideone.com/" target="_blank" rel="noopener">http://ideone.com/</a></p></blockquote><a id="more"></a><h2 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h2><pre><code class="lang-c++">#include &lt;iostream&gt;using namespace std;int main() {    // your code goes here    cout &lt;&lt; sizeof(int) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; sizeof(long long) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; sizeof(long double) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; sizeof(__int128) &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p><strong>Output</strong>:</p><p>4  =  21 4748 3647</p><p>8  ≈  9.2233720368548 * 10 ^ 18 </p><p>16  ≈  1.7014118346047 * 10 ^ 38 </p><p>16  ≈  1.7014118346047 * 10 ^ 38 </p></blockquote><h2 id="输入输出需自己写函数"><a href="#输入输出需自己写函数" class="headerlink" title="输入输出需自己写函数"></a>输入输出需自己写函数</h2><h3 id="Code-of-Input"><a href="#Code-of-Input" class="headerlink" title="Code of Input"></a>Code of Input</h3><pre><code class="lang-c++">void scan(__int128 &amp;x)//输入{    x = 0;    int f = 1;    char ch;    if((ch = getchar()) == &#39;-&#39;) f = -f;    else x = x*10 + ch-&#39;0&#39;;    while((ch = getchar()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        x = x*10 + ch-&#39;0&#39;;    x *= f;}</code></pre><h3 id="Code-of-Output"><a href="#Code-of-Output" class="headerlink" title="Code of Output"></a>Code of Output</h3><pre><code class="lang-c++">void print(__int128 x){    if(x &lt; 0)    {        x = -x;        putchar(&#39;-&#39;);    }     if(x &gt; 9) print(x/10);    putchar(x%10 + &#39;0&#39;);}</code></pre><h2 id="还有一件事！！！"><a href="#还有一件事！！！" class="headerlink" title="还有一件事！！！"></a>还有一件事！！！</h2><blockquote><p>看以下代码</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){    int a, b;    a = b = 2100000000;    long long c = a + b;    cout &lt;&lt; c &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>Output: -94967296</p><p>a、b皆为int类型，相加默认还是int，所以这里int溢出了，得到一个负值，再赋给一个long long类型的值已经晚了</p></blockquote><pre><code class="lang-c++">    int a, b;    a = b = 2100000000;    long long c = a;    c += b;</code></pre><blockquote><p>或者一开始a、b就设为long long类型</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2718 Smallest Difference</title>
      <link href="2019/07/18/POJ-2718-Smallest-Difference/"/>
      <url>2019/07/18/POJ-2718-Smallest-Difference/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出不重复的几个数字，将他们分成两部分，组成两个数字，求所有情况中差值最小时的差值</p></blockquote><a id="more"></a><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><blockquote><ol><li>若有0，则0必须用上</li><li>我之前认为，划分123时要划分成12、3与1、23，后来发现next_permutation会产生一个231，他划分可出23、1就是前面的1 、23</li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int a[12];        int cnt = 0;        char ch;        while(1)        {            scanf(&quot;%d%c&quot;, &amp;a[cnt++], &amp;ch);            if(ch == &#39;\n&#39;)                break;        }        int ans = 0x3f3f3f3f;        if(cnt == 2)        {            cout &lt;&lt; abs(a[0] - a[1]) &lt;&lt; &#39;\n&#39;;            continue;        }        do        {            int tem_fro = 0;            if(a[0] == 0 || a[cnt / 2] == 0)                continue;            for(int i = 0; i &lt; cnt / 2; ++i)                tem_fro = tem_fro * 10 + a[i];            int tem_bac = 0;            for(int i = cnt / 2; i &lt; cnt; ++i)                tem_bac = tem_bac * 10 + a[i];            int tem = abs(tem_fro - tem_bac);            if(tem &lt; ans)                ans = tem;        }while(next_permutation(a, a + cnt));        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 函数のnext_permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈</title>
      <link href="2019/07/18/%E5%8D%9A%E5%BC%88/"/>
      <url>2019/07/18/%E5%8D%9A%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<h1 id="巴什博弈（Bash-Game）"><a href="#巴什博弈（Bash-Game）" class="headerlink" title="巴什博弈（Bash Game）"></a>巴什博弈（Bash Game）</h1><blockquote><p>一堆n个物品，两人轮流取出（1~m）个，最终取完者胜出</p></blockquote><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><blockquote><p>若n = m + 1,先手必败<strong>——结论①</strong></p><p>-&gt;若n = k <em> (m + 1)，第二个人有可以使物品最终变为(m + 1)的办法，先手必败<em>*——结论②</em></em></p><p>-&gt;若n = k <em> (m + 1) + r,先手拿走r个，由结论②得后手必败、先手必胜<em>*——结论③</em></em></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">bool Bash_Game(int n, int m){    if(n % (m + 1) != 0)        return 1;    return 0;}</code></pre><blockquote><p>若有n堆，每堆a[i]个物品，两人来取，如何判断？</p><p>先考虑取的最大数目无上限即可以把一堆全部取完的情形：</p><ol><li><p>一堆，无论数目多少，先手必胜</p></li><li><p>两堆，从最简单的情况开始考虑：</p><p>1 、1时，后手必胜</p><p>1、n时，先手取走(n - 1)，变成上述情况，先手必胜</p><p>a 、b时(a &gt;= 2 &amp;&amp; b &gt;= 2)</p><p>若先手取走其中一堆会输</p><p>若先手取完变成1、n也会输（<strong>最终谁取完后局面为1、n谁就输了</strong>）</p><p>所以要保证先手取完还是c、b或a、d</p></li><li><p>N堆，也是：最终谁取完后局面变为1、n谁就输了</p></li></ol></blockquote><h1 id="尼姆博弈（Nimm-Game）"><a href="#尼姆博弈（Nimm-Game）" class="headerlink" title="尼姆博弈（Nimm Game）"></a>尼姆博弈（Nimm Game）</h1><blockquote><p>如上述n堆物品，每堆a[i]个,两人轮流取（从其中一堆中取，数目不限），是否有先手必胜策略？</p></blockquote><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><blockquote><p>如果把n堆抽象为n个非负整数,再将n个整数转化为二进制,然后对n个二进制数按位相加(<strong>不进位</strong>),若每一位相加都为偶数, 称这个状态为偶状态,否则称它为奇状态. （可以看到偶状态限制条件严苛）</p><p>可以证明:任何一个偶状态在其中一个数变小后一定成为奇状态,而一个奇状态一定可以通过改变一个数变成偶状态. </p><p>证明：</p><blockquote><ol><li>前一点很显然,因为一个数变小至少有一位发生改变,这一位就改变了原来的偶状态. </li><li>对于后一点,对于一个从高位到低位某一位和为奇的奇状态,必定有一个数的二进制表示在此位为1,对于后面的较低位和为奇的情况,只要把这个数对应位取反即可得到一个偶状态 </li></ol></blockquote><p>对于n堆物品,只要判断它出是奇状态就可以断定先手有必赢策略 </p><p>位运算（异或）代替求二进制判断奇状态：</p><p> 如果有奇数个二进制数在第K位为1，那么在这一位上的和为奇（已可以表明这就是一个奇状态）</p><p>在位运算方面体现为：所有数字异或后得到的ans在第K位为1</p><p>这一条件可以放大为ans != 0，意味着ans至少有一位1，我们说那就是第K位。</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">bool Nimm_Game(int n){    int flag = 0;    for(int i = 0; i &lt; n; ++i)        flag ^= a[i];    if(flag)        return 1;    return 0;}</code></pre><blockquote><p>但是有时会遇到n很大，a[i]为连续整数的特殊情况，这时有特殊算法</p></blockquote><h3 id="Strange-code"><a href="#Strange-code" class="headerlink" title="Strange code"></a>Strange code</h3><pre><code class="lang-c++">//读入n，表示有从物品数分别1到n的n堆物品，假设n个数存在数组f[]中int xor_n(int n)//从1到n的异或和{     int t = n &amp; 3;     if (t &amp; 1)          return t / 2 ^ 1;     return t / 2 ^ n;}int Nimm_Game(int n)//有必胜策略返回1{    int flag = 0;    for(int i = 1; i &lt;= n; i++)        flag ^= xor_n(f[i]);    if(flag)         return 1;    return 0;}</code></pre><h3 id="另一种解释"><a href="#另一种解释" class="headerlink" title="另一种解释"></a>另一种解释</h3><blockquote><p>用(A,B,C)来表示某一特定局势，同时规定A&lt;=B&lt;=C。奇异局势表示先手必败。</p><ol><li>显然(0,0,0)是奇异局势。</li><li>(0,n,n)是奇异局势，当先手拿走s个石子时，我们对应拿走s个石子，最终转化为(0,0,0)</li><li>(1,2,3)也是奇异局势，无论先手如何取，我们都可以转化为(0,n,n)的局势。</li></ol><p>对于一个奇异局势(A,B,C),我们可以发现，A(XOR)B(XOR)C = 0。 </p><p>下面是一条需要的前置技能： </p><p>设有数字a,b，a(XOR)b(XOR)(a(XOR)b) = (a(XOR)a)(XOR)(b(XOR)b) = 0 </p><p>对于一个非奇异局势(A,B,C),我们只需要将C转化为(A(XOR)B)即可，而将C转化为(A(XOR)B)的操作为，拿走K = C-(A(XOR)B)个即可。</p><p>3可扩展到N</p><p>原文出处 ： <a href="https://blog.csdn.net/pengwill97/article/details/76796070" target="_blank" rel="noopener">https://blog.csdn.net/pengwill97/article/details/76796070</a></p></blockquote><h2 id="威佐夫博弈（Wythoff-Game）"><a href="#威佐夫博弈（Wythoff-Game）" class="headerlink" title="威佐夫博弈（Wythoff Game）"></a>威佐夫博弈（Wythoff Game）</h2><blockquote><p>有两堆各若干个物品，两个人轮流从某一堆或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。 </p><p>如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：</p><p>（0，0）、（1，2）、（3，5）、（4，7）、（6，10）.</p><p>可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk=ak+k. </p><p>面对奇异局势，先手必败</p><p>面对非奇异局势，必然存在使其变为奇异局势的方案，使后手必败，从而先手获胜</p><p>取石子游戏 ： <a href="http://poj.org/problem?id=1067" target="_blank" rel="noopener">http://poj.org/problem?id=1067</a></p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){    int a, b, k, tem;    while(cin &gt;&gt; a &gt;&gt; b)    {        if(a &gt; b)            a ^= b, b ^= a, a ^= b;        k = b - a;        tem = (int)((sqrt(5.0) + 1) / 2 * k);        if(tem == a)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &#39;1&#39; &lt;&lt; &#39;\n&#39;;     /* double tem = (sqrt(5.0) - 1.0) / 2.0;        k = a * tem;        if(a != k * (int)(tem + 1))            ++k;        if(a + k == b)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &#39;1&#39; &lt;&lt; &#39;\n&#39;; */    }    return 0;}</code></pre><blockquote><p>文章出处: <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6398385.html" target="_blank" rel="noopener">https://www.cnblogs.com/ECJTUACM-873284962/p/6398385.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の博弈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 读写csv文件</title>
      <link href="2019/07/17/python-%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6/"/>
      <url>2019/07/17/python-%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="Python读取csv文件统计数据写入新的csv文件"><a href="#Python读取csv文件统计数据写入新的csv文件" class="headerlink" title="Python读取csv文件统计数据写入新的csv文件"></a>Python读取csv文件统计数据写入新的csv文件</h3><a id="more"></a><blockquote><p>原始资料文件</p></blockquote><p><img src="https://i.loli.net/2019/07/17/5d2f0a3b34d9b72701.jpg" alt="原始资料csv文件"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-python">&#39;&#39;&#39;pycharm里，写完了暂时没有用到的东西会显示为灰色就像eclipse似的，写出来暂时没用到的东西会有标注&#39;&#39;&#39;import csvdata_path = &#39;./train.csv&#39;def run_main():    pclass_dict = {}    gender_dict = {}    age_dict = {}    sibsp_dict = {}    parch_dict = {}    fare_dict = {}    embarked_dict = {}    with open(data_path, &#39;r&#39;, newline=&#39;&#39;) as csvfile:        rows = csv.reader(csvfile)        for i, row in enumerate(rows):            if i == 0:                continue            if i % 50 == 0:                print(&#39;正在处理第{}行数据...&#39;.format(i))            survived = row[1]            pclass = row[2]            gender = row[3]            age = row[4]            sibsp = row[5]            parch = row[6]            fare = row[7]            embarked = row[8]            pclass = pclass.replace(&#39; &#39;, &#39;&#39;)            gender = gender.replace(&#39; &#39;, &#39;&#39;)            age = age.replace(&#39; &#39;, &#39;&#39;)            sibsp = sibsp.replace(&#39; &#39;, &#39;&#39;)            parch = parch.replace(&#39; &#39;, &#39;&#39;)            fare = fare.replace(&#39; &#39;, &#39;&#39;)            embarked = embarked.replace(&#39; &#39;, &#39;&#39;)            if gender not in gender_dict:                gender_dict[gender] = [0, 0]            if survived == &#39;0&#39;:                     # 字符0                gender_dict[gender][0] += 1            elif survived == &#39;1&#39;:                gender_dict[gender][1] += 1            else:                pass            if pclass not in pclass_dict:                pclass_dict[pclass] = [0, 0]            if survived == &#39;0&#39;:                pclass_dict[pclass][0] += 1            elif survived == &#39;1&#39;:                pclass_dict[pclass][1] += 1            else:                pass            if age not in age_dict:                age_dict[age] = [0, 0]            if survived == &#39;0&#39;:                age_dict[age][0] += 1            elif survived == &#39;1&#39;:                age_dict[age][1] += 1            else:                pass            if sibsp not in sibsp_dict:                sibsp_dict[sibsp] = [0, 0]            if survived == &#39;0&#39;:                sibsp_dict[sibsp][0] += 1            elif survived == &#39;1&#39;:                sibsp_dict[sibsp][1] += 1            else:                pass            if parch not in parch_dict:                parch_dict[parch] = [0, 0]            if survived == &#39;0&#39;:                parch_dict[parch][0] += 1            elif survived == &#39;1&#39;:                parch_dict[parch][1] += 1            else:                pass            if fare not in fare_dict:                fare_dict[fare] = [0, 0]            if survived == &#39;0&#39;:                fare_dict[fare][0] += 1            elif survived == &#39;1&#39;:                fare_dict[fare][1] += 1            else:                pass            if embarked not in embarked_dict:                embarked_dict[embarked] = [0, 0]            if survived == &#39;0&#39;:                embarked_dict[embarked][0] += 1            elif survived == &#39;1&#39;:                embarked_dict[embarked][1] += 1            else:                pass    print(&#39;Finished!&#39;)    with open(&#39;result.csv&#39;, &#39;w&#39;, newline=&#39;&#39;, encoding=&#39;utf-16&#39;) as csvfile:        csvwriter = csv.writer(csvfile, delimiter=&#39;,&#39;)        csvwriter.writerow([&#39;gender&#39;, &#39;dead&#39;, &#39;survived&#39;])        # csvwriter.writerow([&#39;male&#39;, gender_dict[&#39;male&#39;][0], gender_dict[&#39;female&#39;][1]])        # csvwriter.writerow([&#39;female&#39;, gender_dict[&#39;female&#39;][0], gender_dict[&#39;female&#39;][1]])        for k, v in list(gender_dict.items()):            csvwriter.writerow([k, v[0], v[1]])        csvwriter.writerow([ &#39;pclass&#39;, &#39;dead&#39;, &#39;survived&#39;])        for k, v in list(pclass_dict.items()):            csvwriter.writerow([k, v[0], v[1]])               # 小括号里有中括号        csvwriter.writerow([ &#39;age&#39;, &#39;dead&#39;, &#39;survived&#39; ])        for k, v in list(age_dict.items()):            csvwriter.writerow([k, v[0], v[1]])        csvwriter.writerow([&#39;sibsp&#39;, &#39;dead&#39;, &#39;survived&#39;])        for k, v in list(sibsp_dict.items()):            csvwriter.writerow([k, v[0], v[1]])        csvwriter.writerow([ &#39;parch&#39;, &#39;dead&#39;, &#39;survived&#39;])        for k, v in list(parch_dict.items()):            csvwriter.writerow([k, v[0], v[1]])        csvwriter.writerow([ &#39;fare&#39;, &#39;dead&#39;, &#39;survived&#39; ])        for k, v in list(fare_dict.items()):            csvwriter.writerow([k, v[0], v[1]])        csvwriter.writerow([ &#39;embarked&#39;, &#39;dead&#39;, &#39;survived&#39; ])        for k, v in list(embarked_dict.items()):            csvwriter.writerow([k, v[0], v[1]])if __name__ == &#39;__main__&#39;:        run_main()&#39;&#39;&#39;            这段代码有问题            gender_dict[&#39;male&#39;] = [0, 0]            gender_dict[&#39;female&#39;] = [0, 0]            if gender == &#39;male&#39;:                if survived == &#39;0&#39;:                    gender_dict[&#39;male&#39;][0] += 1          # dead mem                elif survived == &#39;1&#39;:                    gender_dict[&#39;male&#39;][1] += 1          # lived men                else:                    pass            elif gender == &#39;female&#39;:                if survived == &#39;0&#39;:                    gender_dict[&#39;female&#39;][0] += 1        # dead women                elif survived == &#39;1&#39;:                    gender_dict[&#39;female&#39;][1] += 1        # lived women                else:                    pass            else:                pass&#39;&#39;&#39;</code></pre><blockquote><p>生成的初始文件经“导入”处理后的文件</p></blockquote><p><img src="https://i.loli.net/2019/07/17/5d2f0972eda8030079.jpg" alt="生成的初始csv文件经导入后的csv文件"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1915 Knight Moves 双向BFS</title>
      <link href="2019/07/13/POJ-1915-Knight-Moves-%E5%8F%8C%E5%90%91BFS/"/>
      <url>2019/07/13/POJ-1915-Knight-Moves-%E5%8F%8C%E5%90%91BFS/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给出起点终点，按图示方法走，至少要几步</p></blockquote><a id="more"></a><p><img src="http://poj.org/images/1915_1.jpg" alt="moves"></p><h2 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h2><blockquote><p>交替逐层搜索√</p><p>交替节点搜索×</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;struct node{    int x, y;};queue&lt;node&gt; q[2];bool vis[2][305][305];int dx[] = { 1, 2, 1, 2, -1, -2, -1, -2 };int dy[] = { 2, 1, -2, -1, 2, 1, -2, -1 };bool BFS(int num){    int sz = q[num].size();    while(sz--)    {        node first = q[num].front();        q[num].pop();        for(int i = 0; i &lt; 8; ++i)        {            int xx = first.x + dx[i];            int yy = first.y + dy[i];            if(xx &lt; 0 || yy &lt; 0 || xx &gt;= n || yy &gt;= n || vis[num][xx][yy])                continue;            vis[num][xx][yy] = 1;            q[num].push({xx, yy});            if(vis[!num][xx][yy])                return 1;        }    }    return 0;}int slove(int sx, int sy, int ex, int ey){    memset(vis, 0, sizeof(vis));    while(q[0].size())        q[0].pop();    while(q[1].size())        q[1].pop();    vis[0][sx][sy] = 1;    vis[1][ex][ey] = 1;    q[0].push({sx, sy});    q[1].push({ex, ey});    int step = 0;    while(q[0].size() || q[1].size())    {        bool flag = BFS(0);        step++;        if(flag)            return step;        flag = BFS(1);        step++;        if(flag)            return step;    }    return -1;}int main(){    int t, sx, sy, ex, ey;    cin &gt;&gt; t;    while(t--)    {        cin &gt;&gt; n;        cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;        if(sx == ex &amp;&amp; sy == ey)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; slove(sx, sy, ex, ey) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>代码参考 <a href="https://yuntengzhiyu.github.io/2019/06/02/POJ-2243-%E5%8F%8C%E5%90%91BFS/" target="_blank" rel="noopener">https://yuntengzhiyu.github.io/2019/06/02/POJ-2243-%E5%8F%8C%E5%90%91BFS/</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3264 Balamced Lineup</title>
      <link href="2019/07/10/POJ-3264-Balamced-Lineup/"/>
      <url>2019/07/10/POJ-3264-Balamced-Lineup/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给出序列A，包含n个元素，给出q个询问，输出每个询问对应区间里最大值与最小值的差</p></blockquote><a id="more"></a><h2 id="关于RMQ问题的ST算法"><a href="#关于RMQ问题的ST算法" class="headerlink" title="关于RMQ问题的ST算法"></a>关于RMQ问题的ST算法</h2><blockquote><p><a href="https://blog.csdn.net/qq_31759205/article/details/75008659" target="_blank" rel="noopener">https://blog.csdn.net/qq_31759205/article/details/75008659</a></p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;int n, q;int a[N];int big[N][20];int sma[N][20];void ST(){    for(int i = 1; i &lt;= n; ++i)        big[i][0] = sma[i][0] = a[i];    for(int j = 1; (1 &lt;&lt; j) &lt;= n; ++j)        for(int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i)        {            big[i][j] = max(big[i][j - 1], big[i + (1 &lt;&lt; (j - 1))][j - 1]);            sma[i][j] = min(sma[i][j - 1], sma[i + (1 &lt;&lt; (j - 1))][j - 1]);        }}//int rmq(int l, int r)void RMQ(int l, int r, int &amp; mmax, int &amp; mmin){    int k = 0;    while( (1 &lt;&lt; (k + 1)) &lt;= r - l + 1 )        ++k;    mmax = max(big[l][k], big[r - (1 &lt;&lt; k) + 1][k]);    mmin = min(sma[l][k], sma[r - (1 &lt;&lt; k) + 1][k]);//    return max(big[l][k], big[r - (1 &lt;&lt; k) + 1][k]) - min(sma[l][k], sma[r - (1 &lt;&lt; k) + 1][k]);}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d&quot;, &amp;a[i]);    ST();    int l, r, mmax, mmin;    while(q--)    {        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        RMQ(l, r, mmax, mmin);        cout &lt;&lt; mmax - mmin &lt;&lt; &#39;\n&#39;;//        cout &lt;&lt; rmq(l, r) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-of-Segment-Tree"><a href="#Code-of-Segment-Tree" class="headerlink" title="Code of Segment Tree"></a>Code of Segment Tree</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 50005;const int INF = 0x3f3f3f3f;int n, q, big, small;struct node{    int L, R, mmax, mmin;} a[N &lt;&lt; 2 | 1] ;void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].mmax = 0;    a[num].mmin = 0;    if(l == r)///初始化到叶子结点返回        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void update(int num, int l, int r, int tot){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].mmax = tot;        a[num].mmin = tot;        return ;    }    if(a[num].L == a[num].R)///搜索到叶子节点返回        return ;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, tot);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r, tot);    else    {        update(num &lt;&lt; 1, l, r, tot);        update(num &lt;&lt; 1 | 1, l, r, tot);    }    a[num].mmax = max(a[num &lt;&lt; 1].mmax, a[num &lt;&lt; 1 | 1].mmax);    a[num].mmin = min(a[num &lt;&lt; 1].mmin, a[num &lt;&lt; 1 | 1].mmin);}void query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        big = max(big, a[num].mmax);        small = min(small, a[num].mmin);        return ;    }    if(a[num].L == a[num].R)        return ;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        query(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        query(num &lt;&lt; 1 | 1, l, r);    else///区间范围分清楚        query(num &lt;&lt; 1, l, mid), query(num &lt;&lt; 1 | 1, mid + 1, r);}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);    int tem, left, right;    init(1, 1, n);    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%d&quot;, &amp;tem);        update(1, i, i, tem);    }    for(int i = 1; i &lt;= q; ++i)    {        big = -1, small = INF;        scanf(&quot;%d %d&quot;, &amp;left, &amp;right);        query(1, left, right);        cout &lt;&lt; big - small &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> DPのST算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3187 Backward Digit Sums</title>
      <link href="2019/06/09/POJ-3187-Backward-Digit-Sums/"/>
      <url>2019/06/09/POJ-3187-Backward-Digit-Sums/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>输入n,sum，求1~n的数，如何排列之后，相邻两列相加，直到得出最后的结果等于sum，输出1~n的排列(杨辉三角) </p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3187" target="_blank" rel="noopener">http://poj.org/problem?id=3187</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long c[25][25];void combine_init(){    memset(c, 0, sizeof(c));    c[0][0] = 1;    for(int i = 1; i &lt;= 15; ++i)    {        c[i][0] = c[i][i] = 1;        c[i][1] = i;        for(int j = 1; j &lt; i; ++j)            if(c[i][j] == 0)                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]);/// % mod    }}int a[15];int main(){    int n, num, sum;    combine_init();    while(cin &gt;&gt; n &gt;&gt; num)    {        for(int i = 0; i &lt; n; ++i)            a[i] = i + 1;        do        {            sum = 0;            for(int i = 0; i &lt; n; ++i)                sum += c[n - 1][i] * a[i];            if(sum == num)            {                for(int i = 0; i &lt; n; ++i)                    cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;                cout &lt;&lt; &#39;\n&#39;;                break;            }        }        while(next_permutation(a, a + n));    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 函数のnext_permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴协助征战SARS(困难)</title>
      <link href="2019/06/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%8D%8F%E5%8A%A9%E5%BE%81%E6%88%98SARS-%E5%9B%B0%E9%9A%BE/"/>
      <url>2019/06/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%8D%8F%E5%8A%A9%E5%BE%81%E6%88%98SARS-%E5%9B%B0%E9%9A%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>你需要统计所有满足下列条件的长度为 n 的字符串的个数: </p><ol><li><p>字符串仅由 A、T、C、G 组成</p></li><li><p>A和C 出现偶数次(也可以不出现)</p><p>数据范围：n &lt;= 10的（10的5次幂）</p></li></ol></blockquote><a id="more"></a><p><a href="https://nanti.jisuanke.com/t/38352" target="_blank" rel="noopener">https://nanti.jisuanke.com/t/38352</a></p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>数据小的时候，正常用矩阵快速幂</p><p>数据大了，先用欧拉降幂预处理</p></blockquote><p><img src="https://i.postimg.cc/76nhS8MX/QX1-1-2-YW7-M-5-GCRQD-8.png" alt="欧拉降幂公式"></p><blockquote><p>这里B % C, B是string类型读入的大数，所以用一下大数求余</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long long//欧拉函数ll phi(ll n){     ll i, rea = n;     for(i = 2; i * i &lt;= n; ++i)         if(n % i == 0)         {             rea = rea - rea / i;             while(n % i == 0)                 n /= i;          }     if(n &gt; 1)         rea = rea - rea / n;     return rea;}const int mod = 1e9 + 7;struct mtx{    ll m[105][105];};int n = 3;ll mi;mtx mpy(mtx a, mtx b){    mtx ans;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)        {            ans.m[i][j] = 0;            for(int k = 1; k &lt;= n; ++k)                ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;        }    return ans;}mtx fast_mod(mtx a, ll k){    mtx ans = a;    k--;    while(k)    {        if(k &amp; 1)            ans = mpy(ans, a);        a = mpy(a, a);        k &gt;&gt;= 1;    }    return ans;}int main(){    ll tem = phi(mod);    string s;    mtx a;    a.m[1][1] = 2, a.m[1][2] = 1, a.m[1][3] = 0;    a.m[2][1] = 2, a.m[2][2] = 2, a.m[2][3] = 2;    a.m[3][1] = 0, a.m[3][2] = 1, a.m[3][3] = 2;    while(cin &gt;&gt; s)    {        if(s[0] == &#39;0&#39;)            break;        mi = 0;        int sz = s.size();        for(int i = 0; i &lt; sz; ++i)//大数求余            mi = ((mi * 10) % tem + (s[i] - &#39;0&#39;) % tem) % tem;        mi += tem;        mtx ans = fast_mod(a, mi);        cout &lt;&lt; ans.m[1][1] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の大数求余 </tag>
            
            <tag> 数论の快速幂 </tag>
            
            <tag> 数论の欧拉降幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3669 Meteor Shower</title>
      <link href="2019/06/07/POJ-3669-Meteor-Shower/"/>
      <url>2019/06/07/POJ-3669-Meteor-Shower/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>巨大流星雨即将袭来。每个流星会对击中的地方以及周围（上下左右四格）造成破坏。Bessie开始时位于（0, 0）位置，并希望逃到一处不会被袭击到的地方（在第一象限内）。已知每移动一格需要1个时间单位，被流星破坏后的地方不能再进入。给出M个流星在T时刻击中的地方（X, Y），问Bessie能否逃到安全的地方，若能输出最短时间，否则输出-1。 </p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3669" target="_blank" rel="noopener">http://poj.org/problem?id=3669</a></p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>简单搜索，需要注意的是：若某处被反复袭击，时间点取最早的那一刻</p><p>所以说：Think twice, code once. 可平时没这样的习惯到场上应该也不会有（平时会觉得耽误时间……加之动脑少，思考的少，但凡有点细节便会忽视……要改！）</p><p>另外发现，map映射会比数组要慢，如果不是不知空间的情况下，尽量不用map</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};bool vis[305][305];//map&lt;int, map&lt;int, int&gt; &gt;ruin;//map&lt;int, map&lt;int, bool&gt; &gt;is;int ruin[305][305];bool is[305][305];struct node{    int x, y, step;};void BFS(){    node now, nxt;    now.x = 0, now.y = 0, now.step = 0;    vis[0][0] = 1;    queue&lt;node&gt; q;    q.push(now);    bool flag = 0;    while(q.size())    {        now = q.front();        q.pop();        if(is[now.x][now.y] == 0)        {            flag = 1;            cout &lt;&lt; now.step &lt;&lt; &#39;\n&#39;;            return ;        }        for(int i = 0; i &lt; 4; ++i)        {            int xx = now.x + dx[i];            int yy = now.y + dy[i];            if(xx &lt; 0 || yy &lt; 0 || vis[xx][yy])                continue;            if(is[xx][yy] == 1 &amp;&amp; ruin[xx][yy] &lt;= now.step + 1)                continue;            vis[xx][yy] = 1;            nxt.x = xx, nxt.y = yy, nxt.step = now.step + 1;            q.push(nxt);        }    }    if(flag == 0)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    return ;}int main(){    scanf(&quot;%d&quot;, &amp;n);    int x, y, t;    for(int i = 0; i &lt; n; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;t);        if(is[x][y] == 0)            ruin[x][y] = t, is[x][y] = 1;        else            ruin[x][y] = min(ruin[x][y], t);        for(int i = 0; i &lt; 4; ++i)        {            int xx = x + dx[i];            int yy = y + dy[i];            if(xx &lt; 0 || yy &lt; 0)                continue;            if(is[xx][yy] == 0)                ruin[xx][yy] = t, is[xx][yy] = 1;            else                ruin[xx][yy] = min(ruin[xx][yy], t);        }    }    BFS();    return 0;}</code></pre><blockquote><p>用二维mapTLE了半小时</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aizu 0121 Seven Puzzle</title>
      <link href="2019/06/07/Aizu-0121-Seven-Puzzle/"/>
      <url>2019/06/07/Aizu-0121-Seven-Puzzle/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>给你一个4x2的方版，上面有0-7 八个数字，每次只能让编号0的方格跟他的上下左右的方格交换；所以也就是把方格0当做空格看待，每次只有空格周围的方格能够向空格处移动。   然后问从输入的方格样式变换到字典序最小的”01234567” 最少需要多少次. </p></blockquote><a id="more"></a><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><p><a href="https://cn.vjudge.net/problem/Aizu-0121" target="_blank" rel="noopener">https://cn.vjudge.net/problem/Aizu-0121</a></p><blockquote><p>多组输入易超时的题：打表O（1）查询</p><p>打表：反向BFS，求出“01234567”到其他排列的最小步数</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, int&gt; mp;map&lt;string, bool&gt; vis;int dir[] = {1, -1, 4, -4};struct node{    string s;    int zero, step;};void BFS(){    string ch = &quot;01234567&quot;;    mp[ch] = 0;    vis[ch] = 1;    node now, nxt;    now.s = ch, now.zero = 0, now.step = 0;    queue&lt;node&gt; q;    q.push(now);    while(q.size())    {        now = q.front();        q.pop();        for(int i = 0; i &lt; 4; ++i)        {            int pos = now.zero + dir[i];            if((pos &lt; 0 || pos &gt; 7) || (pos == 3 &amp;&amp; now.zero == 4) || (pos == 4 &amp;&amp; now.zero == 3))                continue;            string t = now.s;            swap(t[now.zero], t[pos]);            if(vis[t] == 0)            {                vis[t] = 1;                nxt.s = t;                nxt.zero = pos;                nxt.step = now.step + 1;                q.push(nxt);                mp[t] = nxt.step;///make the table            }        }    }}int main(){    BFS();    char tem[20];    while(~scanf(&quot;%c&quot;, &amp;tem[0]))    {        for(int i = 1; i &lt; 8; ++i)            getchar(), tem[i] = getchar();        getchar();        tem[8] = &#39;\0&#39;;//堵光标        cout &lt;&lt; mp[tem] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python study</title>
      <link href="2019/06/06/Python-study/"/>
      <url>2019/06/06/Python-study/</url>
      
        <content type="html"><![CDATA[<h1 id="enumerate遍历"><a href="#enumerate遍历" class="headerlink" title="enumerate遍历"></a>enumerate遍历</h1><blockquote><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p></blockquote><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-python">&#39;&#39;&#39;enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。&#39;&#39;&#39;# 字符串s = &#39;fireworks&#39;for i, char in enumerate(s):    print(i, char)&#39;&#39;&#39;0 f1 i2 r3 e4 w5 o6 r7 k8 s&#39;&#39;&#39;# 列表list = [ &#39;fireworks&#39;, &#39;24&#39;, 1, 17 ];for i, idx in enumerate(list):    print(i, idx)&#39;&#39;&#39;0 fireworks1 242 13 17&#39;&#39;&#39;# 元组tup = (&#39;LX&#39;, 24, &#39;short hair&#39;, &#39;tall&#39;)for i, idx in enumerate(tup):    print(i, idx)&#39;&#39;&#39;0 LX1 242 short hair3 tall&#39;&#39;&#39;dict = { &#39;My love&#39; : &#39;lx&#39;, 100 : 3.1415926 }for i, key in enumerate(dict):        print(i, key, dict[key])&#39;&#39;&#39;0 My love lx1 100 3.1415926&#39;&#39;&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML涉猎</title>
      <link href="2019/06/06/HTML%E6%B6%89%E7%8C%8E/"/>
      <url>2019/06/06/HTML%E6%B6%89%E7%8C%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML制表"><a href="#HTML制表" class="headerlink" title="HTML制表"></a>HTML制表</h1><h2 id="表格居中"><a href="#表格居中" class="headerlink" title="表格居中"></a>表格居中</h2><h3 id="Code-添加属性-align-quot-center-quot"><a href="#Code-添加属性-align-quot-center-quot" class="headerlink" title="Code :添加属性 align=&quot;center&quot;"></a>Code :添加属性 <code>align=&quot;center&quot;</code></h3><pre><code class="lang-html">&lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;align=&quot;center&quot;&gt;</code></pre><blockquote><p>align    [ə’laɪn]     对齐</p></blockquote><h2 id="边框为无宽度直线"><a href="#边框为无宽度直线" class="headerlink" title="边框为无宽度直线"></a>边框为无宽度直线</h2><blockquote><p>填充（P）：0</p><p>间距（S）：0</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のHTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3255 Roadblocks and 3463 Sightseeing（次短路）</title>
      <link href="2019/06/06/POJ-3255-Roadblocks-and-3463-Sightseeing/"/>
      <url>2019/06/06/POJ-3255-Roadblocks-and-3463-Sightseeing/</url>
      
        <content type="html"><![CDATA[<h1 id="POJ-3255-Roadblocks"><a href="#POJ-3255-Roadblocks" class="headerlink" title="POJ 3255 Roadblocks"></a>POJ 3255 Roadblocks</h1><blockquote><p>N个点，M条双向边，求1到N的严格次短路</p></blockquote><a id="more"></a><h2 id="Idea-1"><a href="#Idea-1" class="headerlink" title="Idea 1"></a>Idea 1</h2><blockquote><p>1到n的次短路长度必然产生于：从1走到x的最短路 + edge[x][y] +  y到n的最短路</p><p>首先预处理好1到每一个节点的最短路，和n到每一个节点的最短路</p><p>然后枚举每一条边作为中间边（x，y）或者（y，x），如果加起来长度等于最短路长度则跳过，否则更新从1走到x的最短路 + edge[x][y] +  y到n的最短路  给dist[n] 比较 找大于dist[n] 且是最小的那一个</p><p>spfa(1) + spfa(n)</p><p>原文链接： <a href="https://blog.csdn.net/huangshuai147/article/details/69105576" target="_blank" rel="noopener">https://blog.csdn.net/huangshuai147/article/details/69105576</a></p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, m;int cnt;struct edge{    int to, w, pre;} a[200005];bool vis[5005];///表示是否在队列里int head[5005], frdis[5005], redis[5005], tot, sum;void add(int from, int to, int w){    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        frdis[i] = INF;        redis[i] = INF;        head[i] = -1;        vis[i] = 0;    }}void spfa(int start, int * dis){    memset(vis, 0, sizeof(vis));    deque&lt;int&gt; q;    dis[start] = 0;    q.push_front(start);    vis[start] = 1;///表示在队列里    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];///同dijkstra，以first为中转点，而非a[i].from        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                }            }        }    }    return ;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    init();    int u, v, w;    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);        add(v, u, w);    }    spfa(1, frdis);    spfa(n, redis);    int ans = INF;    for(int i = 1; i &lt;= n; ++i)        for(int j = head[i]; ~j; j = a[j].pre)        {            v = a[j].to;            w = a[j].w;            int tem = frdis[i] + w + redis[v];            if(tem &gt; frdis[n] &amp;&amp; tem &lt; ans)                ans = tem;        }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h1 id="POJ-3463-Sightseeing"><a href="#POJ-3463-Sightseeing" class="headerlink" title="POJ 3463 Sightseeing"></a>POJ 3463 Sightseeing</h1><blockquote><p>N个点，M条单向边，求最短路数目+比最短路长单位1的次短路条数</p></blockquote><h2 id="Idea-2"><a href="#Idea-2" class="headerlink" title="Idea 2"></a>Idea 2</h2><blockquote><p>（s，u，v）代表从s——v的最短路，u是中间一个必经点</p><p>最短路和次短路的比较:</p><blockquote><p>(s，u，v）最短路=到达前一个点u的最短路+（u，v）的最短路。 </p></blockquote><p>因而最短路求解有两种情况： </p><blockquote><ol><li>（s，u，v）次短路=到达前一个点u的次短路+（u，v）的最短路 </li><li>（s，u，v）次短路=到达前一个点u的最短路+（u，v）的次短路。 </li></ol></blockquote><p>用：d[v][0]代表最短路，d[v][1]代表次短路。  </p><p>（一）如果从s—u的最短路加上（u，v）权值的距离小于原来的d[v][0] ，我们就可把次短路d[v][1] 的值更新为d[v][0]，就该题而言，此时可以把次短路的条数也更新为这个点的最短路的条数；把当前最短路d[v][0]的值更新成最小的，和原来最短路的松弛操作是一样的。</p><p>（二）如果从s—u的最短路加上（u，v）权值的距离大于原来的d[v][0]，这就说明这条路路径就可能是一条次短路，那我们需要判断这条路的值dist，和原来的次短路的值d[v][1]进行比较！</p><blockquote><ol><li>如果它比原来的次短路要大，直接跳过.</li><li>如果它比原来的次短路要小，那么我们就需要更新最短路的长度 .</li><li>如果与原来的次短路相等，说明我们的次短路有另一种（这里并不一定是只有1种）方法可以到达终点v。这里要加的种类是：原来到v点的次短路的条数+到u点的次短路（或者最短路，（u，v）并不知道是不是一定是最短路，如果是次短路，那么此时加的就是到u的最短路）的条数。 </li></ol></blockquote><p>原文链接： <a href="https://blog.csdn.net/ydd97/article/details/47919551" target="_blank" rel="noopener">https://blog.csdn.net/ydd97/article/details/47919551</a></p></blockquote><h2 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 10005;struct edge{    int to, w, pre;}a[N &lt;&lt; 1];int n, m, cnt, head[N], d[N][2], c[N][2], vis[N][2];void add(int from, int to, int w){    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt++;}void Dijkstra(int s){    memset(d, INF, sizeof(d));    memset(c, 0, sizeof(c));    memset(vis, 0, sizeof(vis));    d[s][0] = 0;    c[s][0] = 1;    int pos = s, idx;    while(1)    {        pos = -1;        for(int i = 1; i &lt;= n; ++i)            for(int j = 0; j &lt; 2; ++j)                if(!vis[i][j] &amp;&amp; (pos == -1 || d[i][j] &lt; d[pos][idx]))                    pos = i, idx = j;        if(pos == -1)            break;        vis[pos][idx] = 1;        for(int i = head[pos]; ~i; i = a[i].pre)        {            int to = a[i].to;            int dis = d[pos][idx] + a[i].w;            if(dis &lt; d[to][0])///This path is shorter than the shortest path.            {                d[to][1] = d[to][0], c[to][1] = c[to][0];                d[to][0] = dis, c[to][0] = c[pos][idx];            }            else if(dis == d[to][0])                c[to][0] += c[pos][idx];            else if(dis &lt; d[to][1])///longer than the shortest but shorter than the second shortest                d[to][1] = dis, c[to][1] = c[pos][idx];            else if(dis == d[to][1])                c[to][1] += c[pos][idx];        }    }}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        cnt = 0;        memset(head, -1, sizeof(head));        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int u, v, w;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            add(u, v, w);        }        int start, over;        scanf(&quot;%d%d&quot;, &amp;start, &amp;over);        Dijkstra(start);        int ans = c[over][0];        if(d[over][1] == d[over][0] + 1)///be careful which is smaller            ans += c[over][1];        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h2 id="POJ-3255-of-Idea-2"><a href="#POJ-3255-of-Idea-2" class="headerlink" title="POJ 3255 of Idea 2"></a>POJ 3255 of Idea 2</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int M = 100005;const int N = 5005;struct edge{    int to, w, pre;} a[M &lt;&lt; 1];int n, m, cnt, head[N], d[N][2], vis[N][2];void add(int from, int to, int w){    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt++;}void Dijkstra(int s){    memset(d, INF, sizeof(d));    memset(vis, 0, sizeof(vis));    d[s][0] = 0;    int pos = s, idx;    while(1)    {        pos = -1;        for(int i = 1; i &lt;= n; ++i)            for(int j = 0; j &lt; 2; ++j)                if(!vis[i][j] &amp;&amp; (pos == -1 || d[i][j] &lt; d[pos][idx]))                    pos = i, idx = j;        if(pos == -1)            break;        vis[pos][idx] = 1;        for(int i = head[pos]; ~i; i = a[i].pre)        {            int to = a[i].to;            int dis = d[pos][idx] + a[i].w;            if(dis &lt; d[to][0])///This path is shorter than the shortest path.                d[to][1] = d[to][0], d[to][0] = dis;            else if(dis &lt; d[to][1])///longer than the shortest but shorter than the second shortest                d[to][1] = dis;        }    }}int main(){    cnt = 0;    memset(head, -1, sizeof(head));    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int u, v, w;    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        add(u, v, w);        add(v, u, w);    }    Dijkstra(1);    cout &lt;&lt; d[n][1] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3276 Face the Right Way</title>
      <link href="2019/06/05/POJ-3276-Face-the-Right-Way/"/>
      <url>2019/06/05/POJ-3276-Face-the-Right-Way/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>N头牛排成一列，有面朝前（F）的、面朝后（B）的，有一台机器能让连续K头牛翻转方向，</p><p>求让所有牛面朝前的最少操作次数M，及此时对应的K；</p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3276" target="_blank" rel="noopener">http://poj.org/problem?id=3276</a></p><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><blockquote><p>翻转问题的特点：</p><ol><li>若确定了翻转方案，交换翻转顺序对结果无影响</li><li>对同一区间：要么不反转，要么只翻转一次。多次翻转是多余的。</li></ol><p>首先对最左边的牛进行判断，如果这头牛已经朝前方了，那么以这头牛为开始的区间就不需要在进行反转。</p><p>如果这头牛朝后面，那么对应的以该牛为开始的区间就反转。不停重复以上步骤即可。</p><p>但是如果反转牛时对每一头牛都进行反转操作的话时间复杂度就成了O(n^3)，肯定超时，所以必须在反转操作上进行优化。</p><p>f[i]:=区间[i,i+k-1]进行了反转的话为1,否则的话为0</p><p>这样在考虑第i头牛时候，如果sum(f[i-k+1]+…+f[i-1)为奇数的话，则与开始方向相反，否则相同。这样就将反转操作的复杂度将为常数，整个算法复杂度将为O(n^2)</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;bool dir[5005];///0 is face. 1 is back.bool f[5005];///0 is that the interval which refers to [i, i + k - 1] wasn&#39;t flip.int cal(int k){    memset(f, 0, sizeof(f));    int res = 0, sum = 0;    for(int i = 0; i + k &lt;= n; ++i)    {        if((dir[i] + sum) &amp; 1)            res++, f[i] = 1;        ///update the sum        sum += f[i];        if(i - k + 1 &gt;= 0)///the first            sum -= f[i - k + 1];    }    ///check the remain    for(int i = n - k + 1; i &lt; n; ++i)    {        if((dir[i] + sum) &amp; 1)            return -1;        if(i - k + 1 &gt;= 0)            sum -= f[i - k + 1];    }    return res;}int main(){    scanf(&quot;%d&quot;, &amp;n);    getchar();    char s[5005];    for(int i = 0; i &lt; n; ++i)        s[i] = getchar(), getchar();    memset(dir, 0, sizeof(dir));    for(int i = 0; i &lt; n; ++i)        if(s[i] == &#39;B&#39;)            dir[i] = 1;    int ans_k = 1, ans_m = n;    for(int k = 1; k &lt;= n; ++k)    {        int m = cal(k);        if(m &gt;= 0 &amp;&amp; ans_m &gt; m)            ans_m = m, ans_k = k;    }    cout &lt;&lt; ans_k &lt;&lt; &#39; &#39; &lt;&lt; ans_m &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の翻转问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 3631 Watashi&#39;s BG</title>
      <link href="2019/06/05/ZOJ-3631-Watashi-s-BG/"/>
      <url>2019/06/05/ZOJ-3631-Watashi-s-BG/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>问题转化：</p><p>N个物品，重量等价于价值，背包承重W，求最大载重</p><p>1 &lt;= N &lt;= 40</p><p>0 &lt;= M &lt;= 1e7</p><p>w[i] &lt;= 1e7</p></blockquote><a id="more"></a><p><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4777" target="_blank" rel="noopener">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=4777</a> 没找到合适的模板题</p><h1 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h1><blockquote><p>超大背包，折半枚举</p><p>2 ^ 40 ≈ 1e12,但折半后 2 ^ 20 ≈ 1e6,可枚举了</p><p>对前半部分枚举出所有方案，排序去除多余元素（重量大反而价值小，不针对此题），对后半部分的方案在枚举时二分搜索前半部分的方案，更新最佳答案</p></blockquote><h2 id="Code（Template）"><a href="#Code（Template）" class="headerlink" title="Code（Template）"></a>Code（Template）</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll INF = 2147483647;const int N = 40;int n, m;ll w[N], v[N];pair&lt;ll, ll&gt; p[1 &lt;&lt; (N / 2)];int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%lld&quot;, &amp;w[i]), v[i] = w[i];        //依次枚举前半部分方案        int mid = n / 2;        for(int i = 0; i &lt; 1 &lt;&lt; mid; ++i)        {            ll ww = 0, vv = 0;            for(int j = 0; j &lt; mid; ++j)                if((i &gt;&gt; j) &amp; 1)                    ww += w[j], vv += v[j];            p[i] = make_pair(ww, vv);        }        //去除多余元素        sort(p, p + (1 &lt;&lt; mid));        int idx = 1;        for(int i = 1; i &lt; 1 &lt;&lt; mid; ++i)            if(p[idx - 1].second &lt; p[i].second)                p[idx++] = p[i];        //枚举后半部分并二分搜索更新答案        ll res = 0;        for(int i = 0; i &lt; 1 &lt;&lt; (n - mid); ++i)        {            ll ww = 0, vv = 0;            for(int j = 0; j &lt; n - mid; ++j)                if((i &gt;&gt; j) &amp; 1)                    ww += w[j + mid], vv += v[j + mid];            if(ww &lt;= m)            {                ll temv = (lower_bound(p, p + idx, make_pair(m - ww, INF)) - 1)-&gt;second;                res = max(res, vv + temv);            }        }        cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    }}</code></pre><h2 id="枚举方案测试"><a href="#枚举方案测试" class="headerlink" title="枚举方案测试"></a>枚举方案测试</h2><pre><code class="lang-c++">for(int i = 0; i &lt; (1 &lt;&lt; n); ++i)    {        for(int j = 0; j &lt; n; ++j)            if(i &gt;&gt; j &amp; 1)                cout &lt;&lt; j &lt;&lt; &#39; &#39;;        cout &lt;&lt; &quot;\n-------------------------&quot; &lt;&lt; &#39;\n&#39;;    }</code></pre><p><img src="https://i.loli.net/2019/06/05/5cf7a160ee3fa49656.png" alt="result"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の折半枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3684 Physics Experiment</title>
      <link href="2019/06/03/POJ-3684-Physics-Experiment/"/>
      <url>2019/06/03/POJ-3684-Physics-Experiment/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>有n个小球从一管道开始下落，每秒钟下落一个，已知管口离地面的距离h及小球半径r，所有的碰撞均是弹性碰撞，求ts时，各个小球的位置 </p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3684" target="_blank" rel="noopener">http://poj.org/problem?id=3684</a></p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>他们的碰撞可以视为没有碰撞，只是穿过了对方，而这种思路适用于没有半径的时候，其实有半径的时候也可以这样来解决 </p><ol><li>假所有的小球都是没有半径的，且从同一高度每隔1s掉下，，很显然，这个时候求t时的小球的位置，只要求出单独的小球位置，然后再sort排个序就好，（sort排序是因为小球相对位置不变，即刚释放时最下边的小球不管怎么跳还是在最下面），这个时候跟蚂蚁是几乎差不多的，碰了等于没碰。</li><li>假设两个小球是有半径的，且是紧挨着每隔1s落下，这时候，因为小球有半径，其实碰了还是等于没碰</li><li>对于从下方数第i个球，在按照R=0计算的结果上加上<strong>2Ri</strong>就好了</li></ol></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double g = 10.0;int N, H, R, T;double y[105];double cal(int t){    if(t &lt; 0)        return H;    double TT = sqrt(2 * H / g);        ///周期    int k = (int)(t / TT);              ///最多包含多少个周期    double time;    if(k &amp; 1)                           ///rise        time = k * TT + TT - t;    else                                ///fall        time = t - k * TT;    return H - g * time * time / 2;}int main(){    int n;    cin &gt;&gt; n;    while(n--)    {        cin &gt;&gt; N &gt;&gt; H &gt;&gt; R &gt;&gt; T;        for(int i = 0; i &lt; N; ++i)            y[i] = cal(T - i);          ///T-i 对应释放时间        sort(y, y + N);        for(int i = 0; i &lt; N; ++i)            printf(&quot;%.2f%c&quot;, y[i] + 2 * R * i / 100.0, i &lt; N - 1 ? &#39; &#39; : &#39;\n&#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 技巧の弹性碰撞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3320 Jessica&#39;s Reading Problem</title>
      <link href="2019/06/02/POJ-3320-Jessica-s-Reading-Problem/"/>
      <url>2019/06/02/POJ-3320-Jessica-s-Reading-Problem/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>求覆盖数组中出现过的所有元素的最小的区间长度（连续） </p></blockquote><a id="more"></a><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>满足尺取条件：</p><ol><li>连续</li><li>若设s -&gt; t， 则s+1 -&gt; ?      ? &gt;= t</li></ol></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int a[1000005];int Scan(){    int res = 0, ch, flag = 0;    if((ch = getchar()) == &#39;-&#39;)        flag = 1;    else if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res += ch - &#39;0&#39;;    while((ch = getchar()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res = res * 10 + ch - &#39;0&#39;;    return flag ? -res : res;}int main(){    int n, t, sz;    scanf(&quot;%d&quot;, &amp;n);    getchar();    set&lt;int&gt; st;    for(int i = 0; i &lt; n; ++i)    {        a[i] = Scan();//scanf(&quot;%d&quot;, &amp;a[i]);        st.insert(a[i]);    }    sz = st.size();    st.clear();    int res = n, l = 0, r = 0, num = 0;    map&lt;int, int&gt; mp;    while(1)    {        while(r &lt; n &amp;&amp; num &lt; sz)        {            if(mp[a[r]] == 0)                num++;            mp[a[r]]++;            r++;///if this sentence is put at the head.a[0] is lost!        }        if(num &lt; sz)            break;        else        {            res = min(res, r - l);            mp[a[l]]--;            if(mp[a[l]] == 0)                num--;            l++;        }    }    cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>注意res初始化的值</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の尺取法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3061 Subsequence</title>
      <link href="2019/06/02/POJ-3061-Subsequence/"/>
      <url>2019/06/02/POJ-3061-Subsequence/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>n个非负整数，给出S，求一个连续子序列，其和&gt;= S，并使其长度最小</p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3061" target="_blank" rel="noopener">http://poj.org/problem?id=3061</a></p><h2 id="Idea-二分搜索"><a href="#Idea-二分搜索" class="headerlink" title="Idea(二分搜索)"></a>Idea(二分搜索)</h2><blockquote><p>连续子序列、和 -&gt; 暗示前缀和</p><p>因为没有负数，前缀和sum[]是单调递增的</p><p>单调递增这一特点对应 ①尺取法、②lower_bound查找</p></blockquote><h2 id="Code-二分搜索"><a href="#Code-二分搜索" class="headerlink" title="Code(二分搜索)"></a>Code(二分搜索)</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[100005];int sum[100005];///涉及 连续子序列的和 -&gt; 前缀和///因为没有负数，前缀和sum[]是单调递增的///单调递增这一特点对应 ①尺取法、②lower_bound查找int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int n, tot;        cin &gt;&gt; n &gt;&gt; tot;        cin &gt;&gt; a[0];        sum[0] = a[0];        for(int i = 1; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum[i] = sum[i - 1] + a[i];        }        if(sum[n - 1] &lt; tot)        {            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;            continue;        }        int ans = n;        for(int i = 0; sum[n - 1] - sum[i] &gt;= tot; ++i)        {    /// (sum + i) 为起点 (sum + pos) 为终点            int pos = lower_bound(sum + i, sum + n, sum[i] + tot) - sum;            ans = min(ans, pos - i);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }return 0;}</code></pre><h2 id="Code-尺取法"><a href="#Code-尺取法" class="headerlink" title="Code(尺取法)"></a>Code(尺取法)</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int a[100005];int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int n, tot;        cin &gt;&gt; n &gt;&gt; tot;        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d&quot;, &amp;a[i]);        int res = INF, l = 0, r = 0, sum = 0;        while(1)        {            while(r &lt; n &amp;&amp; sum &lt; tot)                sum += a[r++];            if(sum &lt; tot)                break;            else            {                res = min(res, r - l);                sum -= a[l];                l++;            }        }        if(res == INF)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; res &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の尺取法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断矩形相交</title>
      <link href="2019/06/02/%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4/"/>
      <url>2019/06/02/%E5%88%A4%E6%96%AD%E7%9F%A9%E5%BD%A2%E7%9B%B8%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<pre><code class="lang-c++">int check(int x1,int y1,int x2,int y2,int x3, int y3,int x4, int y4){    if(x2 &lt; x3 || x4 &lt; x1 || y4 &lt; y1 || y2 &lt; y3)        return 0;    return (min(y4, y2)- max(y1,y3)) * (min(x4,x2) - max(x1, x3));}</code></pre><a id="more"></a><blockquote><p>上面那个代码好垃圾，只能用在一种特定情况下：</p><p>先输入左下角坐标，后输入右上角坐标</p><p>要是先输入<strong>右上角</strong>坐标，再输入<strong>左下角</strong>坐标呢？</p><p>要是输入<strong>左上角</strong>坐标跟<strong>右下角</strong>坐标呢？</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">double x1, y1, x2, y2, x3, y3, x4, y4, lux, luy, rdx, rdy;    scanf(&quot;%lf%lf%lf%lf%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;x4, &amp;y4);    lux = max(min(x1,x2),min(x3,x4));    luy = max(min(y1,y2),min(y3,y4));    rdx = min(max(x1,x2),max(x3,x4));    rdy = min(max(y1,y2),max(y3,y4));    if(rdx &gt; lux &amp;&amp; rdy &gt; luy)        printf(&quot;%.2f\n&quot;,(rdx - lux)*(rdy - luy));    else        printf(&quot;0.00\n&quot;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3723 Conscription</title>
      <link href="2019/06/02/POJ-3723-Conscription/"/>
      <url>2019/06/02/POJ-3723-Conscription/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>对n个女生m个男生征兵，这些女生中部分与男生间有关系d，征一人入伍需10000，若一女生已被征，去征召跟她有关系d的男生只需花费10000-d，相反亦然。问征全部人最小花费</p></blockquote><a id="more"></a><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><blockquote><p>将女生标号（0~ n-1）偏移在男生（0 ~ m-1）之上: （m ~ m+n-1）构成图</p><p>其实关系值d代表应征一个人可以减少的花费，那么求一个最大生成树即最多减少的花费</p><p>10000 * （n + m） - 最大生成树 即最终的最少花费</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, r, ans;int pre[N * 2];int cnt;struct edge{    int there, here, w;} a[N * 2];bool cmp(edge a, edge b){    return a.w &gt; b.w;}void init(){    ans = 0;    for(int i = 0; i &lt;= n + m; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}int unite(edge t){    int x = found(t.there);    int y = found(t.here);    if(x != y)    {        pre[y] = x;        return t.w;    }    return 0;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;r);        init();        int b, c, d;        for(int i = 0; i &lt; r; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;a[i].there, &amp;a[i].here, &amp;a[i].w);            a[i].there += m;        }        sort(a, a + r, cmp);        for(int i = 0; i &lt; r; ++i)            ans += unite(a[i]);        cout &lt;&lt; 10000 * (n + m) - ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最小生成树のKruskal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白书-初出茅庐-初级篇</title>
      <link href="2019/06/02/%E7%99%BD%E4%B9%A6-%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90-%E5%88%9D%E7%BA%A7%E7%AF%87/"/>
      <url>2019/06/02/%E7%99%BD%E4%B9%A6-%E5%88%9D%E5%87%BA%E8%8C%85%E5%BA%90-%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="白书《挑战程序设计竞赛》第2版-准备篇-初级篇"><a href="#白书《挑战程序设计竞赛》第2版-准备篇-初级篇" class="headerlink" title="白书《挑战程序设计竞赛》第2版 准备篇+初级篇"></a>白书《挑战程序设计竞赛》第2版 准备篇+初级篇</h1><blockquote><p> 题目链接       <a href="https://cn.vjudge.net/article/426" target="_blank" rel="noopener">https://cn.vjudge.net/article/426</a></p></blockquote><a id="more"></a><h2 id="POJ-1852-Ants"><a href="#POJ-1852-Ants" class="headerlink" title="POJ 1852 Ants"></a>POJ 1852 Ants</h2><blockquote><p>思维：俩蚂蚁碰头后回头走，在这一问题里<strong>等效</strong>于不回头</p></blockquote><pre><code class="lang-c++">//菜到窒息#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int l, n, val, tem_first, first = 0, mmin = 0x3f3f3f3f, mmax = -1;        scanf(&quot;%d%d&quot;, &amp;l, &amp;n);        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;val);            if(val &gt; mmax)                mmax = val;            if(val &lt; mmin)                mmin = val;            tem_first = min(val, l - val);            if(tem_first &gt; first)                first = tem_first;        }        cout &lt;&lt; first &lt;&lt; &#39; &#39;;        cout &lt;&lt; max(l - mmin, mmax) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h2 id="POJ-2386-Lake-Counting"><a href="#POJ-2386-Lake-Counting" class="headerlink" title="POJ 2386 Lake Counting"></a>POJ 2386 Lake Counting</h2><blockquote><p>DFS八个方位</p></blockquote><pre><code class="lang-c++">//菜到窒息#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;string s[105];int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};void DFS(int x, int y){    s[x][y] = &#39;.&#39;;    for(int i = 0; i &lt; 8; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &lt; 0 || xx &gt;= n || yy &lt; 0 | yy &gt;= m || s[xx][yy] == &#39;.&#39;)            continue;        s[xx][yy] = &#39;.&#39;;        DFS(xx, yy);    }}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 0; i &lt; n; ++i)        cin &gt;&gt; s[i];    int ans = 0;    for(int i = 0; i &lt; n; ++i)        for(int j = 0; j &lt; m; ++j)            if(s[i][j] == &#39;W&#39;)            {                DFS(i, j);                ans++;            }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h2 id="POJ-3617-Best-Cow-Line"><a href="#POJ-3617-Best-Cow-Line" class="headerlink" title="POJ 3617 Best Cow Line"></a>POJ 3617 Best Cow Line</h2><blockquote><p>贪心</p></blockquote><pre><code class="lang-c++">//菜到窒息#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    char ch;    cin &gt;&gt; n;    getchar();    string s, t, ss;    for(int i = 0; i &lt; n; ++i)    {        scanf(&quot;%c&quot;, &amp;ch);        getchar();        s += ch;    }    for(int i = 0; i &lt; n; ++i)    {        ///下标从0开始，放在前面是每80，放在后面是每81        if(i % 80 == 0 &amp;&amp; i != 0)            cout &lt;&lt; &#39;\n&#39;;        ss = s;        reverse(ss.begin(), ss.end());        if(s &lt;= ss)            putchar(s[0]), s.erase(s.begin());        else            putchar(ss[0]), s.erase(s.end() - 1);    }    cout &lt;&lt; &#39;\n&#39; ;    return 0;}</code></pre><h2 id="POJ-3253-Fence-Repair"><a href="#POJ-3253-Fence-Repair" class="headerlink" title="POJ 3253 Fence Repair"></a>POJ 3253 Fence Repair</h2><blockquote><p>贪心，好像跟简单的石子合并不是一回事儿</p></blockquote><pre><code class="lang-c++">//菜到窒息#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main(){    vector&lt;int&gt; vec;    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)    {        int tem;        scanf(&quot;%d&quot;, &amp;tem);        ///vector据大小插入        vec.insert(lower_bound(vec.begin(), vec.end(), tem), tem);    }    long long ans = 0;/// &gt;= 2个int可能超int    while(vec.size() &gt; 1)    {        int t = vec[0] + vec[1];        ans += t;        vec.erase(vec.begin());        vec.erase(vec.begin());        vec.insert(lower_bound(vec.begin(), vec.end(), t), t);    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h2 id="POJ-2431-Expedition"><a href="#POJ-2431-Expedition" class="headerlink" title="POJ 2431 Expedition"></a>POJ 2431 Expedition</h2><blockquote><p>贪心 + 思维</p><p>转换一些基本的思路, 在到达加油站i时, 其实就可以认为获得了一次在i之后的任何时候都可以加油a[i].val的机会</p></blockquote><pre><code class="lang-c++">//菜到窒息#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int pos, val;    bool vis;} a[10005];bool cmp(node a, node b){    return a.pos &lt; b.pos;}int main(){    int n, ans = 0, over, init;    cin &gt;&gt; n;    priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt;q;    for(int i = 0; i &lt; n; ++i)        scanf(&quot;%d%d&quot;, &amp;a[i].pos, &amp;a[i].val);    scanf(&quot;%d%d&quot;, &amp;over, &amp;init);    for(int i = 0; i &lt; n; ++i)        a[i].pos = over - a[i].pos;    sort(a, a + n, cmp);    bool flag = 1;    while(init &lt; over)    {        for(int i = 0; a[i].pos &lt;= init; ++i)        {            if(a[i].vis)                continue;            else                a[i].vis = 1, q.push(a[i].val);        }        if(q.size())            init += q.top(), q.pop(), ans++;        else        {            flag = 0;            break;        }    }    if(!flag)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    else        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得</title>
      <link href="2019/05/31/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>2019/05/31/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><blockquote><p>扩展欧几里德算法是用来在已知a, b求解一组x，y，使它们满足贝祖等式： ax+by = gcd(a, b) =d（解一定存在，根据数论中的相关定理）。扩展欧几里德常用在求解模线性方程及方程组中。 </p></blockquote><a id="more"></a><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">int extgcd(int a, int b,int &amp; x, int &amp; y){    int d = a;    if(b != 0)    {        d = extgcd(b, a % b, y, x);        y -= (a / b) * x;    }    else  x = 1, y = 0;    return d;}</code></pre><p>对于方程ax + by = gcd(a, b)；我们设解为x1,  y1</p><p>我们令a = b, b = a % b;</p><p>得到方程bx + a % by = gcd(b， a % b);</p><p>由欧几里得算法可以得到gcd(a, b) = gcd(b, a % b);</p><p>代入可得：bx + a % b y = gcd(a, b)</p><p>设此方程解为x2, y2；</p><p>在计算机中我们知道： a % b = a - (a / b) * b;</p><p>代入方程化解得：</p><p>ay2 + b(x2 - (a / b) y2) = gcd(a, b);</p><p>与ax1 + by1 = gcd(a, b) 联立，我们很容易得：</p><blockquote><p>x1 = y2,          y1 = x2 - ( a  /  b ) y2 ;</p><p>y2为后来的第四维值，要把它赋给x1（原来第三维值）</p><p>才有了<code>extgcd( , , y, )</code></p><p>而<code>extgcd( , , , x)</code>这里把后来的第三维值（x2）赋给了原来的第四维值（y1）</p><p><strong>现在x2  y2 没有了，取而代之的是 y1, x1</strong></p><p>但根据<code>y1 = x2 - (a / b)y2</code> 判断原来的y1还应该加一步此操作</p><p>但执行完<code>extgcd( , , y, x)</code>后x2赋给了y1后消失了，y2赋给了x1后消失了</p><p>所以只能借用y1 替换 x2， 用 y2 替换 x1 ， 得</p><p>y1 = y1 - (a / b)x1</p><p>即 y = y - (a / b) x</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 数论の扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1539 恰当选择DP对象</title>
      <link href="2019/05/31/SDNUOJ-1539-%E6%81%B0%E5%BD%93%E9%80%89%E6%8B%A9DP%E5%AF%B9%E8%B1%A1/"/>
      <url>2019/05/31/SDNUOJ-1539-%E6%81%B0%E5%BD%93%E9%80%89%E6%8B%A9DP%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>T组输入样例</p><p>N个物品，W最大承重</p><p>每个物品都有对应的w[i], v[i]</p><p>求总重不超W时最大价值V</p></blockquote><a id="more"></a><blockquote><blockquote><p>01背包选择价值作为DP对象，详见小白书Page61</p></blockquote></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int dp[505][5005];int w[505], v[505];int N, W;int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;N, &amp;W);        for(int i = 1; i &lt;= N; ++i)            scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);        memset(dp, INF, sizeof(dp));        dp[0][0] = 0;        for(int i = 1; i &lt;= N; ++i)            for(int j = 0; j &lt;= 5000; ++j)            {                if(j &lt; v[i])                    dp[i][j] = dp[i - 1][j];                else                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);            }        int ans = 0;        for(int i = 0; i &lt;= 5000; ++i)        {            if(dp[N][i] &lt;= W)                ans = i;        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces B.Arpa&#39;s weak amphitheater and Mehrdad&#39;s ...</title>
      <link href="2019/05/30/Codeforces-B-Arpa-s-weak-amphitheater-and-Mehrdad-s/"/>
      <url>2019/05/30/Codeforces-B-Arpa-s-weak-amphitheater-and-Mehrdad-s/</url>
      
        <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><blockquote><p>n人分属不同的朋友圈，这些人都有自己的体重w与美丽度b，他们之间有m个关系描述（是朋友）。有一个舞台最大承重w，从每个朋友圈中选一个人或全选，在不超重前提下选美丽度最大的情况。</p></blockquote><a id="more"></a><p><a href="http://codeforces.com/problemset/problem/741/B" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/741/B</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote><p>题目有个关于两个人属于同一朋友圈的叙述：</p><p>Two Hoses <em>x</em> and <em>y</em> are in the same friendship group if and only if there is a sequence of Hoses <em>a</em>1, <em>a</em>2, …, <em>ak</em> such that <em>ai</em> and <em>ai</em> + 1 are friends for each 1 ≤ <em>i</em> &lt; <em>k</em>, and <em>a</em>1 = <em>x</em> and <em>ak</em> = <em>y</em>.</p><p>AB、BC属于同一个圈，则AC属于同一个圈</p><p>AB、BC、CD属于同一个圈，则AD属于同一个圈</p><p>仔细想想其实就是个并查集 </p><p>选一个或‘全都要’：</p><p>将’全都要‘等效成新的‘一个’，即将‘特殊’一般化</p><p>接下来背包DP，不过我没看出来‘每组只取一个’体现在哪？重量循环在外层？可以问问师哥</p></blockquote><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N, M, W, x, y;int w[10005];int b[10005];int pre[10005];int dp[1005];vector&lt;int&gt; vec[10005];void init(){    for(int i = 0; i &lt;= N; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[y] = x;}int main(){    cin &gt;&gt; N &gt;&gt; M &gt;&gt; W;    ///1. 初始化与输入    init();    for(int i = 1; i &lt;= N; ++i)        scanf(&quot;%d&quot;, &amp;w[i]);    for(int i = 1; i &lt;= N; ++i)        scanf(&quot;%d&quot;, &amp;b[i]);    ///2. 并查集分组    for(int i = 1; i &lt;= M; ++i)    {        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        unite(x, y);    }    for(int i = 1; i &lt;= N; ++i)        vec[ found(i) ].push_back(i);    ///3. 枪打出头鸟：特殊一般化    ///&quot;全拿&quot;等效成&quot;新的一组&quot;    int num = N + 1;    for(int i = 1; i &lt;= N; ++i)    {        if(vec[i].size() == 0)            continue;        int sz = vec[i].size();        int ww = 0, bb = 0;        for(int j = 0; j &lt; sz; ++j)        {            ww += w[ vec[i][j] ];            bb += b[ vec[i][j] ];        }        w[num] = ww;        b[num] = bb;        vec[i].push_back(num++);    }    for(int i = 1; i &lt;= N; ++i)///某个非空集合num    {        if(vec[i].size() == 0)            continue;        ///哪里体现了&quot;从每个集合里只选一个&quot;的要求？        int sz = vec[i].size();        for(int j = W; j &gt;= 1; --j)            for(int k = 0; k &lt; sz; ++k)///非空集合num中每个元素                if(j &gt;= w[ vec[i][k] ])/// &gt;= 别漏了&#39;=&#39;                    dp[j] = max(dp[j], dp[j - w[ vec[i][k] ]] + b[ vec[i][k] ]);        ///每个集合循环一次才决定了一个dp[j]，每个集合只对应一个dp[w]        ///最终的dp[w]是最优的    }    cout &lt;&lt; dp[W] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
            <tag> DPの背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces B.Eugeny and Play List</title>
      <link href="2019/05/28/Codeforces-B-Eugeny-and-Play-List/"/>
      <url>2019/05/28/Codeforces-B-Eugeny-and-Play-List/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n首歌曲，给出每首歌曲的总时长以及播放次数，给出一个时刻，输出这一时刻再放哪首歌曲（前开后闭）</p></blockquote><a id="more"></a><p><a href="http://codeforces.com/problemset/problem/302/B" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/302/B</a></p><h1 id="二分（要简洁，防止死循环）"><a href="#二分（要简洁，防止死循环）" class="headerlink" title="二分（要简洁，防止死循环）"></a>二分（要简洁，防止死循环）</h1><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[100005];int sum[100005];int main(){    int n, m, c, t;    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%d%d&quot;, &amp;c, &amp;t);        a[i] = c * t;        sum[i] = sum[i - 1] + a[i];    }    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d&quot;, &amp;t);        int l = 0, r = n, mid;        while(r - l &gt; 1)        {            mid = (l + r + 1) &gt;&gt; 1;            if(sum[mid] &gt;= t)                r = mid;            else                l = mid;        }        cout &lt;&lt; r &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流Dinic算法</title>
      <link href="2019/05/23/%E6%9C%80%E5%A4%A7%E6%B5%81Dinic%E7%AE%97%E6%B3%95/"/>
      <url>2019/05/23/%E6%9C%80%E5%A4%A7%E6%B5%81Dinic%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Dinic"><a href="#Dinic" class="headerlink" title="Dinic"></a>Dinic</h1><blockquote><p>前面的网络流算法，每进行一次增广，都要做 一遍BFS，十分浪费。能否少做几次BFS?  这就是Dinic算法要解决的问题 </p><p>Dinic是EK(SAP)的改进，但可能逊于ISAP</p></blockquote><a id="more"></a><blockquote><p>参考博客：<a href="https://blog.csdn.net/A_Comme_Amour/article/details/79356220" target="_blank" rel="noopener">https://blog.csdn.net/A_Comme_Amour/article/details/79356220</a></p></blockquote><h2 id="Code（模板）-O-n-n-m"><a href="#Code（模板）-O-n-n-m" class="headerlink" title="Code（模板） O(n  n m)"></a>Code（模板） O(n <em> n </em>m)</h2><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10005;const int INF = 0x3f3f3f3f;typedef long long ll;ll n, m;int maxflow, deep[N];///deep深度struct Edge{    int to, w, pre;} a[N];queue&lt;int&gt; q;int cnt = -1, head[N], cur[N];///cur用于复制head///cnt in this way can save the time///我也试过cnt初始化为0，最后加个++cnt，但TLEvoid add(int from, int to, int w){    a[++cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;}bool bfs(int s, int t)///update deep[]{    memset(deep, INF, sizeof(deep));    while(!q.empty())        q.pop();    for(int i = 0; i &lt;= n; ++i)        cur[i] = head[i];    deep[s] = 0;    q.push(s);    while(q.size())    {        int first = q.front();        q.pop();        for(int i = head[first]; ~i; i = a[i].pre)        {            if(deep[ a[i].to ] == INF &amp;&amp; a[i].w)///w在此处用来做标记 是正图还是返图            {                deep[ a[i].to ] = deep[first] + 1;                q.push(a[i].to);            }        }    }    if(deep[t] &lt; INF)        return 1;    else        return 0;}int dfs(int now, int t, int limit){    if(!limit || now == t)        return limit;    int flow = 0, f;    for(int i = cur[now]; ~i; i = a[i].pre)    {        cur[now] = i;        if(deep[ a[i].to ] == deep[now] + 1)            if(f = dfs(a[i].to, t, min(limit, a[i].w)))            {                flow += f;                limit -= f;                a[i].w -= f;                a[i^1].w += f;                if(!limit)                    break;            }    }    return flow;}void Dinic(int s, int t){    while(bfs(s, t))        maxflow += dfs(s, t, INF);}int main(){    memset(head, -1, sizeof(head));    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);    int start, over, x, y,z;    scanf(&quot;%d%d&quot;, &amp;start, &amp;over);    for(int i = 1; i &lt;= m; ++i)    {        scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);        add(x, y, z);        add(y, x, 0);    }    Dinic(start, over);    cout &lt;&lt; maxflow &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><blockquote><p>果然，涉及DFS的东西，不好理解…</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂与斐波那契不得不说的故事</title>
      <link href="2019/05/22/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>2019/05/22/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E4%B8%8D%E5%BE%97%E4%B8%8D%E8%AF%B4%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h1><blockquote><p>求矩阵A的k（较大）次幂（% 1e9 + 7）</p></blockquote><a id="more"></a><h2 id="Code-模板"><a href="#Code-模板" class="headerlink" title="Code(模板)"></a>Code(模板)</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;ll n, mi;struct mtx{    ll m[105][105];};mtx mpy(mtx a, mtx b){    mtx ans;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)        {            ans.m[i][j] = 0;            for(int k = 1; k &lt;= n; ++k)                ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;        }    return ans;}mtx fast_mod(mtx a, ll k){    mtx ans = a;    k--;    while(k)    {        if(k &amp; 1)            ans = mpy(ans, a);        a = mpy(a, a);        k &gt;&gt;= 1;    }    return ans;}int main(){    mtx a;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;mi);    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)            scanf(&quot;%lld&quot;, &amp;a.m[i][j]);    if(mi == 0)    {        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                ans.m[i][j] = (i == j ? 1 : 0);    }    else        ans = fast_mod(a, mi);    for(int i = 1; i &lt;= n; ++i)    {        for(int j = 1; j &lt;= n; ++j)        {            cout &lt;&lt; ans.m[i][j];            if(j != n)                cout &lt;&lt; &#39; &#39;;        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h2 id="SDNUOJ-1062-Fibonacci"><a href="#SDNUOJ-1062-Fibonacci" class="headerlink" title="SDNUOJ 1062 Fibonacci"></a>SDNUOJ 1062 Fibonacci</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;ll n, mi;struct mtx{    ll m[10][10];};mtx mpy(mtx a, mtx b){    mtx ans;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)        {            ans.m[i][j] = 0;            for(int k = 1; k &lt;= n; ++k)                ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;        }    return ans;}mtx fast_mod(mtx a, ll k){    mtx ans = a;    k--;    while(k)    {        if(k &amp; 1)            ans = mpy(ans, a);        a = mpy(a, a);        k &gt;&gt;= 1;    }    return ans;}int main(){    n = 2;    mtx a;    a.m[1][1] = 1, a.m[1][2] = 1, a.m[2][1] = 1, a.m[2][2] = 0;    scanf(&quot;%lld&quot;, &amp;mi);    if(mi == 0)        cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;    else    {        a = fast_mod(a, mi);        cout &lt;&lt; a.m[1][2] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><p><img src="https://i.loli.net/2019/05/22/5ce5540be401481221.png" alt="规律"></p><p><img src="https://i.loli.net/2019/05/22/5ce5542dee66131502.png" alt="规律2"></p><blockquote><p>对于此题</p></blockquote><p><img src="https://i.loli.net/2019/05/23/5ce61ceeae24430414.png" alt="solution"></p><h2 id="SDNUOJ-1085-爬楼梯再加强版"><a href="#SDNUOJ-1085-爬楼梯再加强版" class="headerlink" title="SDNUOJ 1085 爬楼梯再加强版"></a>SDNUOJ 1085 爬楼梯再加强版</h2><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int mod = 1e9 + 7;ll n, mi;struct mtx{    ll m[10][10];};mtx mpy(mtx a, mtx b){    mtx ans;    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= n; ++j)        {            ans.m[i][j] = 0;            for(int k = 1; k &lt;= n; ++k)                ans.m[i][j] = (ans.m[i][j] + a.m[i][k] * b.m[k][j]) % mod;        }    return ans;}mtx fast_mod(mtx a, ll k){    mtx ans = a;    k--;    while(k)    {        if(k &amp; 1)            ans = mpy(ans, a);        a = mpy(a, a);        k &gt;&gt;= 1;    }    return ans;}int main(){    n = 3;    mtx a, b;    a.m[1][1] = 1, a.m[1][2] = 1, a.m[1][3] = 1;    a.m[2][1] = 1, a.m[2][2] = 0, a.m[2][3] = 0;    a.m[3][1] = 0, a.m[3][2] = 1, a.m[3][3] = 0;    b.m[1][1] = 4, b.m[2][1] = 2, b.m[3][1] = 1;    scanf(&quot;%lld&quot;, &amp;mi);    if(mi == 1)        cout &lt;&lt; &#39;1&#39; &lt;&lt; &#39;\n&#39;;    else if(mi == 2)        cout &lt;&lt; &#39;2&#39; &lt;&lt; &#39;\n&#39;;    else if(mi == 3)        cout &lt;&lt; &#39;4&#39; &lt;&lt; &#39;\n&#39;;    else    {        a = fast_mod(a, mi - 3);        a = mpy(a, b);        cout &lt;&lt; a.m[1][1] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论の快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大流EK算法</title>
      <link href="2019/05/21/%E6%9C%80%E5%A4%A7%E6%B5%81EK%E7%AE%97%E6%B3%95/"/>
      <url>2019/05/21/%E6%9C%80%E5%A4%A7%E6%B5%81EK%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="容量网络"><a href="#容量网络" class="headerlink" title="容量网络"></a>容量网络</h1><blockquote><p>设G(V,E),是一个<strong>有向</strong>网络;</p><p>在V中指定了一个顶点,称为源点(记为Vs),以及另一个顶点,称为汇点(记为Vt);</p><p>对于每一条弧<u,v>属于E,对应有一个权值c(u,v)&gt;0,称为弧的容量.</u,v></p><p>通常把这样的有向网络G称为容量网络. </p></blockquote><a id="more"></a><h1 id="弧的流量"><a href="#弧的流量" class="headerlink" title="弧的流量"></a>弧的流量</h1><blockquote><p>通过容量网络G中每条弧<u,v>,上的实际流量(简称流量),记为f(u,v); </u,v></p></blockquote><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><blockquote><p>所有弧上流量的集合f={f(u,v)},称为该容量网络的一个网络流 </p></blockquote><h1 id="可行流-与流网络性质"><a href="#可行流-与流网络性质" class="headerlink" title="可行流(与流网络性质)"></a>可行流(与流网络性质)</h1><blockquote><p>在容量网络G中满足以下条件(1、3)的网络流f,称为可行流 (123为流网络性质)</p><ol><li>容量限制：对任意u,v∈V，f(u,v)≤c(u,v)。</li><li>反对称性：对任意u,v∈V，f(u,v) = -f(v,u)。从u到v的流量一定是从v到u的流量的相反值。</li><li>流守恒性：对任意u，若u不为S或T，一定有∑f(u,v)=0，(u,v)∈E。即u到相邻节点的流量之和为0，因为流入u的流量和u点流出的流量相等，u点本身不会”制造”和”消耗”流量</li></ol></blockquote><h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><blockquote><p>在容量网络中,满足弧流量限制条件,且满足平衡条件并且具有最大流量的可行流,称为网络最大流,简称最大流. </p></blockquote><h1 id="如何求最大流？-何为增广路"><a href="#如何求最大流？-何为增广路" class="headerlink" title="如何求最大流？(何为增广路)"></a>如何求最大流？(何为增广路)</h1><blockquote><p>假如所有边上的流量都没有超过容量（水管），那么就把这个流，称为一个可行流。</p><p>易见，任一网络中都有一个零流，即每弧a上f(a)=0的流f.</p><p>我们就从这个零流开始考虑，假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点(这条路叫做可行路径)，并且，这条路上的每一段都满足流量&lt;容量，注意，是严格的&lt;,而不是&lt;=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。</p><p>这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路</p></blockquote><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><blockquote><p>每次寻找增广路(就是源点到汇点的一条可行路)然后ans+=增广路能流过的流量，更新剩余网络，然后再做增广路，直到做不出增广路。</p></blockquote><h1 id="反向边"><a href="#反向边" class="headerlink" title="反向边"></a>反向边</h1><blockquote><p>加条反相边那就是给程序一个<strong>反悔</strong>的机会</p><p>现实中，反相边是不存在的，只是在程序中出现</p></blockquote><h1 id="残余（残量）网络"><a href="#残余（残量）网络" class="headerlink" title="残余（残量）网络"></a>残余（残量）网络</h1><blockquote><p>在一个网络流图上，找到一条源到汇的路径（即找到了一个流量）后，对路径上所有的边，其容量都减去此次找到的量，对路径上所有的边，都添加一条反向边，其容量也等于此次找到的流量，这样得到的新图，就称为原图的“残余网络” </p></blockquote><h1 id="为什么要加反向边？"><a href="#为什么要加反向边？" class="headerlink" title="为什么要加反向边？"></a>为什么要加反向边？</h1><blockquote><p>在做增广路时可能会阻塞后面的增广路…或者说做增广路本来是有个顺序才能找完最大流的…..但我们是任意找的…为了修正…就每次将流量加在了反向弧上…让后面的流能够进行自我调整…剩余网络的更新(就在原图上更新就可以了) </p><p>据说是Ford-Fulkerson算法的改进，EK = SAP(Shortest Augmenting Path 最短增广路)</p></blockquote><h2 id="Code-模板-易MLE、TLE-O-n-m-m"><a href="#Code-模板-易MLE、TLE-O-n-m-m" class="headerlink" title="Code(模板)易MLE、TLE O(n  m  m)"></a>Code(模板)易MLE、TLE O(n <em> m </em> m)</h2><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 205;const int INF = 0x3f3f3f3f;///点、路、源点、汇点int n, m, s, t;int pre[N];int r[N][N];    ///残余网络bool vis[N];///寻找一条从s到t的增广路，若找到返回truebool bfs(int s, int t){    queue&lt;int&gt; q;    memset(vis, 0, sizeof(vis));    memset(pre, -1, sizeof(pre));    vis[s] = 1;    q.push(s);    while(q.size())    {        int first = q.front();        q.pop();        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; r[first][i] &gt; 0)            {                pre[i] = first;                vis[i] = 1;                if(i == t)                    return 1;                q.push(i);            }    }    return 0;}int EK(int s, int t){    int flow = 0, d, i;    while(bfs(s, t))    {        d = INF;        for(i = t; i != s; i = pre[i])///i != s            d = min(d, r[ pre[i] ][i]);        for(i = t; i != s; i = pre[i])        {            r[ pre[i] ][i] -= d;            r[i][ pre[i] ] += d;        }        flow += d;    }    return flow;}int main(){    while(~scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;s, &amp;t))    {        int u, v, w;        memset(r, 0, sizeof(r));        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);            r[u][v] += w;       /// = will WA        }        cout &lt;&lt; EK(s, t) &lt;&lt; &#39;\n&#39;;;    }    return 0;}</code></pre><blockquote><p>参考博客：</p><ol><li>思想 <a href="https://www.cnblogs.com/pk28/p/8039645.html" target="_blank" rel="noopener">https://www.cnblogs.com/pk28/p/8039645.html</a></li><li>定义 <a href="https://blog.csdn.net/x_y_q_/article/details/51999466" target="_blank" rel="noopener">https://blog.csdn.net/x_y_q_/article/details/51999466</a></li><li>概念 <a href="https://blog.csdn.net/A_Comme_Amour/article/details/79356220" target="_blank" rel="noopener">https://blog.csdn.net/A_Comme_Amour/article/details/79356220</a></li><li>过程 <a href="https://blog.csdn.net/wzw1376124061/article/details/55001639" target="_blank" rel="noopener">https://blog.csdn.net/wzw1376124061/article/details/55001639</a></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 网络流の最大流最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNU 1330 Max Sum</title>
      <link href="2019/05/19/SDNUOJ-1330-Max-Sum/"/>
      <url>2019/05/19/SDNUOJ-1330-Max-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="最大上升子序列（模板）"><a href="#最大上升子序列（模板）" class="headerlink" title="最大上升子序列（模板）"></a>最大上升子序列（模板）</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>给定长度为n的正整数序列a1,a2,…,an。</p><p>令sum=ab1+ab2+…+abm，并且满足：ab1&lt;ab2&lt;…&lt;abm；b1&lt;b2&lt;…&lt;bm;1&lt;=m&lt;=n。</p><p>求最大的sum。</p></blockquote><a id="more"></a><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[1005];long long sum[1005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        sum[0] = a[0] = 0;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum[i] = a[i];        }        for(int i = 1; i &lt;= n; ++i)        {            long long tem = sum[i];            for(int j = i - 1; j &gt;= 1; --j)                if(a[j] &lt; a[i])                tem = max(tem, sum[j] + a[i]);///想清楚,非 sum[i] + a[j]            sum[i] = tem;        }        long long ans = 0;        for(int i = 1; i &lt;= n; ++i)            ans = max(ans, sum[i]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那晚，竟然发生这种可怕的事</title>
      <link href="2019/05/16/%E9%82%A3%E6%99%9A%EF%BC%8C%E7%AB%9F%E7%84%B6%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E5%8F%AF%E6%80%95%E7%9A%84%E4%BA%8B/"/>
      <url>2019/05/16/%E9%82%A3%E6%99%9A%EF%BC%8C%E7%AB%9F%E7%84%B6%E5%8F%91%E7%94%9F%E8%BF%99%E7%A7%8D%E5%8F%AF%E6%80%95%E7%9A%84%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="2019-5-16晚刷水题"><a href="#2019-5-16晚刷水题" class="headerlink" title="2019.5.16晚刷水题"></a>2019.5.16晚刷水题</h1><blockquote><p>本来自在地刷着水题，结果竟然发生这种事！！！？？？</p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2019/05/16/5cdd61eed46d282170.png" alt="terrible"></p><blockquote><p>一道水题PE了近一个小时！！！？？？</p><p>output：</p><p><strong>m行，每行若干个从小到大排好序的、用一个空格隔开的整数 </strong></p></blockquote><p><code>for(int i = 0; i &lt; m; ++i)</code></p><pre><code class="lang-c++">int sz = vec[a].size();for(int j = 0; j &lt; sz; ++j)    printf(&quot;%d%c&quot;, vec[a][j], j == sz - 1 ? &#39;\n&#39;: &#39; &#39;);</code></pre><pre><code class="lang-c++">int sz = vec[a].size();for(int j = 0; j &lt; sz; ++j)    cout &lt;&lt; vec[a][j] &lt;&lt; &#39; &#39; ;cout &lt;&lt; &#39;\n&#39;;</code></pre><pre><code class="lang-c++">int sz = vec[a].size();for(int j = 0; j &lt; sz; ++j)    cout &lt;&lt; vec[a][j] &lt;&lt; &#39; &#39; ;if(i != m - 1)   cout &lt;&lt; &#39;\n&#39;;</code></pre><blockquote><p>死马当活马医，我看数组开挺大的，输出时有延迟，改用map套vector</p></blockquote><pre><code class="lang-c++">map&lt;int, vector&lt;int&gt; &gt;mp;scanf(&quot;%d&quot;, &amp;a);int sz = mp[a].size();for(int j = 0; j &lt; sz; ++j)    printf(&quot;%d%c&quot;, mp[a][j], j == sz - 1 ? &#39;\n&#39;: &#39; &#39;);</code></pre><pre><code class="lang-c++">int sz = mp[a].size();        for(int j = 0; j &lt; sz; ++j)        {            cout &lt;&lt; mp[a][j];            if(j == sz - 1)                cout &lt;&lt; endl;            else                cout &lt;&lt; &#39; &#39;;        }</code></pre><pre><code class="lang-c++">        int sz = vec[a].size();        for(int j = 0; j &lt; sz; ++j)        {            cout &lt;&lt; vec[a][j];            if(j == sz - 1)                cout &lt;&lt; endl;            else                cout &lt;&lt; &#39; &#39;;        }</code></pre><blockquote><p>都PE，然而正确输出是：先输出第一个数字，以后每次输出一个空格+一个数字，最后输出回车</p><p>……我先输出数字+空格，控制最后一个数字后输出的是回车，不一样吗！！！？？？</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浪潮杯第十届山东省大学生ACM程序设计竞赛</title>
      <link href="2019/05/15/%E6%B5%AA%E6%BD%AE%E6%9D%AF%E7%AC%AC%E5%8D%81%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9FACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"/>
      <url>2019/05/15/%E6%B5%AA%E6%BD%AE%E6%9D%AF%E7%AC%AC%E5%8D%81%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81%E5%A4%A7%E5%AD%A6%E7%94%9FACM%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="http://acm.zju.edu.cn/onlinejudge/showProblems.do?contestId=1&pageNumber=32" style="color:violet;" target="_blank" rel="noopener">ZOJ题目总链接（4113~4125）</a></strong>  </p><h1 id="A-Calander"><a href="#A-Calander" class="headerlink" title="A.Calander"></a>A.Calander</h1><blockquote><p>给出一个新的日期计算方法，一周五天（周一至周五），一月6个周（30天），一年有这样的十二个月，给出一个日期及其星期，另给出一个日期，求出星期</p></blockquote><a id="more"></a><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>一看日期计算 —&gt; 形成思维定式：不就是求两个日期差 % 5吗！</p><p>后来各种错：</p><ol><li>% 5 之后对应数字为0~4，要搞清楚其对应周几</li><li>封榜后发现与年份无关，一年是那固定的360天，% 5 == 0</li><li>赛后再想想与月份都无关，一个月是那固定的30天， % 5 == 0</li></ol><p>所以，题目给出一个新事物（或是旧事物的变式），一定要先<strong>找其运行规律，总结特点</strong>，抓住特点去做，不要因着急而盲目去做。一个人在敲这个题时，另外两人不仅要思考这方法是否正确、细节是否都注意到了、特判做到了，还要想想是否有更简单的方法，因为更简单的方法一定是更优的，是更能体现参赛者水平的，是出题人想看到的。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    map&lt;int, string&gt; mp;    mp[1] = &quot;Monday&quot;;    mp[2] = &quot;Tuesday&quot;;    mp[3] = &quot;Wednesday&quot;;    mp[4] = &quot;Thursday&quot;;    mp[5] = &quot;Friday&quot;;    while(t--)    {        int ay, am, ad, by, bm, bd, idx;        string s;        scanf(&quot;%d%d%d&quot;, &amp;ay, &amp;am, &amp;ad);        cin &gt;&gt; s;        switch(s[1])        {        case &#39;o&#39;:            idx = 1;            break;        case &#39;u&#39;:            idx = 2;            break;        case &#39;e&#39;:            idx = 3;            break;        case &#39;h&#39;:            idx = 4;            break;        case &#39;r&#39;:            idx = 5;        }        scanf(&quot;%d%d%d&quot;, &amp;by, &amp;bm, &amp;bd);        int tem = 30 - ad + bd;        tem %= 5;        if((idx + tem) % 5 == 0)            cout &lt;&lt; &quot;Friday&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; mp[(idx + tem) % 5] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="B-Flipping-Game"><a href="#B-Flipping-Game" class="headerlink" title="B.Flipping Game"></a>B.Flipping Game</h1><blockquote><p>updating……</p></blockquote><h1 id="C-Wandering-Robot"><a href="#C-Wandering-Robot" class="headerlink" title="C.Wandering Robot"></a>C.Wandering Robot</h1><blockquote><p>一个机器人按照一个长度为n的指令串重复走k次，求其离原点的最远“折线距离”</p></blockquote><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><blockquote><p>第一次我想出一个思路：</p><p>执行一次指令串后离原点的距离 * (k - 1) + 最后一次的最优解：WA</p><p>研究了一会儿，队友发现：最后一次的最优解可能并不是前（k-1）次位移方向上的！</p><p>过了53分钟修改上交：WA</p><p>耽误时间长了去看了D题，没敲对，C题int改longlong交了一遍？WA</p><p>队友提出利用坐标，发现这种思路跟之前的一样，不过实现起来思路更清晰：WA</p><p>队友提出遗漏：答案也可能只是第一次的最优解（比如只执行两次指令时）：AC</p><ol><li><p>在纸上多画图、多模拟，不至于看不出来第一个错误！</p></li><li><p>多思考队友的思路、提出的建议，不要第一时间想着反驳</p><p>（当这题的第一个思路（或主思路）是自己想出来的时候，心里有种不愿别人提出异议的感觉？一种不容别人提出更完善策略的感觉？你的思路跟我的一样，只不过实现方式不一样，我的理应就是对的，即使错了，那你的思路跟我一样必然也是错的）可是你不想想，同一思路换种实现方法可能更清晰呢！</p></li><li><p>多质疑自己，将错误的险隘思路拓宽</p></li></ol></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int len;string s;long long x, y;long long cal(){    long long ans = 0;    for(int i = 0; i &lt; len; ++i)    {        if(s[i] == &#39;U&#39;)            y++;        if(s[i] == &#39;D&#39;)            y--;        if(s[i] == &#39;L&#39;)            x--;        if(s[i] == &#39;R&#39;)            x++;        if(ans &lt; abs(x) + abs(y))            ans = abs(x) + abs(y);    }    return ans;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int n, k;        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);        cin &gt;&gt; s;        len = s.length();        x = 0, y = 0;        long long first = cal();        x *= (k - 1);        y *= (k - 1);        long long tem = cal();        cout &lt;&lt; max(first, tem) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="D-Game-on-a-Graph"><a href="#D-Game-on-a-Graph" class="headerlink" title="D.Game on a Graph"></a>D.Game on a Graph</h1><blockquote><p>k个分属两阵营的人在一地图上玩游戏，n个点，m条边，每人轮流拿一条边，最后谁拿走便后图不连通了，那个人所在阵营就lose，对面win</p></blockquote><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><blockquote><p>信誓旦旦地跟队友说是水题（不过确实是），这题k可以不给出（s.length()自己算），后面m组输入完全用不到。</p><p>k个人玩，n个点，只需n-1条边</p><p>m条现有边，可以拿走(m - (n - 1)) == m - n + 1条</p><p>则下一个人(m - n + 2)所属阵营lose</p><p>不过我急于交题去看C，疏忽了，没有%，罚时了</p></blockquote><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int k, a, b;        scanf(&quot;%d&quot;, &amp;k);        string s;        cin &gt;&gt; s;        int n, m;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; m; ++i)            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        int tem = (m - n + 2) % k;        if(tem == 0)            tem = k;        if(s[tem - 1] == &#39;1&#39;)            cout &lt;&lt; &#39;2&#39; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &#39;1&#39; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h1><blockquote><p>updating……</p></blockquote><h1 id="F-Stones-in-the-Bucket"><a href="#F-Stones-in-the-Bucket" class="headerlink" title="F.Stones in the Bucket"></a>F.Stones in the Bucket</h1><blockquote><p>水题（没有坑）</p></blockquote><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int a[100005];int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int n;        long long sum = 0;        long long ans = 0;        scanf(&quot;%d&quot;, &amp;n);        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum += a[i];        }        ans += sum % n;        int tem = sum / n;        for(int i = 0; i &lt; n; ++i)            if(a[i] &lt; tem)                ans += (tem - a[i]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="G"><a href="#G" class="headerlink" title="G."></a>G.</h1><blockquote><p>updating……</p></blockquote><h1 id="H-Tokens-on-the-Segments"><a href="#H-Tokens-on-the-Segments" class="headerlink" title="H.Tokens on the Segments"></a>H.Tokens on the Segments</h1><blockquote><p>这种题应该是经常出现，求最优分配</p><p>暴力贪心：</p><p>按左界从小到大排序，左界相同按右界从小到大排序</p><p>线段从最右向左遍历，每个点也从右向左遍历，相当于“采用了”满足条件的最右点（也是接下来最可能用不到的点）</p></blockquote><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;struct node{    int l, r;} a[N];bool cmp(node a, node b){    if(a.l != b.l)        return a.l &lt; b.l;    else        return a.r &lt; b.r;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int n;        scanf(&quot;%d&quot;, &amp;n);        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d%d&quot;, &amp;a[i].l, &amp;a[i].r);        sort(a, a + n, cmp);        map&lt;int, bool&gt; mp;        int ans = 0;        for(int i = n - 1; i &gt;= 0; --i)            for(int j = a[i].r; j &gt;= a[i].l; --j)                if(!mp[j])                {                    mp[j] = 1;                    ans++;                    break;                }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="I"><a href="#I" class="headerlink" title="I."></a>I.</h1><blockquote><p>updating……</p></blockquote><h1 id="J"><a href="#J" class="headerlink" title="J."></a>J.</h1><blockquote><p>updating……</p></blockquote><h1 id="k"><a href="#k" class="headerlink" title="k."></a>k.</h1><blockquote><p>updating……</p></blockquote><h1 id="L-Median"><a href="#L-Median" class="headerlink" title="L.Median"></a>L.Median</h1><blockquote><p>n个点，m个关系（a &gt; b），求是否可以知道哪些数字可以作为中位数</p></blockquote><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><blockquote><p>开场我就看了这题，说好了我从后往前看，结果漏看了M题？！以为有封面吗？！</p><p>一眼看去像拓扑排序，但…但是什么呢，忘了当时哪里不明白了，不过后来发现这题可能的中位数不止一个，当时没认识到这一问题</p><p>虑中位数的特殊性，中位数意味着一定有n个比它大的，n个比它小的，所以对于1&lt;= x &lt;= n，在给出的关系里寻找比它大数字的个数（入度）的和比它小的数字的个数（出度），只要两者都&lt;= 2/n,就说明可以是中位数 </p><p>不过最遗憾的是：我明明做过floyd闭包传递（传递闭包的含义指通过传递性<strong>推导出尽量多的元素之间的关系</strong> ） <a href="https://fireworks99.github.io/2019/04/07/POJ-3660-Cow-Contest/" target="_blank" rel="noopener">https://fireworks99.github.io/2019/04/07/POJ-3660-Cow-Contest/</a> 在场上却什么也想不出来，还是做少了…</p></blockquote><h3 id="Code-of-floyd"><a href="#Code-of-floyd" class="headerlink" title="Code of floyd"></a>Code of floyd</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;bitset&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, m;bool r[105][105];int out[105];int in[105];void floyd(){    for(int k = 1; k &lt;= n; ++k)        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(r[i][k] &amp;&amp; r[k][j])                    r[i][j] = 1;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        memset(r, 0, sizeof(r));        memset(out, 0, sizeof(out));        memset(in, 0, sizeof(in));        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int a, b;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);            r[a][b] = 1;        }        floyd();        bool flag = 1;        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)            {                if(r[i][j] &amp;&amp; r[j][i])///r[1][1] == r[1][1] == 1                {                    flag = 0;                    break;                }                if(r[i][j])                {                    out[i]++;                    in[j]++;                }            }        if(!flag)            for(int i = 0; i &lt; n; ++i)                cout &lt;&lt; &#39;0&#39;;        else        {            for(int i = 1; i &lt;= n; ++i)                if(in[i] &lt;= (n &gt;&gt; 1) &amp;&amp; out[i] &lt;= (n &gt;&gt; 1))                    cout &lt;&lt; &#39;1&#39;;                else                    cout &lt;&lt; &#39;0&#39;;        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="improved-Floyd"><a href="#improved-Floyd" class="headerlink" title="improved Floyd"></a>improved Floyd</h3><pre><code class="lang-c++">#include &lt;bitset&gt;bitset&lt;105&gt; r[105];void floyd(){        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(r[j][i])                    r[j] |= r[i];}</code></pre><h1 id="M-Sekiro"><a href="#M-Sekiro" class="headerlink" title="M.Sekiro"></a>M.Sekiro</h1><blockquote><p>水题，坑：n == 0               n == 1 &amp;&amp; k == 1e9</p></blockquote><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        int n, k;        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);        while(k--)        {            n = (n + 1) &gt;&gt; 1;            if(n == 1 || n == 0)                break;        }        cout &lt;&lt; n &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客跳过渲染，创建自定义网页</title>
      <link href="2019/05/13/Hexo-%E5%8D%9A%E5%AE%A2%E8%B7%B3%E8%BF%87%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E9%A1%B5/"/>
      <url>2019/05/13/Hexo-%E5%8D%9A%E5%AE%A2%E8%B7%B3%E8%BF%87%E6%B8%B2%E6%9F%93%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E9%A1%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Hexo 博客中所见文章都是经由渲染的静态网页，而静态网页的样式都直接由 Hexo 的主题控制，所以 Hexo 博客大部分都呈现出一种高度的统一化与规范化。不过 Hexo 提供了跳过渲染功能，使得我们可以直接在博客中放入自定义网页。比如在博客中放入图片、自定义 404.html 、自定义 About 页面等。</p></blockquote> <a id="more"></a><h1 id="自定义网页"><a href="#自定义网页" class="headerlink" title="自定义网页"></a>自定义网页</h1><blockquote><p>页可以是自己编写的，也可以是别人现成的源码。 网页编写完成后，在 Hexo\source 目录下创建一个文件夹，文件夹名称任意，将 Html 文件放置于此文件夹，并重命名为 index.html 。 </p></blockquote><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><blockquote><p>在html文件中添加跳过渲染指令：</p><p>用编辑器打开 Hexo\source 创建的文件夹中的 index.html 文件，在开头添加如下代码即可</p></blockquote><pre><code class="lang-html">---layout: false---</code></pre><blockquote><p>添加该指令后，执行 hexo g 命令时便会跳过该 index.html 文件，使得 index.html 不受当前 hexo 主题影响，完全是一个独立的网页。</p><p>如果网页引用了 css 或 js ，这些 css 和 js 必须使用外链。</p><p>如果引用图片，可以在网页目录下建立 img 文件夹，可以直接引用图片，不必再去创建外链。</p></blockquote><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><blockquote><p>使用编辑器打开 Hexo 目录下的_config.yml 文件，找到 skip_render</p><p>skip_render 一般有以下四种常用参数：</p><ol><li><p>跳过source目录下的 test.html: skip_render: test.html </p></li><li><p>跳过source目录下 test 文件夹内所有文件：skip_render: test/* </p></li><li><p>跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** </p></li><li><p>跳过多个路径： </p><pre><code class="lang-html">skip_render:- text.html- text/*</code></pre></li></ol><p>对格式要求严格，注意填写参数时的格式，添加完成后便不会渲染指定文件/文件夹。</p><p>如果网页引用了 css 或 js ，并将整个网页目录设置为跳过渲染，则不必再为 css 和 js 创建外链，可以直接引用。</p></blockquote><p>原文转自：<a href="http://blog.fangchengjin.cn/hexo-custom-page.html" target="_blank" rel="noopener">http://blog.fangchengjin.cn/hexo-custom-page.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期模拟</title>
      <link href="2019/05/08/%E6%97%A5%E6%9C%9F%E6%A8%A1%E6%8B%9F/"/>
      <url>2019/05/08/%E6%97%A5%E6%9C%9F%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>时常遇到计算两年间有多少天的日期模拟题，在这里整理一下模板</p></blockquote><a id="more"></a><blockquote><p>cal_first_year(int y, int m, int d)今天（包括在内）到年底的天数</p><p>cal_last_year(int y, int m, int d)年初至今（包括在内）的天数</p><p>cal_only_one_year(5个形参)同年内两日期间天数（闭区间）</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int num[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};bool judge(int y){    if((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0)        return 1;    return 0;}int cal_first_year(int y, int m, int d)///including this day{    int ans = 0;    for(int i = m + 1; i &lt;= 12; ++i)        ans += num[i];    ans += num[m] - d + 1;    if(judge(y) &amp;&amp; ((m == 1) || (m == 2 &amp;&amp; d &lt;= 29)) )            ans ++;    return ans;}int cal_last_year(int y, int m, int d){    int ans = 0;    for(int i = 1; i &lt;= m - 1; ++i)        ans += num[i];    ans += d;    if(judge(y) &amp;&amp; (m &gt; 2))            ans ++;    return ans;}int cal_only_one_year(int y, int am, int ad, int bm, int bd){    int ans = 0;    for(int i = am + 1; i &lt;= bm - 1; ++i)        ans += num[i];    if(am == bm)        ans += bd - ad + 1;    else        ans += num[am] - ad + 1 + bd;    if(judge(y) &amp;&amp; ((am == 1) || (am == 2 &amp;&amp; ad &lt;= 29))        &amp;&amp; ((bm == 2 &amp;&amp; bd == 29) || (bm &gt; 2)))        ans++;    return ans;}int main(){    cout &lt;&lt; cal_only_one_year(2018, 1, 1, 2, 2);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2018 Best Cow Fences</title>
      <link href="2019/05/08/POJ-2018-Best-Cow-Fences/"/>
      <url>2019/05/08/POJ-2018-Best-Cow-Fences/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N, K: 有n个农场，每个农场有不同数目的牧场，圈起不少于K个农场，用其牧场数 / 农场数 * 1000求最大值</p></blockquote><a id="more"></a><p><strong><a href="http://poj.org/problem?id=2018" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><h3 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h3><blockquote><p>因为涉及”连续项的和“，所以用前缀和维护</p><p>bool judge(mid) 遍历所有方案，若有均值 &gt;= mid 则return 1</p><p>但我只考虑了圈起k个农场的情况，忽略了 &gt; k方案，WA</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n, k;double a[100010];double sum[100010];bool judge(double ans){    for(int i = k; i &lt;= n; ++i)        if(sum[i] - sum[i - k] &gt; ans * k)            return 1;    return 0;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%lf&quot;, &amp;a[i]);        sum[i] = sum[i - 1] + a[i];    }    double mid, l = 0, r = 1e7;    while(r - l &gt; 1e-6)    {        mid = (l + r) / 2;        if(judge(mid))            l = mid;        else            r = mid;    }    printf(&quot;%.f\n&quot;, 1000 * l);    return 0;}</code></pre><h3 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h3><blockquote><p>外加一层循环，果然还是TLE了</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n, k;double a[100010];double sum[100010];bool judge(double ans){    for(int t = k; t &lt;= n; ++t)        for(int i = t; i &lt;= n; ++i)            if(sum[i] - sum[i - t] &gt; ans * double(t))                return 1;    return 0;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i = 1; i &lt;= n; ++i)    {        scanf(&quot;%lf&quot;, &amp;a[i]);        sum[i] = sum[i - 1] + a[i];    }    double mid, l = 0, r = 1e6;    while(r - l &gt; 1e-6)    {        mid = (l + r) / 2;        if(judge(mid))            l = mid;        else            r = mid;    }    printf(&quot;%d\n&quot;, int(1000 * r));    return 0;}</code></pre><h3 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h3><blockquote><p>考虑能不能两层循环优化为一层：我两层循环是在遍历所有方案，依次检验是否有符合条件的情况，但实际我只需要拿“最有可能符合条件”的那一个方案去检验即可，就像：一个集合内的最大值都&lt;n，则没有大于n的值。！！！</p><p>找“符合方案的最大均值”不好搞，没有规律、没有方法去找，然后这里有一个转化思想：</p><p>比较 ( 均值 &gt; mid ? )  等同于 (均值 - mid &gt; 0 ?) 等同于 ((每个值 - mid)总和 &gt; 0 ?)</p><p>那就只用一层循环，i 从1到 n - k，用一个量mmin存这里面最小的sum[i]，用一个量mmax存sum[i + k]里面最大的。这个想法还不对，可能前一个对应sum[n - k]，后一个对应sum[1 + k]，那两者距离相差可能小于k。</p><p>所以要控制间距。每次循环更新“最可能符合条件的方案”：mmin更新最小sum[i]，但另一个量<code>ans = max(ans, sum[i + k] - mmin)</code>，必能找到最优方案ans，且保证对应两者距离&gt;=k，<strong>因为mmin &lt;= 当前循环的i，他距离i + k的距离也因此而 &gt;= k(妙不可言)</strong></p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int n, k;double a[100010];double sum[100010];bool check(double mid){    for(int i = 1; i &lt;= n; ++i)        sum[i] = sum[i - 1] + a[i] - mid;    double mmin = 1e9;    double ans = -1e9;    for(int i = k; i &lt;= n; ++i)    {        mmin = min(mmin, sum[i - k]);        ans = max(ans, sum[i] - mmin);    }    return ans &gt; 0;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%lf&quot;, &amp;a[i]);    double mid, l = 0, r = 1e6;    while(r - l &gt; 1e-6)    {        mid = (l + r) / 2;        if(check(mid))            l = mid;        else            r = mid;    }    printf(&quot;%d\n&quot;, int(1000 * r));    return 0;}</code></pre><blockquote><p>还有件事，我之前的二分最后一直是输出左界（按理说左界==右界），但在这里输出左界不对，右界对了……</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2785 4 Values whose Sum is 0</title>
      <link href="2019/05/07/POJ-2785-4-Values-whose-Sum-is-0/"/>
      <url>2019/05/07/POJ-2785-4-Values-whose-Sum-is-0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n行数据，每行4个，每列选出一个数加起来和为0，这样的情况共几种？</p></blockquote><a id="more"></a><p><strong><a href="http://poj.org/problem?id=2785" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p><strong>四个数分成两组，计算和，二分搜索</strong></p><blockquote><p>此题坑在于：跟前一组数据匹配的后一组数据可能不止一组！！！</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 4010;int a[N], b[N], c[N], d[N], e[N * N], f[N * N];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]);        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; n; ++j)            {                e[i * n + j] = a[i] + b[j];                f[i * n + j] = c[i] + d[j];///第二个j写成了i...                int tem = i * n + j;            }        sort(e, e + n * n);        sort(f, f + n * n);        int ans = 0;        for(int i = 0; i &lt; n * n; ++i)        {            int pos = lower_bound(f, f + n * n, -e[i]) - f;            while(pos != n * n &amp;&amp; f[pos] == -e[i])//坑！            {                ans++;                pos++;            }        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="lower-bound-and-upperbound"><a href="#lower-bound-and-upperbound" class="headerlink" title="lower_bound and upperbound"></a>lower_bound and upperbound</h3><blockquote><p>lower_bound      &gt;=     找不到返回末元素的末地址（并不是末元素的首地址，一切都安排好了） </p><p>upper_bound      &gt;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
            <tag> 技巧の折半枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2289 Cup</title>
      <link href="2019/05/06/HDU-2289-Cup/"/>
      <url>2019/05/06/HDU-2289-Cup/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>一个杯子，已知上下两底面半径和杯子高度、水的体积，求水在杯中的高度</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2289" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><blockquote><p>二分：</p><p>越看越玄乎了…</p><p>那些个能直接解出来的模拟题、数学题，直接解出来的答案是错误的，或是精度丧失了的，而二分查找（枚举）赋值代数是：natural，纯真自然的、一尘不染的，可AC的…</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const double eps = 1e-9;const double PI = acos(-1.0);double r, R, H, V;double cal(double ans){    double tr = ans / H * (R - r) + r;    return (tr * tr + r * r + r * tr) * PI * ans / 3;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%lf%lf%lf%lf&quot;, &amp;r, &amp;R, &amp;H, &amp;V);//        if(R - r &lt; eps)//            printf(&quot;%.6f\n&quot;, V / (r * r * PI));//        else//        {//            double left = V / (R * R * PI);//            double right = V / (r * r * PI);            double left = 0, right = 100, tv, mid;            while(right - left &gt; eps)            {                mid = (left + right) / 2;                tv = cal(mid);                if(fabs(tv - V) &lt; eps)                    break;                else if(tv &lt; V)                    left = mid;                else                    right = mid;            }            printf(&quot;%.6f\n&quot;, mid);//        }    }    return 0;}</code></pre><blockquote><p>有时候人为好心地去缩小界线——反而好心办坏儿事…</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CodeForces 371C Hamburgers</title>
      <link href="2019/05/06/CodeForces-371C-Hamburgers/"/>
      <url>2019/05/06/CodeForces-371C-Hamburgers/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>做一个汉堡需要B(Bread)  S(Sausage)  C(Cheese)中的一种或多种，给出一个字符串代表配方，给出已有材料，相应材料商店售价，现有资金，问最多能做多少个汉堡？</p></blockquote><a id="more"></a><p><strong><a href="http://codeforces.com/problemset/problem/371/C" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><blockquote><p>二分实质：对于暴力枚举的优化</p><p>为什么会想到用二分？</p><ol><li>若想枚举出所有情况：太多且易遗漏</li><li>已知答案必在某个固定区间里（此时遍历耗时则用二分优化）</li></ol><p>明确目的：</p><p>求</p><ol><li>最大值?</li><li>最小值？</li><li>最大化最小值？</li><li>最小化最大值？</li></ol><p>三要素：</p><ol><li>下界：为了方便，可适当向下调整（求最大值时下界必须<strong>实际</strong>）</li><li>上界：为了方便，可适当向上调整（求最大值时，上界是<strong>理想值（白日梦值）</strong>）</li><li>bool judge（ll ans）：检查资金是否足够</li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int nb, ns, nc, pb, ps, pc;int B = 0, C = 0, S = 0;long long money;bool judge(long long ans){    long long needb = ans * B - nb;    long long needs = ans * S - ns;    long long needc = ans * C - nc;    if(B == 0 || needb &lt; 0)        needb = 0;    if(S == 0 || needs &lt; 0)        needs = 0;    if(C == 0 || needc &lt; 0)        needc = 0;    long long needpay = pb * needb + ps * needs + pc * needc;    if(needpay &lt;= money)        return 1;    else        return 0;}int main(){    string s;    cin &gt;&gt; s;    int sz = s.size();    scanf(&quot;%d%d%d%d%d%d&quot;, &amp;nb, &amp;ns, &amp;nc, &amp;pb, &amp;ps, &amp;pc);    cin &gt;&gt; money;    for(int i = 0; i &lt; sz; ++i)    {        if(s[i] == &#39;B&#39;)            B++;        else if (s[i] == &#39;S&#39;)            S++;        else            C++;    }    long long one = B * pb + S * ps + C * pc;    long long l =  money / one;    long long r =  money / one + max(nb, max(ns, nc));    ///找最大值时上界为 幻想值(白日梦值)    long long mid;    while(l &lt; r)    {        mid = (l + r + 1) &gt;&gt; 1;        if(judge(mid))///找最大值(二分明确所找最值)            l = mid;        else            r = mid - 1;    }    cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="改进：调整上下界"><a href="#改进：调整上下界" class="headerlink" title="改进：调整上下界"></a>改进：调整上下界</h3><pre><code class="lang-c++">long long one = B * pb + S * ps + C * pc;    long long l =  money / one;    long long r =  money / one;    if(B == 0)    {        l += min(ns / S, nc / C);        r += max(ns / S, nc / C);    }    else if(S == 0)    {        l += min(nb / B, nc / C);        r += max(nb / B, nc / C);    }    else if(C == 0)    {        l += min(nb / B, ns / S);        r += max(nb / B, ns / S);    }    else    {        l += min(nb / B, min(ns / S, nc / C));        r += max(nb / B, max(ns / S, nc / C));    }</code></pre><blockquote><p>如上，之前在找上下界时，执着于缩小范围，导致</p><ol><li><p>忽视了分母为0的情况而RE</p></li><li><p>遗漏了两种材料都不需要的情况而WA</p><p>后来干脆扩展界线，代码简单还AC了</p></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3273 Monthly Expense</title>
      <link href="2019/05/05/POJ-3273-Monthly-Expense/"/>
      <url>2019/05/05/POJ-3273-Monthly-Expense/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n天预算花费分为m组（可少于m），所有组中最大值最小是多少？</p></blockquote><a id="more"></a><p><strong><a href="http://poj.org/problem?id=3273" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>二分查找，最小化最大值</p><p>二分三要素：</p><ol><li><p>下界：(n天预算分为n组)，此时答案为n天预算中的最大值</p></li><li><p>上界：(n天预算分为1组)，此时答案为n天预算之和</p></li><li><p>bool judge(int mid)函数：</p><p>“连续”是前提，贪心性分组</p><p>分完之后，</p><p>if 组数 &lt;= m return 1 可再优化（最小化最大值）：上界更新为mid</p><p>else return 0 下界更新为 mid + 1</p></li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, m, b[100005];bool judge(int ans){    int sum = 0, num = 1;///每组的和与组数    for(int i = 0; i &lt; n; ++i)    {        if(sum + b[i] &lt;= ans)            sum += b[i];        else        {            sum = b[i];            num++;        }    }    if(num &lt;= m)        return 1;    else        return 0;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        int l = 0, r = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;b[i]);            r += b[i];            if(l &lt; b[i])///所有值里最大的                l = b[i];        }        int mid;        ///最小化最大值        while(l &lt; r)        {            mid = (l + r) &gt;&gt; 1;            if(judge(mid))///中值可以，上界降低                r = mid;            else                l = mid + 1;        }        cout &lt;&lt; l &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>背包九讲之五</title>
      <link href="2019/05/05/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%E4%B9%8B%E4%BA%94/"/>
      <url>2019/05/05/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%E4%B9%8B%E4%BA%94/</url>
      
        <content type="html"><![CDATA[<h3 id="动态规划之背包问题"><a href="#动态规划之背包问题" class="headerlink" title="动态规划之背包问题"></a>动态规划之背包问题</h3><blockquote><ol><li>01背包</li><li>完全背包</li><li>多重背包</li><li>二维费用背包</li><li>背包剩余容量最小</li></ol></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1329713104&auto=1&height=66"></iframe><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10005;int C, V, n, w[N], vue[N], val[N], num[N], m[N], dp[N][N]， gd[2][N];void slove_01bp()///0-1背包{    scanf(&quot;%d%d&quot;, &amp;C, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d&quot;, &amp;w[i], &amp;val[i]);    memset(m, 0, sizeof(m));    for(int i = 1; i &lt;= n; ++i)        for(int j = C; j &gt;= w[i]; --j)///逆序遍历            m[j] = max(m[j], m[ j - w[i] ] + val[i]);    cout &lt;&lt; m[C] &lt;&lt; &#39;\n&#39;;}void slove_01gdbp(){    scanf(&quot;%d%d&quot;, &amp;C, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d&quot;, &amp;w[i], &amp;val[i]);    memset(gd, 0, sizeof(gd));    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= C; ++j)        {            if(j &gt;= w[i])                gd[i &amp; 1][j] = max(gd[(i - 1) &amp; 1][j], gd[(i - 1) &amp; 1][j - w[i]] + val[i]);            else                gd[i &amp; 1][j] = gd[(i - 1) &amp; 1][j];        }    cout &lt;&lt; gd[n &amp; 1][C] &lt;&lt; &#39;\n&#39;;}void slove_complate_bp()///完全背包{    scanf(&quot;%d%d&quot;, &amp;C, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d&quot;, &amp;w[i], &amp;val[i]);    memset(m, 0, sizeof(m));    for(int i = 1; i &lt;= n; ++i)        for(int j = w[i]; j &lt;= C; ++j)///顺序遍历            m[j] = max(m[j], m[ j - w[i] ] + val[i]);    cout &lt;&lt; m[C] &lt;&lt; &#39;\n&#39;;}void slove_multi_bp()///多重背包(数目有限0/1背包变式){    scanf(&quot;%d%d&quot;, &amp;C, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;val[i], &amp;num[i]);    memset(m, 0, sizeof(m));    for(int i = 1; i &lt;= n; ++i)        for(int k = 0; k &lt; num[i]; ++k)            for(int j = C; j &gt;= w[i]; --j)                m[j] = max(m[j], m[ j - w[i] ] + val[i]);    cout &lt;&lt; m[C] &lt;&lt; &#39;\n&#39;;}void slove_2D_bp()///二维费用背包(0/1背包变式){    scanf(&quot;%d%d%d&quot;, &amp;C, &amp;V, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d%d&quot;, &amp;w[i], &amp;vue[i], &amp;val[i]);    memset(dp, 0, sizeof(dp));    for(int i = 1; i &lt;= n; ++i)        for(int j = C; j &gt;= w[i]; --j)            for(int k = V; k &gt;= vue[i]; --k)                dp[j][k] = max(dp[j][k], dp[j-w[i]][k-vue[i]] + val[i]);    cout &lt;&lt; dp[C][V] &lt;&lt; &#39;\n&#39;;}///背包剩余空间最小，即重量最大///将重量视为价值,即价值最大（0/1背包）void slove_min_remain_bp(){    scanf(&quot;%d%d&quot;, &amp;C, &amp;n);    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d&quot;, &amp;w[i]);    memset(m, 0, sizeof(m));    for(int i = 1; i &lt;= n; ++i)        for(int j = C; j &gt;= w[i]; --j)         m[j] = max(m[j], m[ j - w[i] ] + w[i]);    cout &lt;&lt; C - m[C] &lt;&lt; &#39;\n&#39;;}int main(){    slove_01bp();    slove_complate_bp();    slove_multi_bp();    slove_2D_bp();    slove_min_remain_bp();    return 0;}</code></pre><blockquote><p><strong><a href="https://blog.csdn.net/stack_queue/article/details/53544109" style="color:violet;" target="_blank" rel="noopener">背包九讲</a></strong></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> DPの背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1535 POJ 1511 Invitation Cards</title>
      <link href="2019/04/30/HDU-1535-POJ-1511-Invitation-Cards/"/>
      <url>2019/04/30/HDU-1535-POJ-1511-Invitation-Cards/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>1~n个城市m条单向路，求从1到各城市最短路之和与各城市到1最短路之和，两者的和</p><p>求第二者只需反向建边</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1535" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000005;const int INF = 0x3f3f3f3f;struct node{    int from, to, w, pre;}a[N];int head[N], dis[N], b[N], c[N], d[N], tot, sum, n, m, cnt;bool vis[N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = INF, head[i] = -1, vis[i] = 0;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void spfa(int start){    deque&lt;int&gt; q;    dis[start] = 0;    q.push_front(start);    vis[start] = 1;    tot = 1;    sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                }            }        }    }}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        long long ans = 0;        init();        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;b[i], &amp;c[i], &amp;d[i]);            add(b[i], c[i], d[i]);        }        spfa(1);        for(int i = 1; i &lt;= n; ++i)            ans += dis[i];        init();        for(int i = 0; i &lt; m; ++i)            add(c[i], b[i], d[i]);        spfa(1);        for(int i = 1; i &lt;= n; ++i)            ans += dis[i];        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 字符串-列表-元组-字典</title>
      <link href="2019/04/27/python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%97%E8%A1%A8-%E5%85%83%E7%BB%84-%E5%AD%97%E5%85%B8/"/>
      <url>2019/04/27/python-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%97%E8%A1%A8-%E5%85%83%E7%BB%84-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="python字符串"><a href="#python字符串" class="headerlink" title="python字符串"></a>python字符串</h3><blockquote><p>字符串是 Python 中最常用的数据类型。我们可以使用引号( ‘ 或 “ )来创建字符串。</p><p>Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用 </p></blockquote><a id="more"></a><h3 id="Code-of-string"><a href="#Code-of-string" class="headerlink" title="Code of string"></a>Code of string</h3><pre><code class="lang-python">import numpy as npvar1 = &#39;Apple&#39;print(var1)print(var1[0])                # 下标索引访问print(var1[2 : 4])            # 左闭右开式截取print(var1[ : 3] + &quot;pear&quot;)    # 截取加拼接# \转义字符print(&#39;\\&#39;)print(&#39;\a&#39;)                   # 响铃警告print(&#39;\&quot;&#39;)print( &#39;check&#39; +  &#39;\n&#39;)       # 换行（print自带一个）a = &#39;Perfect&#39;b = &#39;Nice&#39;print(a + b)                    # 连接print(a * 4)                    # 重复输出# if 语句没有括号，有冒号if &#39;P&#39; in a:                    # in 成员运算符    print(&quot;There is a P in a&quot;)else :    print(&quot;There is not a P in a&quot;)if &#39;P&#39; not in b:               # not in    print( &#39;p is not in b&#39;)else :    print(&#39;P is in b&#39;)print(r&#39;\n&#39; )                  # 原始字符串（中间不加空格）print(R&#39;\n&#39; )# %格式化输出print(&quot;My name is %s, and I&#39;m %d years old.&quot; % ( &#39;ZBL&#39;, 19 ))# 三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符c = &quot;&quot;&quot;字符串可以跨多行多行字符串可以使用制表符TAB ( \t )。也可以使用换行符 [ \n ]&quot;&quot;&quot;print(c)# python的字符串内建函数(略)</code></pre><h3 id="Python列表list"><a href="#Python列表list" class="headerlink" title="Python列表list"></a>Python列表list</h3><blockquote><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。</p><p>Python有6个序列的内置类型，但最常见的是<strong>列表</strong>和<strong>元组</strong>。</p><p>序列都可以进行的操作包括索引，切片，加，乘，检查成员。</p><p>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现 </p></blockquote><h3 id="Code-of-List"><a href="#Code-of-List" class="headerlink" title="Code of List"></a>Code of List</h3><pre><code class="lang-python">if __name__ == &#39;__main__&#39;:    d = np.array([1,2,3,4,5])    print(d[2:4])# 列表的数据项不需要具有相同的类型list1 = [ &#39;Fireworks&#39;, &#39;4444&#39;, &#39;!@#$%&#39;, &#39;123asd&#39; ]list2 = [ &#39;ABC123&#39;, &#39;LX521&#39;, &#39;!=!&#39;, &#39;qaq&#39; ]print(len(list1))             # 长度函数print(max(list1))             # 最值（even for the string）print(min(list1))print(list1[3])print(list2[1 : 3])list1[3] = &#39;MYL&#39;              # 直接更新数据print(list1[3])print(list1)                  # 输出整个列表del list1[1]                  # 删除列表元素print(list1)print(list1 + list2)print(list2 * 2)print(&#39;Fireworks&#39; in list1)for x in [1, 2, 3]: print(x, end = &#39; &#39;)L = [ &#39;LOVE&#39;, &#39;Patience&#39;, &#39;Duty&#39; ]print(L[2])print(L[-2])                # Patienceprint(L[1 :])print(list1 + L)           # 日常拼接e = [list1, L]print(e)                   # 嵌套f = ( &quot;12345&quot;, &quot;SDNU&quot;, &#39;qwq&#39;, &#39;!*&amp;^%$#&#39; )print(f)print(list(f))            # 元组转列表# python 包含以下方法（略）&#39;&#39;&#39;list.append(obj)list.count(obj)list.extend(seq)list.index(obj)list.insert(index, obj)list.pop([index=-1])list.remove(obj)list.reverse()list.sort( key=None, reverse=False)list.clear()list.copy()&#39;&#39;&#39;</code></pre><h3 id="Python元组tuple"><a href="#Python元组tuple" class="headerlink" title="Python元组tuple"></a>Python元组tuple</h3><blockquote><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改。</p><p>元组使用小括号，列表使用方括号。</p></blockquote><h3 id="Code-of-tuple"><a href="#Code-of-tuple" class="headerlink" title="Code of tuple"></a>Code of tuple</h3><pre><code class="lang-python">tup1 = ( &#39;Beautiful&#39;, &#39;handsome&#39;, &#39;1999&#39;, &#39;2000&#39;)tup2 = &#39;bug&#39;, &#39;hug&#39;, &#39;embrace&#39;,    # without &#39;()&#39; is OK# 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用tup3 = (50)print( type(tup3) )                # &lt;class &#39;int&#39;&gt;tup4 = (50, )print( type(tup4) )                # &lt;class &#39;tuple&#39;&gt;# 下标访问、截取、不可修改但可以 + 连接 * 重复输出 in、 not in# 元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组print(tup1)del tup1# 内置函数&#39;&#39;&#39;len(tuple)max(tuple)min(tuple)tuple(seq) 列表转元组&#39;&#39;&#39;</code></pre><h3 id="Python字典Dict"><a href="#Python字典Dict" class="headerlink" title="Python字典Dict"></a>Python字典Dict</h3><blockquote><p>字典是另一种可变容器模型，且可存储任意类型对象。</p><p>字典的每个键值(key=&gt;value)对用冒号(<strong>:</strong>)分割，每个对之间用逗号(<strong>,</strong>)分割，整个字典包括在花括号<strong>{}</strong>中 </p><p>键必须是唯一的，但值则不必。</p><p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p></blockquote><h3 id="Code-of-Dict"><a href="#Code-of-Dict" class="headerlink" title="Code of Dict"></a>Code of Dict</h3><pre><code class="lang-python"># 像c++里的mapd1 = { &#39;ZBL&#39; : 100, &#39;ZRX&#39; : 101 }d2 = { &#39;abc&#39; : 44, 1000 : 10 }print(d1[&#39;ZBL&#39;])                    # 访问print(d2[1000])d1[20] = 9600690                   # 添加d2[&#39;QWQ&#39;] = &#39;邱达不溜秋&#39;d1[&#39;ZBL&#39;] = 59                     # 修改(更新)print(d1)print(d2)del d1[&#39;ZRX&#39;]                      # delete one elementprint(d1)d1.clear()                         # cleardel d1                             # delete the whole dict# 键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行tup5 = (&#39;1024&#39;, 1111, &#39;people&#39;)list5 = [ &#39;LX&#39;, 2048, &#39;nine days&#39; ]d5 = { tup5 : list5 }              # 元组作&#39;键&#39;，列表作&#39;值&#39;print( d5[tup5] )# 内置函数 len(dict) str(dict) type(variable)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python numpy库の矩阵、数列(等差、等比)</title>
      <link href="2019/04/25/Python-numpy%E5%BA%93%E3%81%AE%E7%9F%A9%E9%98%B5-%E6%95%B0%E5%88%97/"/>
      <url>2019/04/25/Python-numpy%E5%BA%93%E3%81%AE%E7%9F%A9%E9%98%B5-%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h3><blockquote><p>NumPy系统是Python的一种开源的数值计算扩展。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多（该结构也可以用来表示矩阵（matrix））。</p></blockquote><a id="more"></a><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote><p>一个用python实现的科学计算，包括：1、一个强大的N维数组对象Array；2、比较成熟的（广播）函数库；3、用于整合C/C++和Fortran代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数。numpy和稀疏矩阵运算包scipy配合使用更加方便。</p><p>NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库。专为进行严格的数字处理而产生。多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore，NASA用其处理一些本来使用C++，Fortran或Matlab等所做的任务。  </p></blockquote><h3 id="Code-of-practice"><a href="#Code-of-practice" class="headerlink" title="Code of practice"></a>Code of practice</h3><pre><code class="lang-python">import numpy as npimport datetime# 获取当前时间, 其中中包含了year, month, hour, 需要import datetimetoday = datetime.date.today()print(today)               # 2019-04-25print(today.year)          # 2019print(today.month)         # 4print(today.day)           # 25# 创建 ndarray 对象的函数，可以很方便的创建常用的或有规律的矩阵# arange 非 arrangea = np.arange(10)         # 默认从0开始到10（不包括10），步长为1print(a)                  # 返回 [0 1 2 3 4 5 6 7 8 9]b = np.arange(5, 10)      # 从5开始到10（不包括10），步长为1print(b)                  # 返回 [5 6 7 8 9]c = np.arange(6, 15, 3)   # 从6开始到15（不包括15），步长为3print(c)                  # 返回 [ 6, 9, 12]# linspace用于生成等差数列d = np.linspace(0, 10, 4) # 生成首位是0，末位是10，含4个数的等差数列print(d)                  # [ 0.          3.33333333  6.66666667 10.        ]# logspace用于生成等比数列e = np.logspace(0, 2, 5)  # 用于生成首位是100，末位是102，含5个数的等比数列print(e)                  # [  1.           3.16227766  10.          31.6227766  100.        ]f_one = np.ones((3, 4))    # 创建3*4的全1矩阵print(f_one)f_zero = np.zeros((3, 4))  # 创建3*4的全0矩阵print(f_zero)f_eye = np.eye(5)          # 创建5阶单位矩阵print(f_eye)f_empty = np.empty((2, 3)) # 创建2*3的空矩阵print(f_empty)# [[1.26785536e-311 1.26784911e-311 1.26784911e-311]#  [4.83245960e+276 3.09394663e+169 9.08367217e+223]]# 手动创建矩阵时注意[ [ 的数量 ] ]g = np.array([[1, 2, 3], [4, 5, 6]])h = np.array([[2, 3, 4], [5, 6, 7]])# 都是对矩阵对应元素间的运算print(g + h)print(g - h)print(g * h)print(g / h)print(g % h)print(g ** 2)# 对矩阵a中每个元素取正弦,sin(x) 还有其他的函数print( np.sin(g) )# 矩阵中的元素不在定义域范围内，会产生RuntimeWarning，结果为nan(not a number)# 矩阵乘法（点乘）dot函数j = np.array([ [1, 2, 3], [4, 5, 6] ])k = np.array([ [1, 2], [3, 4], [5, 6] ])print(j.shape[1]) # 获得行数print(k.shape[0]) # 获得列数print(j.shape[1] == k.shape[0])print(j.dot(k))# 矩阵的转置 j.transpose()   j.Tprint(j.transpose())print(j.T)# 矩阵的逆m = np.array([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) # 理论上只有方阵可求逆print(np.linalg.inv(m))print(&#39;Check&#39;)# 矩阵最值，另有均值、方差、标准差、中值、求和、累积和print(m.max()) # 矩阵最大值print(m.min())print(m.max(axis = 0)) # 每行的最大值print(m.max(axis = 1)) # 每列的最大值print(m.min(axis = 0))print(m.min(axis = 1))print(m.argmax()) # 最大值所在位置print(m.argmin())print(m.argmax(axis = 0))print(m.argmax(axis = 1))print(m.argmin(axis = 0))print(m.argmin(axis = 1))</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3259 Wormholes</title>
      <link href="2019/04/24/POJ-3259-Wormholes/"/>
      <url>2019/04/24/POJ-3259-Wormholes/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>农夫有T个农场，对应T组测试样例</p><p>每个农场有N块地，M条双向路，W条单向负权路（原文指走这条路时光回到之前）</p><p>问是否存在负权回路</p></blockquote><a id="more"></a><p><strong><a href="http://poj.org/problem?id=3259" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford"></a>Bellman_Ford</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10005;///数组3005都算开小了...const int INF = 0x3f3f3f3f;struct node{    int from, to, w;}a[N];int n, m, w, cnt, dis[N];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    cnt++;}bool Bellman_Ford(int start){    dis[start] = 0;    int tot = n;    while(tot--)    {        bool flag = 0;        for(int i = 0; i &lt; cnt; ++i)        {            if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            {                flag = 1;                dis[ a[i].to ] = dis[ a[i].from ] + a[i].w;            }        }        if(flag == 0)            break;    }    for(int i = 0; i &lt; cnt; ++i)        if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)        return 0;    return 1;}int main(){    int t, there, here, val;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        memset(dis, INF, sizeof(INF));        cnt = 0;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;there, &amp;here, &amp;val);            add(there, here, val);            add(here, there, val);        }        for(int i = 0; i &lt; w; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;there, &amp;here, &amp;val);            add(there, here, -val);        }        bool ans = 0;        for(int i = 1; i &lt;= n; ++i)            if(Bellman_Ford(i) == 0)            {                ans = 1;                break;            }        if(ans)            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, m, w;int mp[510][510];void floyd(){    bool flag = 0;    for(int k = 1; k &lt;= n; ++k)/// 又写成了 ++i    {        for(int i = 1; i &lt;= n; ++i)        {            for(int j = 1; j &lt;= n; ++j)            {                if(mp[i][j] &gt; mp[i][k] + mp[k][j])                    mp[i][j] = mp[i][k] + mp[k][j];    ///本想用下面这句话提前结束循环    ///后来发现这句话本身的耗时多于提前终结所省的时间//                if(i == j &amp;&amp; mp[i][j] &lt; 0//                {//                    flag = 1;//                    break;//                }            }//            if(flag)//                break;            if(mp[i][i] &lt; 0)            {                flag = 1;                break;            }        }        if(flag)            break;    }    if(flag)        cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;    else        cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;}int main(){    int t, there, here, val;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;w);        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                mp[i][j] = (i == j ? 0 : INF);        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;there, &amp;here, &amp;val);            if(mp[there][here] &gt; val)                mp[there][here] = mp[here][there] = val;        }        for(int i = 0; i &lt; w; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;there, &amp;here, &amp;val);            mp[there][here] = -val;        }        floyd();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のBellman-Ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经验总结</title>
      <link href="2019/04/23/A%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
      <url>2019/04/23/A%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="做题经验总结"><a href="#做题经验总结" class="headerlink" title="做题经验总结"></a>做题经验总结</h3><blockquote><p>算法竞赛对其参与者的要求：</p><p>具备较强的问题抽象和建模能力，能实现对复杂实际问题的模拟求解</p></blockquote><a id="more"></a><blockquote><p><strong>迎难而上，方能成长。念念不忘，必有回响！</strong></p><p>-58.好多题数据n上限都是1e9(10亿，int上限21亿)，今天遇到这样一题，一直WA，后来发现我有个3 * n的操作!!!</p><p>-57.有些样例(像是codeforces上的)不怀好意，故意引导人按照一种错误的思路去考虑，从而WA.</p><p>-56.我才发现，二进制运算 | &amp; ，在状态压缩中，0代表无，1代表有，此时 | 对应取并集∪， &amp; 对应取交集∩.</p><p>-55.阶乘取模，很可能从某项开始就是0了!</p><p>-54.从n到1不好算，试试反着来，从1到n。</p><p>-53.有乘有除的double运算坚持先除后乘，免超longlong!痛死</p><p>-52.不要自我感觉不会超int，就一个ans能开long long就开呗！</p><p>-51.多者选其一的贪心可简化为二者选其一，多测试几个”二者选其一“哪个更优，得出贪心方案</p><p>-50.猜出可能是贪心，可不明确贪心方案时，举一个简单的例子(&gt;=3)，手动枚举出所有方案，看哪个方案最优，猜测那就是正解</p><p>-49.当你确定思绪乱了的时候，敢于重新整理思路重新写</p><p>-48.题目叙述较长时，第一段多为题目背景，可忽略，若读完其他段有疑问可去读一下</p><p>-47.写了init函数，主函数里没调用就交上了……</p><p>-46.PE：Print a blank line after each test case. </p><p>-45.我就是个傻*，多次将i写成1</p><p>-44.T多(&gt;=1000测试组数)想想预处理</p><p>-43.注意输出格式”Case # 1: “，大多数人做题时不管这个，只注重算法是否正确，当时间一长或思路正确而感到激动，往往忘掉了输出格式，多罚时20min</p><p>-42.较短的数字串可以当做数字处理</p><p>-41.输入(Input)可能有<strong>重复</strong>的内容</p><p>-40.代码能过样例和极限边界值却不能AC：去Discuss区看看</p><p>-39.special judge的题<strong>抓住刺眼、奇怪的特点</strong>去思考</p><p>-38.但凡有点思路就跟队友提出来，即使没有最终方案，也可以启发队友想出新策略</p><p>-37.遇到段错误（Segmentation Fault 、RE）而又不知该如何修改时，可以试试用map代替数组</p><p>-36.不要一遇到问题立刻转为数学题，有些是有<strong>实际意义</strong>的！比如你赌博（不可赊欠的那种），前四天每天输一元，后三天每天赢一元，你以为最开始只需一元的本金吗？天真…找到<strong>过程最低谷！（—++过程中最负的值即为一开始必须要有的值！）</strong> 实际问题相对于数学模型的最大特点是：<strong>不赊欠</strong></p><p>-35.有时候除法能改为乘法(如：两比值比较大小)，从而避免了卡精度问题</p><p>-34.手推出一般规律后，拿‘5’验证一下，有时候‘4’都不一定可靠</p><p>-33.在涉及取模的题目里，任何一步加法运算都要注意取模（特别是在特殊处理、结尾处理的时候）</p><p>-32.有时候初始化的值对应答案！所以慎重初始化，并检测初始化值作为答案是否符合题意！</p><p>-31.用输入挂前若需<code>getchar()</code>一定加上，不加可WA</p><p>-30.<code>int n; scanf(&quot;%d&quot;, n);</code>   漏了 &amp; 编译器不报错</p><p>-29.平日做题遇到想不通的地方暂且搁置或问一下别人，相信阿基米德与酝酿效应，硬刚浪费时间还伤身</p><p>-28.条件判断时 &gt;= 别漏了 ‘=’</p><p>-27.对于int型奇数n来说，n / 2 <em> 4   !=   n </em> 2</p><p>-26.有些乍一看很不可思议、无从下手的题往往过于简单，用最简单的0、1、2带入’暴力赋值法’（选择填空必胜法宝），这样的题要大胆猜想、敢于尝试</p><p>-25.二分的l、r改变条件要写的简洁（那才是真的懂二分）</p><p>-24.凡是暴力遍历超时的，都可以想想二分优化（l、r的改变写好，否则易死循环）</p><p>-23.做题遇到从文件读入…freopen(“input.txt”,”r”,stdin); freopen(“output.txt”,”w”,stdout);</p><p>-22.平时1e4的期望内存开大十倍就行（除非内存限制很小）</p><p>-21.上下两个边界都要试一下</p><p>-20.程序简单取模复杂用JAVA</p><p>-19.有些题目看上去很复杂，实则是在掩盖它本身很简单这一事实，为了达到这一目的，它给的提示往往是去误导你，误导你把问题想复杂些</p><p>-18.T组测试数据，当T&gt;100以至于1e5时，考虑<strong>预处理</strong></p><p>-17.i、j、k下标密集区，下标看清楚写的是不是自己想要的</p><p>-16.有想法先跟队友商量一下，确保可行后试敲</p><p>-15.很多题有T组测试数据，样例输入却只一组，自己检查每组进行前是否各值已初始化！</p><p>-14.运行除法时 / 考虑分母是否可能为0，否则运行出错RE</p><p>-13.敢于读题（即使面对一篇冗长的阅读理解，有时不必全弄明白）</p><p>-12.数组开小了，非法访问未知地址的内容会TLE！</p><p>-11.数据量大时，强行用较高精度代替较低精度输入会TLE！</p><p>-10.无 结果输出 又没有 程序结束提示 ：大概是死循环</p><p>-9.debug要有!针对性！抓要点！不盲目地改，效率低！</p><p>-8.if并列关系要列的清楚明白、层次分明，不要乱if</p><p>-7.输入一个数字，程序没运行直接返回一个异样的负值，很可能你的    scanf没有&amp;</p><p>-6.当变量设置较多时，适当注释。</p><p>-5.数组开的大又不止一个会溢出，不等你输入直接结束程序</p><p>-4.特殊样例：逆序输入、重复输入、0、+1、-1        !边界值!</p><p>-3.思路清晰，写在纸上，可减少出错</p><p>-2.注意是非负整数（包括0）还是正整数</p><p>-1.在wrong answer与presentation error同时存在时可能先报presentation answer!</p><p>0.sacnf(“%lld”,a[i])没有“&amp;”不报错但！</p><p>1.Time limit Exceeded(超时）缺少 !=EOF</p><p>2.数组适当开大一点，题目数据小的话开大10倍</p><p>3.细心！p!=np(输入p与n而非np).</p><p>4.分类讨论时  注意对应、对称性！</p><p>5.if（a==0）两个=         if（a[i] == a[j])让这个==害惨了</p><p>6.赋值 temp==a[i]    无语……</p><p>7.原来循环中可以计算a【i】有多少被赋值（循环中计数）</p><p>8.不能只想，要一边想一边写，成功几率更大</p><p>9.特殊样例：注意0与负数与常数列的输入检测.(某些值结果若是0等特殊数字）</p><p>10.英文注意Multiple test cases. </p><p>11.有错误可用手机检查一下？</p><p>12.花样自造输入样例.</p><p>13.鼠标拖动选中Sample Output测试末尾有无空格</p><p>14.输入一个数字就对Ta操作，可不开数组，或许省内存、思路更清晰，但耗时间?</p><p>15.int 比 long long 省空间还省时；尽量不用endl因为耗时！</p><p>16.if(flag) 这里flag即使为负值也被算作1，if只能判0与非0</p><p>17.当你知道某题用到的知识点是你没学过的，那就直接去看题解，学会这个点，A过这道题，不要犹豫，这是应该的</p></blockquote><h3 id="英语单词学习（ACM相关）"><a href="#英语单词学习（ACM相关）" class="headerlink" title="英语单词学习（ACM相关）"></a>英语单词学习（ACM相关）</h3><blockquote><p><strong>有时候不愿刷题真的是因为题面是一大片英文……就跟饭菜不合胃口似的，想吃点又吃不下……</strong></p><p><strong>学以致用</strong>才是真正学到了。单词学完了用到句子里、文章里；数据结构、算法学完了用它去解题；函数、库学完了用它去做一两个简单的项目，这样才能记住些东西。</p><p>如果你学习一个知识点不去实践、应用，根本记不了一两天，还不如不去浪费那个时间！</p><ol><li>bidirectional     /,baɪdə’rɛkʃənl/         双向的   example: a bidirectional path</li><li>adjacent           /ə’dʒesnt/                  相邻的</li><li>respectively      /rɪ’spɛktɪvli/              分别的   </li><li>radius                [‘redɪəs]                    半径，半径范围 </li><li>contiguous        [kən’tɪɡjuəs]            连续的；邻近的；接触的 </li><li>horizontal          [hɒrɪ’zɒnt(ə)l]          水平的、水平线，水平面；水平位置 </li><li>lexicographic     [,lɛksɪkə’græfɪk]      字典的；字典编纂的 </li><li>troop                  [truːp]                       军队；组；群；多数 </li><li>pasture              [‘pɑːstʃə]                   牧场；草原  吃草  放牧 </li><li>quadrant            [‘kwɒdr(ə)nt]           象限、四分之一圆 </li><li>decimal              [‘desɪm(ə)l]               十进位的，小数的 </li><li>lexicographically  [ˌleksɪkəˈɡræfɪklɪ]  按字典序</li><li>boundary          [‘baʊnd(ə)rɪ]                边界；分界线</li><li>indices                 [‘ɪndɪsiːz]                  指数；目录（index的复数）</li><li>scenarios            [sɪ’nɛrɪ,o]                  情节；情况 （≈cases）</li><li>decimal              [‘desɪm(ə)l]                <strong>十进制的</strong>、小数的；小数</li><li>rational             [‘ræʃ(ə)n(ə)l]                合理的，有理数(rational number)</li><li>finite                   [‘faɪnaɪt]                      有限的</li><li>invalid          [ˈɪnvəlɪd; ɪnˈvælɪd]          无效的、病弱残的</li><li>syntax                   [‘sɪntæks]                     句法</li><li>Trajan                   [‘treidʒən] </li><li>identical               [aɪ’dentɪk(ə)l]           完全同样的，相同的；恒等的 </li><li>specification      [,spesɪfɪ’keɪʃ(ə)n]        规格；说明书；详述 </li><li>performance     [pə’fɔːm(ə)ns]            性能；绩效 </li><li>diameter              [daɪ’æmɪtə]               直径</li><li>radius                  [‘reɪdɪəs]                       半径</li><li>precisely              [prɪ’saɪslɪ]                  精确地</li><li>arbitrarily             [,ɑrbə’trɛrəli]               任意地 </li><li>cryptography       [krɪp’tɒgrəfɪ]              密码学</li><li>diagonal              [daɪ’æg(ə)n(ə)l]            斜的，对角线的</li><li>overlap                 [.əʊvə(r)’læp]             交叠、重叠</li><li>unidirectional      [,juːnɪdɪ’rekʃ(ə)n(ə)l]   单向的    (对比undirected无向的)</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="2019/04/22/KMP/"/>
      <url>2019/04/22/KMP/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><blockquote><p>KMP算法要解决的问题就是在字符串（也叫主串）中的模式（pattern）定位问题。说简单点就是我们平时常说的关键字搜索。模式串就是关键字，如果它在一个主串中出现，就返回它的具体位置，否则返回-1（常用手段）。 </p></blockquote><a id="more"></a><h3 id="Code-of-KMP-count"><a href="#Code-of-KMP-count" class="headerlink" title="Code of KMP count"></a>Code of KMP count</h3><pre><code class="lang-c++">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 1000100;char m[maxn], n[maxn];int nex[maxn];///next[j]的值（也就是k）表示，当P[j] != T[i]时，j指针的下一步移动位置void getne(char * str, int len){    int i = 0, j = -1;    nex[0] = -1;    while(i &lt; len)    {        if (j == -1 || str[i] == str[j])            nex[++i] = ++j;        else            j = nex[j];    }}int kmp(char * a, char * b, int lena, int lenb){    int sum = 0;    int i = 0, j = 0;    while(i &lt; lena &amp;&amp; j &lt; lenb)    {        ///当j为-1时,要移动的是i,当然j也要归0        if (j == -1 || a[i] == b[j])            ++j, ++i;        else            j = nex[j];        if(j == lenb)        {            sum++;            ///i--;会TLE            j = nex[j];        }    }    return sum;}int main(){    scanf(&quot;%s&quot;, n);///子串    scanf(&quot;%s&quot;, m);///主串    int a = strlen(n), b = strlen(m);    getne(n, a);    printf(&quot;%d\n&quot;, kmp(m, n, b, a));}</code></pre><p><strong><a href="https://www.cnblogs.com/yjiyjige/p/3263858.html" style="color:violet;" target="_blank" rel="noopener">参考1</a></strong></p><p><strong><a href="https://blog.csdn.net/v_july_v/article/details/7041827" style="color:violet;" target="_blank" rel="noopener">参考2</a></strong></p><p><strong><a href="http://www.cnblogs.com/mfryf/archive/2012/08/15/2639565.html" style="color:violet;" target="_blank" rel="noopener">参考3</a></strong></p><p><strong><a href="http://www.ituring.com.cn/article/59881" style="color:violet;" target="_blank" rel="noopener">参考4</a></strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 字符串のKMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD与LCM</title>
      <link href="2019/04/22/GCD%E4%B8%8ELCM/"/>
      <url>2019/04/22/GCD%E4%B8%8ELCM/</url>
      
        <content type="html"><![CDATA[<h3 id="UVA-11827"><a href="#UVA-11827" class="headerlink" title="UVA 11827"></a>UVA 11827</h3><blockquote><p>找任意两个数的最大公因数中最大的那个</p><p>此题难在输入</p></blockquote><a id="more"></a><p><strong><a href="https://vjudge.net/problem/UVA-11827" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define ll long longint gcd(int a, int b){    return b == 0 ? a : gcd(b, a % b);}int lcm(int a, int b){    return (a / gcd(a, b) * b);}int main(){    int t, n, ans = 0, a[105], cnt = 0;    cin &gt;&gt; t;    getchar();    while(t--)    {        cnt = 0, ans = 0;        string s, tem;        getline(cin, s);        stringstream ss(s);        while(ss &gt;&gt; tem)            a[cnt++] = atoi(tem.c_str());        for(int i = 0; i &lt; cnt; ++i)            for(int j = i + 1; j &lt; cnt; ++j)                if(gcd(a[i], a[j]) &gt; ans)                    ans = gcd(a[i], a[j]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="还可用ungetc"><a href="#还可用ungetc" class="headerlink" title="还可用ungetc"></a>还可用ungetc</h3><p><strong><a href="https://baike.so.com/doc/175028-184922.html" style="color:violet;" target="_blank" rel="noopener">ungetc百科</a></strong></p><p><img src="https://i.loli.net/2019/04/22/5cbd9ece421e4.png" alt="ungetc"></p><h2 id="异或写的gcd"><a href="#异或写的gcd" class="headerlink" title="异或写的gcd"></a>异或写的gcd</h2><pre><code class="lang-c++">ll GCD(ll a, ll b){    while(b ^= a ^= b ^= a %= b);    return a;}</code></pre><blockquote><p>世界之大无奇不有……</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论のGCD与LCM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据转换</title>
      <link href="2019/04/22/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/"/>
      <url>2019/04/22/%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="数据之间的转换"><a href="#数据之间的转换" class="headerlink" title="数据之间的转换"></a>数据之间的转换</h3><blockquote><p>字符数组转：</p><ol><li>int ： atoi (char * ch)</li><li>long : atol (char * ch)</li><li>float : atof (char * ch)</li></ol></blockquote><a id="more"></a><blockquote><p>字符数组转：</p><ol><li><p>float : strtof (char * ch, NULL)</p></li><li><p>double : strtod(char * ch, NULL)</p></li><li><p>long: strtol(char * ch, NULL, int base)</p></li><li><p>unsigned long: strtoul(char * ch, NULL, int base)</p><p>base &gt;= 2 &amp;&amp; base &lt;= 36</p><p>3、4将字符串视为base进制转为十进制，堪比java进制转换</p></li></ol></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;int main(){    string s;    cin &gt;&gt; s;    cout &lt;&lt; atoi(s.c_str()) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; atol(s.c_str()) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; atof(s.c_str()) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; strtof(s.c_str(), NULL) &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; strtod(s.c_str(), NULL) &lt;&lt; &#39;\n&#39;;    ///top :  2147483647 = 7fffffff    cout &lt;&lt; strtol(s.c_str(), NULL, 16) &lt;&lt; &#39;\n&#39;;    ///top : 4294967295 = ffffffff    cout &lt;&lt; strtoul(s.c_str(), NULL, 16) &lt;&lt; &#39;\n&#39;;    ///char [] -&gt; string : copy    char a[] = &quot;123456&quot;;    string b(a);    cout &lt;&lt; b &lt;&lt; &#39;\n&#39;;    ///string -&gt; char [] : ch.c_str()    string ch = &quot;987654&quot;;    cout &lt;&lt; ch.c_str() &lt;&lt; &#39;\n&#39;;}</code></pre><blockquote><p>string转char * s:</p></blockquote><pre><code class="lang-c++">char c[20];string s = &quot;1234&quot;;strcpy(c, s.c_str());</code></pre><blockquote><p>暂存一段cin关闭同步<code>#define quick_cin ios::sync_with_stdio(false);</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python a + b</title>
      <link href="2019/04/22/Python-a-b/"/>
      <url>2019/04/22/Python-a-b/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简单a-b"><a href="#1-简单a-b" class="headerlink" title="1.简单a+b"></a>1.简单a+b</h3><pre><code class="lang-python">a, b = input().split()a, b = int(a), int(b)print(a + b)</code></pre><a id="more"></a><h3 id="2-读到文末-EOF-a-b"><a href="#2-读到文末-EOF-a-b" class="headerlink" title="2.读到文末(EOF)a+b"></a>2.读到文末(EOF)a+b</h3><pre><code class="lang-python">while True:    try:        a, b = input().split()        a, b = int(a), int(b)        print(a + b)    except EOFError:        break</code></pre><h3 id="3-T组数据a-b"><a href="#3-T组数据a-b" class="headerlink" title="3.T组数据a+b"></a>3.T组数据a+b</h3><pre><code class="lang-python">t = input() #different?t = int(t)for case in range(t):    a, b = input().split()    a, b = int(a), int(b)    print(a + b)</code></pre><h3 id="4-特殊数据停止a-b"><a href="#4-特殊数据停止a-b" class="headerlink" title="4.特殊数据停止a+b"></a>4.特殊数据停止a+b</h3><pre><code class="lang-python">while True:    a, b = input().split()    a, b = int(a), int(b)    if a == 0 and b == 0:  #There is a &#39;:&#39;         break    print (a + b)</code></pre><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><pre><code class="lang-python">import keyword # 导入相应的模块# 空行也是程序代码的一部分print(keyword.kwlist)  # keyword 模块，可以输出当前版本的所有关键字# Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。print(&quot;你好，世界！&quot;)  # Python3 源码文件默认使用utf-8编码中国 = &#39;china&#39;  # Python 3 中，非 ASCII 标识符也是允许的了print(中国)美国 = &quot;America&quot;  # 单引号和双引号使用完全相同print(美国)print(&#39;python3&#39;, end = &quot; &quot;) # 要实现不换行需要在变量末尾加上 end=&quot;something&quot;print(&quot;柳絮&quot;); print(&quot;Fireworks&quot;) # Python可以在同一行中使用多条语句，语句之间使用分号(;)分割# 变量不需要声明,每个变量在使用前都必须赋值a = 100a = 1.0a = &quot;我&quot; # 变量就是变量，它没有类型，我们所说的&quot;类型&quot;是变量所指的内存中对象的类型print(a)# 多个对象指定多个变量b , c, d = 4, 3.14, &quot;Yes&quot;print(b , end = &quot; &quot;)print(c , end = &quot; &quot;)print(d)print(5 + 4)print(3.14 - 2) # 减法 1.1400000000000001print(2.5 * 4)print(2 ** 4) # 乘方print(2 / 4) # 除法，得到一个浮点数0.5print(2 // 4)print(4 % 3)</code></pre><h1 id="split-函数"><a href="#split-函数" class="headerlink" title="split()函数"></a>split()函数</h1><blockquote><p>split翻译为分裂。  split()就是将一个字符串分裂成多个字符串组成的列表。</p><p>split()当不带参数时以空格进行分割，当代参数时，以该参数进行分割。</p><p>详解： <a href="https://www.cnblogs.com/douzi2/p/5579651.html" target="_blank" rel="noopener">https://www.cnblogs.com/douzi2/p/5579651.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 其他语言のPython </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="2019/04/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>2019/04/21/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote><p>在计算机科学中，最长的回文子串或最长的对称因子问题是找到给定字符串的最大长度连续子串的问题，该字符串也是回文。</p><p>例如，“香蕉”的最长回文子串是“anana”。 最长的回文子串不保证是唯一的; 例如，在字符串“abracadabra”中，没有长度大于3的回文子串，但是有两个长度为3的回文子串，即“aca”和“ada”。 在某些应用程序中，可能需要返回所有最大回文子串（即，所有子串本身是回文并且不能扩展到更大的回文子串），而不是仅返回一个子串或返回回文子串的最大长度。   </p></blockquote><a id="more"></a><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><pre><code class="lang-c++">int Manacher(string s){    string t = &quot; #&quot;;///two chars    int sz = s.size();    for(int i = 0; i &lt; sz; ++i)    {        t += s[i];        t += &quot;#&quot;;    }    sz = t.size();    vector&lt;int&gt; vec(sz, 0);    int mmax = 0, pos = 0, len = 0, center = 0;    for(int i = 1; i &lt; sz; ++i)///start from 1    {        vec[i] = mmax &gt; i ? min(vec[2 * pos - i], mmax - i) : 1;        while( t[ i + vec[i] ] == t[ i - vec[i] ] )            ++vec[i];        if (mmax &lt; i + vec[i])        {            mmax = i + vec[i];            pos = i;        }        if (len &lt; vec[i])        {            len = vec[i];            center = i;        }    }    cout &lt;&lt; s.substr( (center - len) / 2, len - 1) &lt;&lt; &#39;\n&#39;;    return len - 1;}</code></pre><p><strong><a href="https://www.cnblogs.com/grandyang/p/4475985.html" style="color:violet;" target="_blank" rel="noopener">原文链接</a></strong>  </p><h3 id="HDU-3038-最长回文"><a href="#HDU-3038-最长回文" class="headerlink" title="HDU 3038 最长回文"></a>HDU 3038 最长回文</h3><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3068" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><p><strong>Code</strong></p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int Manacher(string s){    string t = &quot; #&quot;;    int sz = s.size();    for(int i = 0; i &lt; sz; ++i)    {        t += s[i];        t += &quot;#&quot;;    }    sz = t.size();    vector&lt;int&gt; vec(sz, 0);    int mmax = 0, pos = 0, len = 0, center = 0;    for(int i = 1; i &lt; sz; ++i)    {        vec[i] = mmax &gt; i ? min(vec[2 * pos - i], mmax - i) : 1;        while( t[ i + vec[i] ] == t[ i - vec[i] ] )            ++vec[i];        if (mmax &lt; i + vec[i])        {            mmax = i + vec[i];            pos = i;        }        if (len &lt; vec[i])        {            len = vec[i];            center = i;        }    }//    cout &lt;&lt; s.substr( (center - len) / 2, len - 1) &lt;&lt; &#39;\n&#39;;    return len - 1;}int main(){    string s;    int cnt = 1;    while(cin &gt;&gt; s)    {        cout &lt;&lt; Manacher(s) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="POJ-3974-Palindrome"><a href="#POJ-3974-Palindrome" class="headerlink" title="POJ 3974 Palindrome"></a>POJ 3974 Palindrome</h3><p><strong><a href="http://poj.org/problem?id=3974" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int Manacher(string s){    string t = &quot; #&quot;;    int sz = s.size();    for(int i = 0; i &lt; sz; ++i)    {        t += s[i];        t += &quot;#&quot;;    }    sz = t.size();    vector&lt;int&gt; vec(sz, 0);    int mmax = 0, pos = 0, len = 0, center = 0;    for(int i = 1; i &lt; sz; ++i)///从1开始    {        vec[i] = mmax &gt; i ? min(vec[2 * pos - i], mmax - i) : 1;        while( t[ i + vec[i] ] == t[ i - vec[i] ] )            ++vec[i];        if (mmax &lt; i + vec[i])        {            mmax = i + vec[i];            pos = i;        }        if (len &lt; vec[i])        {            len = vec[i];            center = i;        }    }//    cout &lt;&lt; s.substr( (center - len) / 2, len - 1) &lt;&lt; &#39;\n&#39;;    return len - 1;}int main(){    string s;    int cnt = 1;    while(cin &gt;&gt; s)    {        if(s == &quot;END&quot;)            break;        cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt++ &lt;&lt; &quot;: &quot; ;        cout &lt;&lt; Manacher(s) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 字符串の最长回文子串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019中山大学程序设计竞赛</title>
      <link href="2019/04/19/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/"/>
      <url>2019/04/19/2019%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="1002Triangle"><a href="#1002Triangle" class="headerlink" title="1002Triangle"></a>1002Triangle</h2><blockquote><p>给出n个int内的数字，是否有三个数字能作为三角形的三条边</p><p>只是n可能到五百万</p></blockquote><a id="more"></a><h3 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h3><blockquote><p>想一下极限（就是组不成三角形）：1， 2， 3， 5， 8， 13， 21……</p><p>是一个斐波那契数列，然后陷入僵局……然后云龙说斐波那契数列很容易超int，</p><p>试了一下，f[46]就超int了……</p><p>队友给力!!!</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>接受输入后，若n&gt;=50(其实n &gt;= 46就行)，直接输出“YES”，否则排序当水题做</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 0x3f3f3f3f;int a[5000005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        int cnt = 0;        while(n--)            scanf(&quot;%d&quot;, &amp;a[cnt++]);        if(cnt &gt;= 50)        {            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;            continue;        }        sort(a, a + cnt);        bool ans = 0;        for(int i = 0; i + 2 &lt; cnt; ++i)            if(a[i] &gt; a[i + 2] - a[i + 1])            {                ans = 1;                break;            }        if(ans)            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>原来用了输入挂，发现<code>while(n--)</code>后应该加一个<code>getchar()</code>才能去读</p></blockquote><h2 id="1005-Coding-Problem（水题）"><a href="#1005-Coding-Problem（水题）" class="headerlink" title="1005 Coding Problem（水题）"></a>1005 Coding Problem（水题）</h2><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 0x3f3f3f3f;string ten_two(int a){    string s;    while(a)    {        s += (a % 2 + &#39;0&#39;);        a /= 2;    }    while(s.length() &lt; 8)        s += &#39;0&#39;;    return s;}int two_ten(string s){    reverse(s.begin(), s.end());    int sz = s.length();    int ans = 0;    for(int i = 0; i &lt; sz; ++i)        ans += (int)pow(2, i) * (s[i] - &#39;0&#39;);    return ans;}int main(){    string s, ans;    cin &gt;&gt; s;    int sz = s.length();    for(int i = 0; i &lt; sz; ++i)        ans += ten_two(int(s[i]));    sz = ans.length();    for(int i = 0; i + 5 &lt; sz; i += 6)        {            s.clear();            s += ans[i] ;            s += ans[i + 1];            s += ans[i + 2];            s += ans[i + 3];            s += ans[i + 4];            s += ans[i + 5];            cout &lt;&lt; two_ten(s) &lt;&lt; &#39; &#39;;        }    return 0;}</code></pre><h2 id="1008-Clumsy-Keke"><a href="#1008-Clumsy-Keke" class="headerlink" title="1008 Clumsy Keke"></a>1008 Clumsy Keke</h2><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool vis1[105][105][105];bool vis2[105][105][105];bool vis3[105][105][105];int main(){    int a, b, c, t;    while(~scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c))    {        for(int i = 1; i &lt;= a; ++i)            for(int j = 1; j &lt;= b; ++j)                for(int k = 1; k &lt;= c; ++k)                {                    vis1[i][j][k] = 0;                    vis2[i][j][k] = 0;                    vis3[i][j][k] = 0;                }        for(int i = 1; i &lt;= a; ++i)            for(int j = 1; j &lt;= b; ++j)            {                scanf(&quot;%d&quot;, &amp;t);                if(t == 1)                    for(int k = 1; k &lt;= c; ++k)                        vis1[i][j][k] = 1;            }        for(int i = 1; i &lt;= b; ++i)            for(int j = 1; j &lt;= c; ++j)            {                scanf(&quot;%d&quot;, &amp;t);                if(t == 1)                    for(int k = 1; k &lt;= a; ++k)                        vis2[k][i][j] = 1;            }        for(int i = 1; i &lt;= c; ++i)            for(int j = 1; j &lt;= a; ++j)            {                scanf(&quot;%d&quot;, &amp;t);                if(t == 1)                    for(int k = 1; k &lt;= b; ++k)                        vis3[j][k][i] = 1;            }        int ans = 0;        for(int i = 1; i &lt;= a; ++i)            for(int j = 1; j &lt;= b; ++j)                for(int k = 1; k &lt;= c; ++k)                    if(vis1[i][j][k] &amp;&amp; vis2[i][j][k] &amp;&amp; vis3[i][j][k])                        ans++;        cout &lt;&lt;ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h2 id="1009-Enlarge-it（签到题）"><a href="#1009-Enlarge-it（签到题）" class="headerlink" title="1009 Enlarge it（签到题）"></a>1009 Enlarge it（签到题）</h2><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 0x3f3f3f3f;string s[105];int main(){    int n, m, k;    while(~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k))    {        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)        {            for(int q = 0; q &lt; k; ++q)            {                for(int j = 0; j &lt; m; ++j)                {                    for(int p = 0; p &lt; k; ++p)                        cout &lt;&lt; s[i][j];                }                cout &lt;&lt; &#39;\n&#39;;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2533 Longest Ordered Subsequence</title>
      <link href="2019/04/18/POJ-2533-Longest-Ordered-Subsequence/"/>
      <url>2019/04/18/POJ-2533-Longest-Ordered-Subsequence/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>最长上升子序列（模板）</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1356925142&auto=1&height=66"></iframe><h3 id="O-n-n"><a href="#O-n-n" class="headerlink" title="O(n * n)"></a>O(n * n)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[10005];int dp[10005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d&quot;, &amp;a[i]);        int ans = 0;        for(int i = 0; i &lt; n; ++i)        {            dp[i] = 1;            for(int j = 0; j &lt; i; ++j)            {                if(a[j] &lt; a[i])                    dp[i] = max(dp[i], dp[j] + 1);            }            ans = max(ans, dp[i]);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="O-n-logn-不能记录路径"><a href="#O-n-logn-不能记录路径" class="headerlink" title="O(n * logn) 不能记录路径"></a>O(n * logn) 不能记录路径</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int a[10005];int low[10005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {   ///这个算法里数组尽量从1开始存        for(int i = 1; i &lt;= n; ++i)            {                scanf(&quot;%d&quot;, &amp;a[i]);                low[i] = INF;            }        int ans = 1;        low[ans] = a[1];        for(int i = 2; i &lt;= n; ++i)        {            if(a[i] &gt; low[ans])                low[++ans] = a[i];            else            {                int pos = lower_bound(low, low + ans, a[i]) - low;                low[pos] = a[i];            }        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1451 拦截导弹</title>
      <link href="2019/04/17/SDNUOJ-1451-%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/"/>
      <url>2019/04/17/SDNUOJ-1451-%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹 </p></blockquote><a id="more"></a><p><strong><a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1451" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=516838963&auto=1&height=66"></iframe><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[10005];int dp[10005];int n;///flag == 0求最长不上升子序列的长度///flag == 1求最长不上升子序列的最少数目///（即最长上升子序列的长度）void slove(bool flag){    int ans = 0;    for(int i = 0; i &lt; n; ++i)    {        dp[i] = 1;        for(int j = 0; j &lt; i; ++j)        {            if(!flag &amp;&amp; a[j] &gt;= a[i])                dp[i] = max(dp[i], dp[j] + 1);            if(flag &amp;&amp; a[j] &lt; a[i])                dp[i] = max(dp[i], dp[j] + 1);        }        ans = max(ans, dp[i]);    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    n = 0;    while(~scanf(&quot;%d&quot;, &amp;a[n]))        n++;    slove(0);    slove(1);    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1257 最少拦截系统</title>
      <link href="2019/04/17/HDU-1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F/"/>
      <url>2019/04/17/HDU-1257-%E6%9C%80%E5%B0%91%E6%8B%A6%E6%88%AA%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>某国为了防御敌国的导弹袭击,发展出一种导弹拦截系统.但是这种导弹拦截系统有一个缺陷:虽然它的第一发炮弹能够到达任意的高度,但是以后每一发炮弹都不能超过前一发的高度. </p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1257" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><blockquote><p>开一个h[N]数组，记录每套系统最后拦截的导弹的高度，对于一颗导弹，遍历所有系统，若找得到h[i]大于此导弹高度，便h[i] = 此高度，否则新添一个系统</p><p>嗯……导弹加在任意一个条件允许（h[i] &gt; 导弹高度）的系统里效果一样吗？</p><p>若导弹高度 = 1， h[0] = 100， h[1] = 2</p><p>那么选择让h[0] = 1岂不有些不妥？</p><p>假设后面还有导弹：80， 50， 30， 10…岂不要三个系统，可如果选的是h[1] = 1只需两个系统…</p><p>所以要从满足条件的h里找最小的h[i]</p><p>这题数据弱没那么做也过了…</p></blockquote><h3 id="虚假的贪心"><a href="#虚假的贪心" class="headerlink" title="虚假的贪心"></a>虚假的贪心</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        int h[1000];        int tem, cnt = 1;        scanf(&quot;%d&quot;, &amp;h[0]);        for(int i = 1; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            bool flag = 0;            for(int j = 0; j &lt; cnt; ++j)                if(h[j] &gt; tem)                {                    flag = 1;                    h[j] = tem;                    break;                }            if(!flag)            {                h[cnt] = tem;                cnt++;            }        }        cout &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote><p>据说    最长<strong>不上升</strong>子序列的<em>个数</em>  ==  最长<strong>上升</strong>子序列的<em>长度</em></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[10005];int dp[10005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d&quot;, &amp;a[i]);        ///求最长上升子序列的长度        int ans = 0;        for(int i = 0; i &lt; n; ++i)        {            dp[i] = 1;            for(int j = 0; j &lt; i; ++j)            {                if(a[j] &lt; a[i])                    dp[i] = max(dp[i], dp[j] + 1);            }            ans = max(ans, dp[i]);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 基本算法の贪心 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1087 1160</title>
      <link href="2019/04/17/HDU-1087-1160/"/>
      <url>2019/04/17/HDU-1087-1160/</url>
      
        <content type="html"><![CDATA[<h3 id="HDU-1087-Super-Jumping"><a href="#HDU-1087-Super-Jumping" class="headerlink" title="HDU 1087 Super Jumping!"></a>HDU 1087 Super Jumping!</h3><blockquote><p>（和最大）递增子序列</p></blockquote><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1087" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        int a[1005];        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d&quot;, &amp;a[i]);        long long dp[1005];        memset(dp, 0, sizeof(dp));        long long ans = 0;        for(int i = 0; i &lt; n; ++i)        {            dp[i] = a[i];            for(int j = 0; j &lt; i; ++j)                if(a[j] &lt; a[i])                    dp[i] = max(dp[i], dp[j] + a[i]);            ans = max(dp[i], ans);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="HDU-1160-FatMouse’s-Speed"><a href="#HDU-1160-FatMouse’s-Speed" class="headerlink" title="HDU 1160 FatMouse’s Speed"></a>HDU 1160 FatMouse’s Speed</h3><blockquote><p>w（重量）递增前提下 s（速度）递减的mouse最多有多少只，分别是哪几只</p><p>先按前提条件排序，再dp并记录路径</p></blockquote><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1160" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int w, s, num;} a[1005];int dp[1005];int pre[1005];bool cmp(node a, node b){    if(a.w != b.w)        return a.w &lt; b.w;    else        return a.s &gt; b.s;}int main(){    memset(pre, -1, sizeof(pre));    int cnt = 1;    while(~scanf(&quot;%d%d&quot;, &amp;a[cnt].w, &amp;a[cnt].s))        {            a[cnt].num = cnt;            cnt++;///不要跟上面写在一起（程序由右向左执行,[]里的cnt也变了）        }    sort(a + 1, a + cnt, cmp);    int ans = 0;    int pos;    for(int i = 0; i &lt; cnt; ++i)    {        dp[i] = 1;        for(int j = 0; j &lt; i; ++j)            if(a[j].w &lt; a[i].w &amp;&amp; a[j].s &gt; a[i].s)                if(dp[i] &lt; dp[j] + 1)                {                    dp[i] = dp[j] + 1;                    pre[ a[i].num ] = a[j].num;                }        if(dp[i] &gt; ans)        {            ans = dp[i];            pos = a[i].num;        }    }    vector&lt;int&gt; vec;    while(pos != -1)    {        vec.push_back(pos);        pos = pre[pos];    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    for(int i = vec.size() - 1; i &gt;= 0; --i)        cout &lt;&lt; vec[i] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1069 Monkey and Banana</title>
      <link href="2019/04/17/HDU-1069-Monkey-and-Banana/"/>
      <url>2019/04/17/HDU-1069-Monkey-and-Banana/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n种盒子（不限量），摞起来最高能有多高？（上面盒子的长与宽必须都小于下面盒子的长与宽）</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1069" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong>  </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>一种盒子六种摆放方式，将问题直接转化为：n * 6种（被规定以何种方式摆放的）盒子摞起来最高能有多高</p><p>dp：等同于求最长递减子序列</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200;struct node{    int L, W, H;} box[N];bool cmp(node a, node b){    if(a.L != b.L)        return a.L &gt; b.L;    else    {        if(a.W != b.W)            return a.W &gt; b.W;        else            return a.H &gt; b.H;    }}int main(){    int n, num = 1;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        int a, b, c, cnt = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);            box[cnt].L = a, box[cnt].W = b, box[cnt++].H = c;            box[cnt].L = a, box[cnt].W = c, box[cnt++].H = b;            box[cnt].L = b, box[cnt].W = a, box[cnt++].H = c;            box[cnt].L = b, box[cnt].W = c, box[cnt++].H = a;            box[cnt].L = c, box[cnt].W = a, box[cnt++].H = b;            box[cnt].L = c, box[cnt].W = b, box[cnt++].H = a;        }        sort(box, box + cnt, cmp);        int dp[N * 6];///dp[i]表示处理完i-1个箱子时的最大高度        int ans = 0;        for(int i = 0; i &lt; cnt; ++i)        {            dp[i] = box[i].H;            ///研究(条件满足时)dp[j]加上box[i].H能否更新dp[i]            for(int j = 0; j &lt; i; ++j)                if(box[i].L &lt; box[j].L &amp;&amp; box[i].W &lt; box[j].W)                    dp[i] = max(dp[i], dp[j] + box[i].H);            ans = max(ans, dp[i]);        }        printf(&quot;Case %d: maximum height = %d\n&quot;, num++, ans);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 3038 How many answers are wrong</title>
      <link href="2019/04/15/HDU-3038-How-many-answers-are-wrong/"/>
      <url>2019/04/15/HDU-3038-How-many-answers-are-wrong/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出n个数字m次询问</p><p>每次询问从L到R这段区间的和</p><p>若后面的答案与前面的矛盾，那么后面的答案错误</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>带权并查集，sum[i]表示i到其顶点的距离（两点的差值），也就是[i + 1,  pre[i]  ]的和</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200010;int n, m, ans;int pre[N];int sum[N];void init(){    for(int i = 0; i &lt;= n; ++i)        pre[i] = i;    memset(sum, 0, sizeof(sum));}int found(int x){    if(x == pre[x])        return x;    ///路径压缩、权值更新    int tem = pre[x];    pre[x] = found(pre[x]);    sum[x] += sum[tem];    return pre[x];}void unite(int x, int y, int val){    int xx = found(x);    int yy = found(y);    if(xx != yy)    {        pre[xx] = yy;        sum[xx] = val + sum[y] - sum[x];///类似向量    }    else    {        if(sum[x] - sum[y] != val)            ans++;    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        ans = 0;        init();        int L, R, VAL;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;VAL);            unite(--L, R, VAL);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ unique</title>
      <link href="2019/04/15/c-unique/"/>
      <url>2019/04/15/c-unique/</url>
      
        <content type="html"><![CDATA[<h3 id="unique函数"><a href="#unique函数" class="headerlink" title="unique函数"></a>unique函数</h3><blockquote><p>线段树离散化时用到了unique函数除重，在这里记一下</p></blockquote><a id="more"></a><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><blockquote><p>algorithm</p></blockquote><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><blockquote><p>unique(头地址， 尾地址)返回一个地址，用这个地址 减 头地址得数字“有几种”</p><p><code>int m = unique(vec.begin(), vec.end()) - vec.begin();</code></p><p>unique函数使得 vec前m个元素各不相同，后面的元素保持原来值不变（好多人认为把前面的值后调了）</p></blockquote><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int a[10] = {20, 20, 20, 10, 10, 30};    int n = unique(a, a + 10) - a;    cout &lt;&lt; n &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; 10; ++i)        cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    ///前n个数字不重复，后面的数字保持为原来的值    vector&lt;int&gt; vec;    vec.push_back(20);    vec.push_back(20);    vec.push_back(20);    vec.push_back(10);    vec.push_back(10);    vec.push_back(30);    int m = unique(vec.begin(), vec.end()) - vec.begin();    cout &lt;&lt; m &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; vec.size(); ++i)        cout &lt;&lt; vec[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><p><img src="https://i.loli.net/2019/04/15/5cb448dd95ad2.png" alt="ceshi"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1166 Just a Hook</title>
      <link href="2019/04/15/HDU-1166-Just-a-Hook/"/>
      <url>2019/04/15/HDU-1166-Just-a-Hook/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>区间更新，区间查询（注意val初始值非0）</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100005;struct node{    int L, R, val, lazy;} a[N &lt;&lt; 2 | 1];void down(int x){    if(a[x].lazy &gt; 0)    {        a[x &lt;&lt; 1].val = a[x].lazy * (a[x &lt;&lt; 1].R - a[x &lt;&lt; 1].L + 1);        a[x &lt;&lt; 1].lazy = a[x].lazy;        a[x &lt;&lt; 1 | 1].val = a[x].lazy * (a[x &lt;&lt; 1 | 1].R - a[x &lt;&lt; 1 | 1].L + 1);        a[x &lt;&lt; 1 | 1].lazy = a[x].lazy;        a[x].lazy = 0;    }}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = 1;    a[num].lazy = 0;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);    ///val != 0    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}void update(int num, int l, int r, int tot){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].val = tot * (r - l + 1);        a[num].lazy = tot;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, tot);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r, tot);    else    {        update(num &lt;&lt; 1, l, mid, tot);        update(num &lt;&lt; 1 | 1, mid + 1, r, tot);    }    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}//void update(int num, int l, int r, int tot)//{//    if(a[num].L &gt; r || a[num].R &lt; l)//        return ;//    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)//    {//        a[num].val = tot * (a[num].R - a[num].L + 1);//        a[num].lazy = tot;//        return ;//    }//    down(num);//    update(num &lt;&lt; 1, l, r, tot);//    update(num &lt;&lt; 1 | 1, l, r, tot);//    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;//}///int query(int num, int l, int r)如果需要勿忘down(num)int main(){    int t;    while(~scanf(&quot;%d&quot;, &amp;t))    {        int tem = t;        int n, m, b, c, d;        while(t--)        {            scanf(&quot;%d%d&quot;, &amp;n, &amp;m);            init(1, 1, n);            while(m--)            {                scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);                update(1, b, c, d);            }            printf(&quot;Case %d: The total value of the hook is %d.\n&quot;, tem - t, a[1].val);        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 3946 Highway Project</title>
      <link href="2019/04/14/ZOJ-3946-Highway-Project/"/>
      <url>2019/04/14/ZOJ-3946-Highway-Project/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点（0~n）m条边，两个权值</p><p>多开一个cs[N]数组，存到某点所选择的那条边（题目给出）的花费权值</p></blockquote><a id="more"></a><p><strong><a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemCode=3946" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><blockquote><p>这题改了一晚上最后发现：dis[N]数组按n的大小(i = 0; i &lt;= n; ++i)标INF就WA，整个memset就AC, 为啥啊？！</p></blockquote><h3 id="Code-of-spfa"><a href="#Code-of-spfa" class="headerlink" title="Code of spfa"></a>Code of spfa</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 100005;int n, m;int cnt;struct edge{    int to, d, c, pre;} a[N &lt;&lt; 1];bool vis[N];int head[N], cs[N], tot, sum;long long dis[N];deque&lt;int&gt; q;void add(int from, int to, int d, int c){    a[cnt].to = to;    a[cnt].d = d;    a[cnt].c = c;    a[cnt].pre = head[from];    head[from] = cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        vis[i] = 0;        head[i] = -1;//        dis[i] = INF;        cs[i] = INF;    }    memset(dis, INF, sizeof(dis));}void update(int t){    if(!vis[t])    {        vis[t] = 1;        if(q.empty() || dis[q.front()] &lt; dis[t] || dis[t] * tot &gt;= sum)            q.push_back(t);        else            q.push_front(t);        sum += dis[t];        tot++;    }}void spfa(int start){    dis[start] = 0;    cs[0] = 0;    q.clear();    q.push_front(start);    vis[start] = 1;    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        sum -= dis[first];        tot--;        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].d)            {                dis[t] = dis[first] + a[i].d;                cs[t] = a[i].c;                update(t);            }            if(dis[t] == dis[first] + a[i].d &amp;&amp; cs[t] &gt; a[i].c)            {                cs[t] = a[i].c;                update(t);            }        }    }}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        init();        int from, to, times, cost;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d%d&quot;, &amp;from, &amp;to, &amp;times, &amp;cost);            add(from, to, times, cost);            add(to, from, times, cost);        }        spfa(0);        long long ans_d = 0;        long long ans_c = 0;        for(int i = 0; i &lt; n; ++i)        {            ans_d += dis[i];            ans_c += cs[i];        }        cout &lt;&lt; ans_d &lt;&lt; &#39; &#39; &lt;&lt; ans_c &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Dijkstra（TLE）"><a href="#Dijkstra（TLE）" class="headerlink" title="Dijkstra（TLE）"></a>Dijkstra（TLE）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 100005;int n, m;int cnt;struct edge{    int to, d, c, pre;} a[N &lt;&lt; 1];bool vis[N];int head[N], cs[N];long long dis[N];void add(int from, int to, int d, int c){    a[cnt].to = to;    a[cnt].d = d;    a[cnt].c = c;    a[cnt].pre = head[from];    head[from] = cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        vis[i] = 0;        head[i] = -1;        dis[i] = INF;        cs[i] = INF;    }}void Dijkstra(int start){    dis[start] = 0;    cs[start] = 0;    int pos = start;    int mmin;    while(pos != -1)    {        for(int i = head[pos]; ~i; i = a[i].pre)        {            if(vis[ a[i].to ])                continue;            if(dis[ a[i].to ] == INF || dis[ a[i].to ] &gt; dis[pos] + a[i].d)            {                dis[ a[i].to ] = dis[pos] + a[i].d;                cs[ a[i].to ] = a[i].c;            }            if(dis[ a[i].to ] == dis[pos] + a[i].d)///时间相等看花费                cs[ a[i].to ] = min(cs[ a[i].to ], a[i].c);        }        vis[pos] = 1;        pos = -1;        mmin = -1;        for(int i = 0; i &lt; n; ++i)            if(!vis[i] &amp;&amp; dis[i] != INF &amp;&amp; (mmin == -1 || mmin &gt; dis[i]))            {                mmin = dis[i];                pos = i;            }    }    return ;}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        init();        int from, to, times, cost;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d%d&quot;, &amp;from, &amp;to, &amp;times, &amp;cost);            add(from, to, times, cost);            add(to, from, times, cost);        }        Dijkstra(0);        long long ans_d = 0;        long long ans_c = 0;        for(int i = 0; i &lt; n; ++i)        {            ans_d += dis[i];            ans_c += cs[i];        }        cout &lt;&lt; ans_d &lt;&lt; &#39; &#39; &lt;&lt; ans_c &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3468 A Simple Problem with Integers</title>
      <link href="2019/04/12/POJ-3468-A-Simple-Problem-with-Integers/"/>
      <url>2019/04/12/POJ-3468-A-Simple-Problem-with-Integers/</url>
      
        <content type="html"><![CDATA[<h3 id="Desscription"><a href="#Desscription" class="headerlink" title="Desscription"></a>Desscription</h3><blockquote><p>n个数字初始化，执行两种操作：更新与查询</p></blockquote><p><strong><a href="http://poj.org/problem?id=3468" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><a id="more"></a><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><blockquote><p>设三个不同的前缀和数组：</p><p>sum[i]:存原始数组前i项的和</p><p>d[i]:存从i到n的增量</p><p>di[i]: 存相应的d[i] * i</p><p>最终ans分两部分（原始前缀和+变化量前缀和）：</p><p>①sum[end] - sum[begin - 1]</p><p>②(end + 1) <em> query(d, end) - query(di, end) - {[(b - 1) + 1] </em> query(d, b - 1) - query(di, b - 1)}</p></blockquote><p><strong><a href="https://blog.csdn.net/non_cease/article/details/7435052" style="color:violet;" target="_blank" rel="noopener">分析参考</a></strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;typedef long long ll;int n, m;///三个不同的前缀和数组ll sum[N];ll d[N];ll di[N];///树状数组：动态维护&quot;前缀和&quot;int lowbit(int pos){    return pos &amp; -pos;}///万能更新(前缀和)void update(ll * t, int pos, ll val){    while(pos &lt;= n)    {        t[pos] += val;        pos += lowbit(pos);    }}///万能查询(前缀和)ll query(ll * t, int pos){    long long res = 0;    while(pos &gt;= 1)    {        res += t[pos];        pos -= lowbit(pos);    }    return res;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(sum, 0, sizeof(sum));        memset(d, 0, sizeof(d));        memset(di, 0, sizeof(di));        ll tem;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%lld&quot;, &amp;tem);            sum[i] = sum[i - 1] + tem;        }        getchar();        char ch;        ll b, c, e;        while(m--)        {            ch = getchar();            if(ch == &#39;Q&#39;)            {                scanf(&quot;%lld%lld&quot;, &amp;b, &amp;c);                getchar();                ll ans = sum[c] - sum[b - 1];                ans += (c + 1) * query(d, c) - query(di, c);                ans -= b * query(d, b - 1) - query(di, b - 1);                cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            }            else            {                scanf(&quot;%lld%lld%lld&quot;, &amp;b, &amp;c, &amp;e);                getchar();                update(d, b, e);                update(d, c + 1, -e);                update(di, b, e * b);                update(di, c + 1, -e * (c + 1));            }        }    }    return 0;}</code></pre><h3 id="线段树（分清存和or存最值）"><a href="#线段树（分清存和or存最值）" class="headerlink" title="线段树（分清存和or存最值）"></a>线段树（分清存和or存最值）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;struct node{    int L, R;    long long val, lazy;} a[N &lt;&lt; 2 | 1];long long ans;void down(int x){    a[x &lt;&lt; 1].val += a[x].lazy * (a[x &lt;&lt; 1].R - a[x &lt;&lt; 1].L + 1);    a[x &lt;&lt; 1].lazy += a[x].lazy;    a[x &lt;&lt; 1 | 1].val += a[x].lazy * (a[x &lt;&lt; 1 | 1].R - a[x &lt;&lt; 1 | 1].L + 1);    a[x &lt;&lt; 1 | 1].lazy += a[x].lazy;    a[x].lazy = 0;}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = 0;    a[num].lazy = 0;    if(l == r)///勿忘        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void update(int num, int l, int r, int tot){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        a[num].val += tot * (a[num].R - a[num].L + 1);        a[num].lazy += tot;        return ;    }    down(num);    update(num &lt;&lt; 1, l, r, tot);    update(num &lt;&lt; 1 | 1, l, r, tot);    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}long long query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)        return a[num].val;    if(a[num].L == a[num].R)        return 0;    down(num);///查询与更新都要有的操作    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        return ans + query(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        return ans + query(num &lt;&lt; 1 | 1, l, r);    else        return ans + query(num &lt;&lt; 1, l, mid) + query(num &lt;&lt; 1 | 1, mid + 1, r);}int main(){    int n, q;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;q))    {        init(1, 1, n);        int tem, d;        int b, c;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(1, i, i, tem);        }        getchar();        char ch;        while(q--)        {            ch = getchar();            if(ch == &#39;Q&#39;)            {                ans = 0;                scanf(&quot;%d%d&quot;, &amp;b, &amp;c);                getchar();                cout &lt;&lt; query(1, b, c) &lt;&lt; &#39;\n&#39;;            }            else            {                scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);                getchar();                update(1, b, c, d);            }        }    }    return 0;}</code></pre><h4 id="线段树update函数优雅写法"><a href="#线段树update函数优雅写法" class="headerlink" title="线段树update函数优雅写法"></a>线段树update函数优雅写法</h4><pre><code class="lang-c++">void update(int num, int l, int r, int tot){    if(a[num]. L == l &amp;&amp; a[num].R == r)    {        a[num].val += tot * (a[num].R - a[num].L + 1);///存和与存最值的不同        a[num].lazy += tot;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);///此区间非目标区间，数据下传    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, tot);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r, tot);    else    {        ///第三种情况分别找，区间分成两部分        update(num &lt;&lt; 1, l, mid, tot);        update(num &lt;&lt; 1 | 1, mid + 1, r, tot);    }    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}</code></pre><h4 id="线段树update函数流氓写法"><a href="#线段树update函数流氓写法" class="headerlink" title="线段树update函数流氓写法"></a>线段树update函数流氓写法</h4><pre><code class="lang-c++">void update(int num, int l, int r, int tot){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        a[num].val += tot * (a[num].R - a[num].L + 1);        a[num].lazy += tot;        return ;    }    down(num);    update(num &lt;&lt; 1, l, r, tot);    update(num &lt;&lt; 1 | 1, l, r, tot);    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> 数据结构の树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1754 I Hate It</title>
      <link href="2019/04/10/HDU-1754-I-Hate-It/"/>
      <url>2019/04/10/HDU-1754-I-Hate-It/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>中文题目</p></blockquote><a id="more"></a><p><strong><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754" style="color:violet;" target="_blank" rel="noopener">题目链接</a></strong></p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200005;int n, m;struct node{    int L, R, val;}a[N &lt;&lt; 2 | 1] ;void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = 0;    if(l == r)///初始化到叶子结点返回        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void update(int num, int l, int r, int tot){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].val = tot;        return ;    }    if(a[num].L == a[num].R)///搜索到叶子节点返回        return ;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, tot);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r, tot);    else    {        update(num &lt;&lt; 1, l, r, tot);        update(num &lt;&lt; 1 | 1, l, r, tot);    }    a[num].val = max(a[num &lt;&lt; 1].val, a[num &lt;&lt; 1 | 1].val);}int query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)        return a[num].val;    if(a[num].L == a[num].R)        return 0;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        return query(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        return query(num &lt;&lt; 1 | 1, l, r);    else///区间范围分清楚        return max(query(num &lt;&lt; 1, l, mid), query(num &lt;&lt; 1 | 1, mid + 1, r));}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        init(1, 1, n);        int tem, b, c;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(1, i, i, tem);        }        getchar();        char ch;        for(int i = 0; i &lt; m; ++i)        {            ch = getchar();            if(ch == &#39;Q&#39;)            {                scanf(&quot;%d%d&quot;, &amp;b, &amp;c);                getchar();                cout &lt;&lt; query(1, b, c) &lt;&lt; &#39;\n&#39;;            }            else            {                scanf(&quot;%d%d&quot;, &amp;b, &amp;c);                getchar();                update(1, b, b, c);            }        }    }    return 0;}</code></pre><h3 id="树状数组（求最值）"><a href="#树状数组（求最值）" class="headerlink" title="树状数组（求最值）"></a>树状数组（求最值）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 200005;int n, m;int tree[N];int init[N];int lowbit(int x){    return x &amp; (-x);}void update(int x, int y){    init[x] = y;    for(int i = x; i &lt;= n; i += lowbit(i))        tree[i] = max(tree[i], y);}int get_mmax(int x, int y){    int ans = init[y];    while(y != x)    {        for(--y; y - lowbit(y) &gt;= x; y -= lowbit(y))            ans = max(ans, tree[y]);        ans = max(ans, init[y]);    }    return ans;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(tree, 0, sizeof(tree));        memset(init, 0, sizeof(init));        int tem, b, c;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(i, tem);        }        getchar();        char ch;        for(int i = 0; i &lt; m; ++i)        {            ch = getchar();            if(ch == &#39;Q&#39;)            {                scanf(&quot;%d%d&quot;, &amp;b, &amp;c);                getchar();                cout &lt;&lt; get_mmax(b, c) &lt;&lt; &#39;\n&#39;;            }            else            {                scanf(&quot;%d%d&quot;, &amp;b, &amp;c);                getchar();                update(b, c);            }        }    }    return 0;}</code></pre><p>更多关于树状数组 <a href="https://blog.csdn.net/yu121380/article/details/81431480" target="_blank" rel="noopener">https://blog.csdn.net/yu121380/article/details/81431480</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> 数据结构の树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gitment 评论</title>
      <link href="2019/04/10/Gitment-%E8%AF%84%E8%AE%BA/"/>
      <url>2019/04/10/Gitment-%E8%AF%84%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Gitment评论"><a href="#Gitment评论" class="headerlink" title="Gitment评论"></a>Gitment评论</h3><blockquote><p>前提：登录github账号</p><p><strong><a href="https://jingyan.baidu.com/article/4ae03de3d6f9c53eff9e6bdd.html" style="color:violet;" target="_blank" rel="noopener">如何注册Github账号</a></strong></p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1293951677&auto=1&height=66"></iframe><h3 id="如何登录Github账号参与评论"><a href="#如何登录Github账号参与评论" class="headerlink" title="如何登录Github账号参与评论"></a>如何登录Github账号参与评论</h3><blockquote><p>①点进一篇可以参与评论的文章（博主可以设置哪些文章开启评论），滑到下方评论区</p></blockquote><p><img src="https://i.postimg.cc/MHjBZJcQ/PVGIAIQ-Q7-GIV6-NQ-QRM-RM.png" alt="演示"></p><blockquote><p>②点击login登录你的Github账号</p></blockquote><p><img src="https://i.postimg.cc/fbrjMKH1/0-Y-MU3-R76-N-AWT7-T0-7-T-FX.png" alt="show"></p><blockquote><p>③凭用户名或邮箱和密码登录</p></blockquote><p><img src="https://i.postimg.cc/qqX36XLJ/PKK0-O-H57-TUU-XEUWC-S-4-I.png" alt="show"></p><blockquote><p>④点击<strong>Authorize(认可) fireworks99</strong></p></blockquote><p><img src="https://i.postimg.cc/dVDhJKzt/X-XC-2-N-D-LAR-D-XN.png" alt="show"></p><blockquote><p>⑤可以评论了（支持markdown语法，preview可预览效果）</p><p><strong><a href="https://www.jianshu.com/p/a6a6a22e9393" style="color:violet;" target="_blank" rel="noopener">部分Markdown语法</a></strong>  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1166 敌兵布阵</title>
      <link href="2019/04/09/HDU-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/"/>
      <url>2019/04/09/HDU-1166-%E6%95%8C%E5%85%B5%E5%B8%83%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>区间1~n初始有一些人，某个区间可以增加人数、减少人数、询问人数。</p></blockquote><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" style="color:red;" target="_blank" rel="noopener">LINK</a></p><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><blockquote><p>1.N * 4 + 1的空间（有N * 2节省空间的方法）</p><p>2.用 位运算符时注意其优先级低，用 (num &lt;&lt; 1) + 1 或  num &lt;&lt; 1 | 1</p><p>3.更新末操作：a[num].val = a[num &lt;&lt; 1].val + a[(num &lt;&lt; 1) + 1].val;</p><p>4.单点更新、单点查询、区间查询都可套用模板，但区间更新分①普通更新②lazy标记</p></blockquote><h3 id="Code-of-ordinary-Segment-tree"><a href="#Code-of-ordinary-Segment-tree" class="headerlink" title="Code of ordinary Segment tree"></a>Code of ordinary Segment tree</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 50005;map&lt;string, int&gt; mp;struct node{    int L, R, val;}a[(N &lt;&lt; 2) + 1];void init(int num, int l, int r)///r = 6,r = 10数组并没有充分利用{    a[num].L = l;    a[num].R = r;    a[num].val = 0;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);///mid被分到左孩子    init((num &lt;&lt; 1) + 1, mid + 1, r);///忽略了位运算符优先级低}///设flag为1对应增加,为0对应减少void update(int num, int l, int r, bool flag, int tot){    if(a[num].L == l &amp;&amp; a[num].R == r)///找到区间，去做任务    {        if(flag)            a[num].val += tot;        else            a[num].val -= tot;        return ;///这里的return都能忘？！    }    if(a[num].L == a[num].R)///未找到区间，返回上一级，程序向下运行        return ;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, flag, tot);    else if(mid &lt; l)///此处无等号(mid被分到左孩子)        update((num &lt;&lt; 1) + 1, l, r, flag, tot);    else    {        update(num &lt;&lt; 1, l, mid, flag, tot);        update((num &lt;&lt; 1) + 1, mid + 1, r, flag, tot);    }    a[num].val = a[num &lt;&lt; 1].val + a[(num &lt;&lt; 1) + 1].val;}int query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)///找到区间，去做任务            return a[num].val;    if(a[num].L == a[num].R)        return 0;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        return query(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        return query((num &lt;&lt; 1) + 1, l, r);    else        return (query(num &lt;&lt; 1, l, mid) + query((num &lt;&lt; 1) + 1, mid + 1, r));}int main(){    int t;    string s[4];    s[0] = &quot;End&quot;;///字符串对应时，尽量控制只比较第一个字符    s[1] = &quot;Add&quot;;    s[2] = &quot;Sub&quot;;    s[3] = &quot;Query&quot;;    for(int i = 0; i &lt; 4; ++i)        mp[ s[i] ] = i;    scanf(&quot;%d&quot;, &amp;t);    int tot = t;    while(t--)    {        int n, tem;        scanf(&quot;%d&quot;, &amp;n);        init(1, 1, n);        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(1, i, i, 1, tem);        }        printf(&quot;Case %d:\n&quot;, tot - t);        string ch;        while(cin &gt;&gt; ch)        {            bool flag = 0;            int x, y;            switch(mp[ch])            {            case 0:                flag = 1;                break;            case 1:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(1, x, x, 1, y);                break;            case 2:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(1, x, x, 0, y);                break;            case 3:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                cout &lt;&lt; query(1, x, y) &lt;&lt; &#39;\n&#39;;                break;            }            if(flag)            break;        }    }    return 0;}</code></pre><h3 id="Code-of-Improved-Segment-tree-by-lazy-array"><a href="#Code-of-Improved-Segment-tree-by-lazy-array" class="headerlink" title="Code of Improved Segment tree(by lazy array)"></a>Code of Improved Segment tree(by lazy array)</h3><blockquote><p>1.区间结构体中除L、R、val，増一个lazy</p><p>2.init时lazy赋0</p><p>3.更新时，若当前区间是目标区间，更新val顺便，更新lazy</p><p>若当前区间不是目标区间，数据下传：down（传完记得lazy清零）</p></blockquote><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 50005;map&lt;string, int&gt; mp;struct node{    int L, R, val, lazy;} a[N &lt;&lt; 2 | 1];void down(int x)///将x区间数据下传{    ///子区间继承父区间的lazy以便下传    ///更新子区间的val    a[x &lt;&lt; 1].lazy += a[x].lazy;    a[x &lt;&lt; 1].val += a[x].lazy;    a[x &lt;&lt; 1 | 1].lazy += a[x].lazy;    a[x &lt;&lt; 1 | 1].val += a[x].lazy;    a[x].lazy = 0;///下传完了lazy清零}void init(int num, int l, int r)///r = 6,r = 10数组并没有充分利用{    a[num].L = l;    a[num].R = r;    a[num].val = 0;    a[num].lazy = 0;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);///mid被分到左孩子    init(num &lt;&lt; 1 | 1, mid + 1, r);///忽略了位运算符优先级低}///设flag为1对应增加,为0对应减少void update(int num, int l, int r, bool flag, int tot){    if(a[num].L == l &amp;&amp; a[num].R == r)///找到区间，去做任务    {        if(flag)        {            a[num].val += tot;            a[num].lazy += tot;        }        else        {            a[num].val -= tot;            a[num].lazy -= tot;        }        return ;    }    if(a[num].L == a[num].R)///未找到区间，返回上一级，程序向下运行        return ;    down(num);///此区间非目标区间，数据下传    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, flag, tot);    else if(mid &lt; l)///此处无等号(mid被分到左孩子)        update(num &lt;&lt; 1 | 1, l, r, flag, tot);    else    {        update(num &lt;&lt; 1, l, mid, flag, tot);        update(num &lt;&lt; 1 | 1, mid + 1, r, flag, tot);    }    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}int query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)///找到区间，去做任务        return a[num].val;    if(a[num].L == a[num].R)        return 0;    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        return query(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        return query(num &lt;&lt; 1 | 1, l, r);    else        return (query(num &lt;&lt; 1, l, mid) + query(num &lt;&lt; 1 | 1, mid + 1, r));}int main(){    int t;    string s[4];    s[0] = &quot;End&quot;;///字符串对应时，尽量控制只比较第一个字符    s[1] = &quot;Add&quot;;    s[2] = &quot;Sub&quot;;    s[3] = &quot;Query&quot;;    for(int i = 0; i &lt; 4; ++i)        mp[ s[i] ] = i;    scanf(&quot;%d&quot;, &amp;t);    int tot = t;    while(t--)    {        int n, tem;        scanf(&quot;%d&quot;, &amp;n);        init(1, 1, n);        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(1, i, i, 1, tem);        }        printf(&quot;Case %d:\n&quot;, tot - t);        string ch;        while(cin &gt;&gt; ch)        {            bool flag = 0;            int x, y;            switch(mp[ch])            {            case 0:                flag = 1;                break;            case 1:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(1, x, x, 1, y);                break;            case 2:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(1, x, x, 0, y);                break;            case 3:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                cout &lt;&lt; query(1, x, y) &lt;&lt; &#39;\n&#39;;                break;            }            if(flag)                break;        }    }    return 0;}</code></pre><h3 id="Try-to-save-time-and-memory"><a href="#Try-to-save-time-and-memory" class="headerlink" title="Try to save time and memory"></a>Try to save time and memory</h3><blockquote><p>1.张昆玮线段树：循环代替递归 <a href="https://blog.csdn.net/keshuqi/article/details/52205884" style="color:blue;" target="_blank" rel="noopener">张昆玮线段树</a></p><p>2.N * 2空间：<a href="http://www.cppblog.com/MatoNo1/archive/2015/05/05/195857.html" style="color:fuchsia;" target="_blank" rel="noopener">空间节省</a></p></blockquote><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h3><blockquote><p>三个函数：lowbit、单点更新、区间查询</p></blockquote><h3 id="Code-of-Binary-Index-Tree"><a href="#Code-of-Binary-Index-Tree" class="headerlink" title="Code of Binary Index Tree"></a>Code of Binary Index Tree</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 50005;map&lt;string, int&gt; mp;int n;///区间上限int tree[N];///树状数组C[N]///原始数组A[N]假设存在int lowbit(int x){    return x &amp; (-x);}///单点更新void update(int x, int y)///修改A[x]对应相关C[]的更新{    for(int i = x; i &lt;= n; i += lowbit(i))///要求n为全局变量        tree[i] += y;}///区间查询int get_sum(int x)///求A[]前x项的和{    int ans = 0;    for(int i = x; i &gt;= 1; i -= lowbit(i))        ans += tree[i];    return ans;}int main(){    int t;    string s[4];    s[0] = &quot;End&quot;;///字符串对应时，尽量控制只比较第一个字符    s[1] = &quot;Add&quot;;    s[2] = &quot;Sub&quot;;    s[3] = &quot;Query&quot;;    for(int i = 0; i &lt; 4; ++i)        mp[ s[i] ] = i;    scanf(&quot;%d&quot;, &amp;t);    int tot = t;    while(t--)    {        int tem;        scanf(&quot;%d&quot;, &amp;n);        memset(tree, 0, sizeof(tree));        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            update(i, tem);        }        printf(&quot;Case %d:\n&quot;, tot - t);        string ch;        while(cin &gt;&gt; ch)        {            bool flag = 0;            int x, y;            switch(mp[ch])            {            case 0:                flag = 1;                break;            case 1:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(x, y);                break;            case 2:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);                update(x, -y);                break;            case 3:                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);///注意区间保留x                cout &lt;&lt; get_sum(y) - get_sum(x - 1) &lt;&lt; &#39;\n&#39;;                break;            }            if(flag)                break;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> 数据结构の树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路记录路径 POJ 2457</title>
      <link href="2019/04/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84-POJ-2457/"/>
      <url>2019/04/08/%E6%9C%80%E7%9F%AD%E8%B7%AF%E8%AE%B0%E5%BD%95%E8%B7%AF%E5%BE%84-POJ-2457/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>m条单向路，n个点（1~n）</p><p>求从1到n的最短路，不存在输出“-1”，存在则输出路径</p></blockquote><a id="more"></a><p><strong><a href="http://poj.org/problem?id=2457" style="color:violet;" target="_blank" rel="noopener">点我飞过去</a></strong></p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><blockquote><p>较为特殊，数组pre[i][j]存从i到j的最短路径上i后面的第一个点</p><p>当然对于此题Floyd已超时了，但算法是对的</p></blockquote><h3 id="Code-of-Floyd"><a href="#Code-of-Floyd" class="headerlink" title="Code of Floyd"></a>Code of Floyd</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n;int mp[1005][1005];int pre[1005][1005];///pre[i][j]存从i到j的最短路径上i后面的第一个点void init(){    for(int i = 0; i &lt;= n; ++i)        for(int j = 0; j &lt;= n; ++j)        {            mp[i][j] = (i == j ? 0: INF);            pre[i][j] = j;        }}void floyd(){    vector&lt;int&gt; ans;    for(int k = 1; k &lt;= n; ++k)///我无语了，又写成了++i        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(mp[i][j] &gt; mp[i][k] + mp[k][j])                {                    mp[i][j] = mp[i][k] + mp[k][j];                    pre[i][j] = pre[i][k];                }    if(mp[1][n] == INF)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    else    {        vector&lt;int&gt; ans;        ans.push_back(1);        int pos = pre[1][n];        while(pos != n)        {            ans.push_back(pos);            pos = pre[pos][n];        }        ans.push_back(n);        int sz = ans.size();        cout &lt;&lt; sz &lt;&lt; &#39;\n&#39;;        for(int i = 0; i &lt; sz; ++i)            cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;    }    return ;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    {        init();        int there, here;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            mp[there][here] = 1;        }        floyd();    }    return 0;}</code></pre><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><blockquote><p>nodepre[N]，这种最短路的记录路径，就像BFS的记录路径pre，像最长递增子序列的记录路径pre，像链式前向星的pre。</p></blockquote><h3 id="Code-of-Dijkstra"><a href="#Code-of-Dijkstra" class="headerlink" title="Code of Dijkstra"></a>Code of Dijkstra</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n;bool vis[1005];int head[1005], dis[1005];int nodepre[1005];///路径都是pre存(由后推前)，而非nxt(由前推后)的原因：///更新方向：由前向后，一点更新多点///即：一点有多个nxt,却只有一个&quot;有实际意义的&quot;preint cnt;struct edge{    int from, to, w, pre;} a[50005];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        dis[i] = INF;        vis[i] = 0;        head[i] = -1;        nodepre[i] = -1;    }}void Dijkstra(int start){    dis[start] = 0;    int pos = start;    int mmin;    while(pos != -1)    {        for(int i = head[pos]; ~i; i = a[i].pre)        {            if(vis[ a[i].to ])                continue;            if(dis[ a[i].to ] == INF || dis[ a[i].to ] &gt; dis[pos] + a[i].w)            {                dis[ a[i].to ] = dis[pos] + a[i].w;                nodepre[ a[i].to ] = pos;            }        }        vis[pos] = 1;        pos = -1;        mmin = -1;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; dis[i] != INF &amp;&amp; (mmin == -1 || mmin &gt; dis[i]))            {                mmin = dis[i];                pos = i;            }    }    if(dis[n] == INF)    {        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        return ;    }    vector&lt;int&gt; ans;    pos = n;    while(nodepre[pos] != -1)    {        ans.push_back(pos);        pos = nodepre[pos];    }    ans.push_back(start);    int sz = ans.size();    cout &lt;&lt; sz &lt;&lt; &#39;\n&#39;;    for(int i = sz - 1; i &gt;= 0; --i)        cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;    return ;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    {        init();        int there, here;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            add(there, here, 1);        }        Dijkstra(1);    }    return 0;}</code></pre><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford"></a>Bellman_Ford</h3><blockquote><p>同Dijkstra普通记录路径方法</p></blockquote><h3 id="Code-of-Bellman-Ford"><a href="#Code-of-Bellman-Ford" class="headerlink" title="Code of Bellman_Ford"></a>Code of Bellman_Ford</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n, dis[1005], nodepre[1005];int cnt;struct edge{    int from, to, w;} a[50005];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    cnt++;}bool Bellman_Ford(int start){    dis[start] = 0;    int tot = n;    while(tot--)    {        bool flag = 0;        for(int i = 0; i &lt; cnt; ++i)            if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            {                flag = 1;                dis[ a[i].to ] = dis[ a[i].from ] + a[i].w;                nodepre[ a[i].to ] = a[i].from;            }        if(!flag)            break;    }    for(int i = 0; i &lt; cnt; ++i)        if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            return 0;    if(dis[n] == INF)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    else    {        int pos = n;        vector&lt;int&gt; ans;        while(pos != -1)        {            ans.push_back(pos);            pos = nodepre[pos];        }        int sz = ans.size();        cout &lt;&lt; sz &lt;&lt; &#39;\n&#39;;        for(int i = sz - 1; i &gt;= 0; --i)            cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;    }    return 1;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    {        cnt = 0;        memset(dis, INF, sizeof(dis));        memset(nodepre, -1, sizeof(nodepre));        int there, here;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            add(there, here, 1);        }        if(Bellman_Ford(1))            continue;    }    return 0;}</code></pre><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><blockquote><p>同Dijkstra普通记录路径方法</p></blockquote><h3 id="Code-of-spfa"><a href="#Code-of-spfa" class="headerlink" title="Code of spfa"></a>Code of spfa</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int m, n;bool vis[1005];int head[1005], dis[1005], times[1005], tot, sum;int nodepre[1005];int cnt;struct edge{    int from, to, w, pre;} a[50005];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        dis[i] = INF;        vis[i] = 0;        times[i] = 0;        head[i] = -1;        nodepre[i] = -1;    }}bool spfa(int start){    dis[start] = 0;    deque&lt;int&gt; q;    q.push_front(start);    vis[start] = 1;    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        sum -= dis[first];        tot--;        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                nodepre[t] = first;                if(!vis[t])                {                    vis[t] = 1;                    if(q.empty() || dis[q.front()] &lt; dis[t] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                    if(++times[t] &gt;= n)                        return 0;                }            }        }    }    if(dis[n] == INF)        cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    else    {        int pos = n;        vector&lt;int&gt; ans;        while(pos != -1)        {            ans.push_back(pos);            pos = nodepre[pos];        }        int sz = ans.size();        cout &lt;&lt; sz &lt;&lt; &#39;\n&#39;;        for(int i = sz - 1; i &gt;= 0; --i)            cout &lt;&lt; ans[i] &lt;&lt; &#39;\n&#39;;    }    return 1;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    {        init();        int there, here;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            add(there, here, 1);        }        if(spfa(1))            continue;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
            <tag> 最短路のBellman-Ford </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3660 Cow Contest</title>
      <link href="2019/04/07/POJ-3660-Cow-Contest/"/>
      <url>2019/04/07/POJ-3660-Cow-Contest/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n头牛参加比赛，给你m对关系（譬如给你a和b，那么给的就是a必赢b，当然，b能赢c，那么a也能赢c），问能确定多少头牛的排名。 </p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=3660" style="color:deeppink;" target="_blank" rel="noopener">传送门</a></p><h3 id="Floyd-传递闭包"><a href="#Floyd-传递闭包" class="headerlink" title="Floyd 传递闭包"></a>Floyd 传递闭包</h3><blockquote><p>传递闭包的含义指通过传递性推导出尽量多的元素之间的关系</p><p>用flod算法将所有的关系进行传递，只要u能胜v，那么我们就将d[u][v]设为1，最后如果两者之间有d[u][v]=0且d[v][u]=0则u、v两点不知排名</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n, m;bool beat[105][105];///一个可怕的地方：我所有的循环都写了++ivoid floyd(){    for(int k = 1; k &lt;= n; ++k)///++i写太习惯了        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(beat[i][k] &amp;&amp; beat[k][j])                    beat[i][j] = 1;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int a, b;    memset(beat, 0, sizeof(beat));    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        beat[a][b] = 1;    }    floyd();    int ans = n;    set&lt;int&gt; st;    for(int i = 1; i &lt;= n; ++i)        for(int j = i + 1; j &lt;= n; ++j)            if(beat[i][j] == 0 &amp;&amp; beat[j][i] == 0)            {                st.insert(i);                st.insert(j);            }    cout &lt;&lt; ans - st.size() &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="Wrong-answer-并查集-拓扑排序"><a href="#Wrong-answer-并查集-拓扑排序" class="headerlink" title="Wrong answer(并查集+拓扑排序)"></a>Wrong answer(并查集+拓扑排序)</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;///n个点，m个关系描述int init_in[105], in[105], init_out[105];vector&lt;int&gt; ans;vector&lt;int&gt; v[105];int pre[105];void init(){    for(int i = 0; i &lt;= n; ++i)    {        pre[i] = i;        v[i].clear();    }}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[y] = x;    return ;}void bfs(){    queue&lt;int&gt; q;    for(int i = 1; i &lt;= n; ++i)///从1~n        if(!init_in[i])            q.push(i);    int init_qsz = q.size();    while(q.size())    {        int first = q.front();        ans.push_back(first);        q.pop();        for(int i = 0; i &lt; v[first].size(); ++i)        {            in[ v[first][i] ]--;            if(in[ v[first][i] ] == 0)                q.push(v[first][i]);        }    }    int res = 0;    int sz = ans.size();///原从0到顶遍历，后改为从顶到0，结果++i没换，编译器不报错一直RE    ///应有四种类型：树形、倒树形、菱形、“嚣”字形    if(init_qsz != 1)        for(int i = sz - 1; i &gt;= 0; --i)///树形        {            if(init_in[ ans[i] ] == 1)                res++;            else                break;        }    else        for(int i = 0; i &lt; sz; ++i)///倒树形        {            if(init_out[ ans[i] ] == 1)                res++;            else                break;        }    cout &lt;&lt; res + 1 &lt;&lt; &#39;\n&#39;;}int main(){    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    init();    memset(init_in, 0, sizeof(init_in));    memset(in, 0, sizeof(in));    int a, b;    map&lt;int, map&lt;int, bool&gt; &gt; mp;    for(int i = 0; i &lt; m; ++i)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        if(mp[a][b])///map嵌套除重            continue;        else            mp[a][b] = 1;        unite(a, b);        v[a].push_back(b);        init_out[a]++;        init_in[b]++;        in[b]++;    }    bool flag = 1;    int standard = found(1);    for(int i = 2; i &lt;= n; ++i)        if(found(i) != standard)        {            flag = 0;            break;        }    if(!flag)        cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;    else        bfs();    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1502 MPI Maelstrom</title>
      <link href="2019/04/06/POJ-1502-MPI-Maelstrom/"/>
      <url>2019/04/06/POJ-1502-MPI-Maelstrom/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点（1~n）</p><p>半个矩阵表示两点距离，x表示无穷大。（自己到自己的距离为0，矩阵里不包含这部分）</p><p>求1到所有点中最远点的最小距离</p></blockquote><a id="more"></a><p><a href="http://poj.org/problem?id=1502" style="color:purple;" target="_blank" rel="noopener">传送门</a>  </p><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h3><blockquote><p>字符串转int</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){    string s;    cin &gt;&gt; s;    int a = atoi(s.c_str());    cout &lt;&lt; a &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><p><strong>更多</strong><a href="https://blog.csdn.net/u010510020/article/details/73799996" target="_blank" rel="noopener">https://blog.csdn.net/u010510020/article/details/73799996</a></p><p><a href="https://blog.csdn.net/u013497977/article/details/50908342" target="_blank" rel="noopener">https://blog.csdn.net/u013497977/article/details/50908342</a></p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><blockquote><p>邻接矩阵存图，最短路更新在里面</p></blockquote><h3 id="Code-of-Floyd"><a href="#Code-of-Floyd" class="headerlink" title="Code of Floyd"></a>Code of Floyd</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;///最短路、最小生成树int n;int mp[105][105];void floyd(){    for(int k = 1; k &lt;= n; ++k)        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                if(mp[i][j] &gt; mp[i][k] + mp[k][j])                    mp[i][j] = mp[i][k] + mp[k][j];    int ans = -1;    for(int i = 1; i &lt;= n; ++i)        if(mp[1][i] &gt; ans)            ans = mp[1][i];    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    scanf(&quot;%d&quot;, &amp;n);    memset(mp, INF, sizeof(mp));    for(int i = 1; i &lt;= n; ++i)        mp[i][i] = 0;    string s;    for(int i = 2; i &lt;= n; ++i)        for(int j = 1; j &lt; i; ++j)///我常犯的错误:都int j了，还++i        {            cin &gt;&gt; s;            if(s == &quot;x&quot;)                mp[i][j] = mp[j][i] = INF;            else                mp[i][j] = mp[j][i] = atoi(s.c_str());        }    floyd();    return 0;}</code></pre><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford"></a>Bellman_Ford</h3><blockquote><p>结构体存边，以“点数次”(n)遍历所有边(cnt)去松弛</p></blockquote><h3 id="Code-of-Bellman-Ford"><a href="#Code-of-Bellman-Ford" class="headerlink" title="Code of Bellman_Ford"></a>Code of Bellman_Ford</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n, dis[105];int cnt;struct edge{    int from, to, w;} a[10005];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    cnt++;}///现在看看这算法也挺暴力的：以“点数次”(n)遍历所有边(cnt)去松弛bool Bellman_Ford(int start)///以遍历边为基础{    dis[start] = 0;    int tot = n;///n次松弛(这算法好牛，看看怎么实现的。Later，算了，能用就行)    while(tot--)    {        bool flag = 0;///优化        for(int i = 0; i &lt; cnt; ++i)///遍历所有边            if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            {                flag = 1;                dis[ a[i].to ] = dis[ a[i].from ] + a[i].w;            }        if(!flag)            break;    }    for(int i = 0; i &lt; cnt; ++i)        if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            return 0;    return 1;}int main(){    scanf(&quot;%d&quot;, &amp;n);    memset(dis, INF, sizeof(dis));    cnt = 0;    string s;    for(int i = 2; i &lt;= n; ++i)        for(int j = 1; j &lt; i; ++j)        {            cin &gt;&gt; s;            if(s == &quot;x&quot;)                add(i, j, INF);            else                add(i, j, atoi(s.c_str()));        }    if(Bellman_Ford(1))    {        int ans = -1;        for(int i = 1; i &lt;= n; ++i)            if(dis[i] &gt; ans &amp;&amp; dis[i] != INF)                ans = dis[i];        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><blockquote><p>每次找到离源点最近的一个顶点，然后以该顶点为中心，然后得到源点到其他顶点的最短路径。贪心算法。 </p></blockquote><h3 id="Code-of-Dijkstra"><a href="#Code-of-Dijkstra" class="headerlink" title="Code of Dijkstra"></a>Code of Dijkstra</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int cnt;struct edge{    int from, to, w, pre;} a[10005];bool vis[105];int head[105], dis[105];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    a[cnt].pre = head[to];    head[to] = cnt;    cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        dis[i] = INF;        head[i] = -1;        vis[i] = 0;    }}///分两部分①②void dijkstra(int start){    dis[start] = 0;    int pos = start;    int mmin;    while(pos != -1)    {        ///①利用当前点更新未连入图的点到起点的最短距离        ///注意：pos是中转点，不再是a[i].from!        for(int i = head[pos]; ~i; i = a[i].pre)        {            if(vis[ a[i].to ])                continue;            if(dis[ a[i].to ] == INF || dis[ a[i].to ] &gt; dis[pos] + a[i].w)                dis[ a[i].to ] = dis[pos] + a[i].w;        }        vis[pos] = 1;        ///②找到下一个距离起点最近的未连入线的点        pos = -1;        mmin = -1;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; dis[i] != INF &amp;&amp; (dis[i] &lt; mmin || mmin == -1))            {                mmin = dis[i];                pos = i;            }    }    return ;}int main(){    scanf(&quot;%d&quot;, &amp;n);    init();    string s;    for(int i = 2; i &lt;= n; ++i)        for(int j = 1; j &lt; i; ++j)        {            cin &gt;&gt; s;            if(s == &quot;x&quot;)                add(i, j, INF);            else                add(i, j, atoi(s.c_str()));        }    dijkstra(1);    int ans = -1;    for(int i = 1; i &lt;= n; ++i)        if(dis[i] &gt; ans &amp;&amp; dis[i] != INF)            ans = dis[i];    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><blockquote><p>感觉像是广义的dijkstra，“最短路期望”…</p></blockquote><h3 id="Code-of-spfa"><a href="#Code-of-spfa" class="headerlink" title="Code of spfa"></a>Code of spfa</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;int cnt;struct edge{    int from, to, w, pre;} a[10005];bool vis[105];///表示是否在队列里int head[105], dis[105], times[105], tot, sum;void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    a[cnt].pre = head[to];    head[to] = cnt;    cnt++;}void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)    {        dis[i] = INF;        head[i] = -1;        vis[i] = 0;        times[i] = 0;    }}bool spfa(int start){    deque&lt;int&gt; q;    dis[start] = 0;    q.push_front(start);    vis[start] = 1;///表示在队列里    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];///同dijkstra，以first为中转点，而非a[i].from        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                    if(++times[t] &gt;= n)///这里是t                        return 0;                }            }        }    }    return 1;}int main(){    scanf(&quot;%d&quot;, &amp;n);    init();    string s;    for(int i = 2; i &lt;= n; ++i)        for(int j = 1; j &lt; i; ++j)        {            cin &gt;&gt; s;            if(s == &quot;x&quot;)                add(i, j, INF);            else                add(i, j, atoi(s.c_str()));        }    if(spfa(1))    {        int ans = -1;        for(int i = 1; i &lt;= n; ++i)            if(dis[i] &gt; ans &amp;&amp; dis[i] != INF)                ans = dis[i];        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
            <tag> 最短路のBellman-Ford </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1287 Networking</title>
      <link href="2019/04/06/POJ-1287-Networking/"/>
      <url>2019/04/06/POJ-1287-Networking/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点，m条边（两点间的路可能不止一条），求最小生成树</p></blockquote><a id="more"></a><p><img src="https://i.loli.net/2019/04/06/5ca88747dd41d.png" alt="传送门"></p><p><a href="http://poj.org/problem?id=1287" style="color:orange;" target="_blank" rel="noopener">传送门</a>  </p><h3 id="Code-of-Kruskal"><a href="#Code-of-Kruskal" class="headerlink" title="Code of Kruskal"></a>Code of Kruskal</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;///点的上限,因为RE我开大了int n, m, ans;int pre[N];int cnt;struct edge{    int there, here, w;}a[N * N];bool cmp(edge a, edge b){    return a.w &lt; b.w;}void init(){    ans = 0;    for(int i = 0; i &lt;= n; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}int unite(edge t){    int x = found(t.there);    int y = found(t.here);    if(x != y)    {        pre[y] = x;        return t.w;    }    return 0;}int main(){    while(~scanf(&quot;%d&quot;, &amp;n))    {        if(n == 0)            break;        scanf(&quot;%d&quot;, &amp;m);        init();        int b, c, d;        for(int i = 0; i &lt; m; ++i)            scanf(&quot;%d%d%d&quot;, &amp;a[i].there, &amp;a[i].here, &amp;a[i].w);        sort(a, a + m, cmp);        for(int i = 0; i &lt; m; ++i)            ans += unite(a[i]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-of-Prim"><a href="#Code-of-Prim" class="headerlink" title="Code of Prim"></a>Code of Prim</h3><blockquote><p>注意每两点间的路在记录时就选最短的</p></blockquote><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;///mmin以及mp的初始化const int N = 105;int n, m, ans;///三个基本数组bool vis[N];///是否入树int mp[N][N];///邻接矩阵存图int low[N];///low[i]已成图所有点到点i最小距离///n-1次循环的三部分:①找点②连入③更新void prim(){    ans = 0;    memset(vis, 0, sizeof(vis));    int mmin, pos = 1;    vis[1] = 1;    for(int i = 1; i &lt;= n; ++i)        low[i] = mp[pos][i];    int cnt = n;    while(--cnt)///n个点，连接 n - 1 条路    {        mmin = INF;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; low[i] &lt; mmin)///找未连入树的且离树最近的            {                mmin = low[i];///这段最小距离的权值                pos = i;///位置（哪个点）            }        ///if(mmin == INF)有时连不成树        vis[pos] = 1;        ans += mmin;        for(int i = 1; i &lt;= n; ++i)            if(!vis[i] &amp;&amp; low[i] &gt; mp[pos][i])                low[i] = mp[pos][i];    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        scanf(&quot;%d&quot;, &amp;m);        memset(mp, INF, sizeof(mp));        int b, c, d;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            if(mp[b][c] == INF)                mp[b][c] = mp[c][b] = d;            else            {                if(d &lt; mp[b][c])                    mp[b][c] = mp[c][b] = d;            }        }        prim();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最小生成树のKruskal </tag>
            
            <tag> 最小生成树のPrim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ACM-ICPC</title>
      <link href="2019/04/06/ACM-ICPC/"/>
      <url>2019/04/06/ACM-ICPC/</url>
      
        <content type="html"><![CDATA[<h1 id="ACM技能树"><a href="#ACM技能树" class="headerlink" title="ACM技能树"></a>ACM技能树</h1><div class="table-container"><table><thead><tr><th>算法分类</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>基本算法</td><td></td><td></td><td></td></tr><tr><td>搜索</td><td></td><td></td><td></td></tr><tr><td>动态规划</td><td></td><td></td><td></td></tr><tr><td>组合数学</td><td></td><td></td><td></td></tr><tr><td>计算几何</td><td></td><td></td><td></td></tr><tr><td>字符串</td><td></td><td></td><td></td></tr><tr><td>数论</td><td></td><td></td><td></td></tr><tr><td>图论</td><td></td><td></td><td></td></tr><tr><td>数据结构</td><td></td><td></td></tr></tbody></table></div><a id="more"></a><h2 id="1-基本算法"><a href="#1-基本算法" class="headerlink" title="1.基本算法"></a>1.基本算法</h2><div class="table-container"><table><thead><tr><th>算法名称</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>构造</td><td></td><td></td><td></td></tr><tr><td>枚举</td><td></td><td></td><td></td></tr><tr><td>模拟</td><td></td><td></td><td></td></tr><tr><td>贪心</td><td></td><td></td><td></td></tr><tr><td>分治</td><td></td><td></td><td></td></tr><tr><td>递归</td><td></td><td></td></tr></tbody></table></div><h2 id="2-搜索"><a href="#2-搜索" class="headerlink" title="2.搜索"></a>2.搜索</h2><div class="table-container"><table><thead><tr><th>算法名称</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>深度优先搜索（DFS）</td><td></td><td></td><td></td></tr><tr><td>广度优先搜索（BFS）</td><td></td><td></td><td></td></tr><tr><td>双向搜索</td><td></td><td></td><td></td></tr><tr><td>记忆化搜索</td><td></td><td></td><td></td></tr><tr><td>启发式搜索</td><td></td><td></td></tr></tbody></table></div><h2 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h2><div class="table-container"><table><thead><tr><th>算法名称</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>背包问题</td><td></td><td></td><td></td></tr><tr><td>数位DP</td><td></td><td></td><td></td></tr><tr><td>状态压缩DP</td><td></td><td></td><td></td></tr><tr><td>区间DP</td><td></td><td></td><td></td></tr><tr><td>树形DP</td><td></td><td></td><td></td></tr><tr><td>优化方法</td><td></td><td></td></tr></tbody></table></div><h3 id="动态规划之背包问题"><a href="#动态规划之背包问题" class="headerlink" title="动态规划之背包问题"></a>动态规划之背包问题</h3><div class="table-container"><table><thead><tr><th>背包分类</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>01背包</td><td></td><td></td><td></td></tr><tr><td>多重背包</td><td></td><td></td><td></td></tr><tr><td>完全背包</td><td></td><td></td></tr></tbody></table></div><h3 id="动态规划之优化方法"><a href="#动态规划之优化方法" class="headerlink" title="动态规划之优化方法"></a>动态规划之优化方法</h3><div class="table-container"><table><thead><tr><th>方法</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>滚动数组</td><td></td><td></td><td></td></tr><tr><td>二分优化</td><td></td><td></td><td></td></tr><tr><td>矩阵优化</td><td></td><td></td><td></td></tr><tr><td>斜率优化</td><td></td><td></td><td></td></tr><tr><td>四边形不等式优化</td><td></td><td></td><td></td></tr><tr><td>数据结构优化</td><td></td><td></td></tr></tbody></table></div><h2 id="4-组合数学"><a href="#4-组合数学" class="headerlink" title="4.组合数学"></a>4.组合数学</h2><div class="table-container"><table><thead><tr><th>算法名称</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>排列</td><td></td><td></td><td></td></tr><tr><td>组合</td><td></td><td></td><td></td></tr><tr><td>常用公式与定理</td><td></td><td></td><td></td></tr><tr><td>常见数列</td><td></td><td></td><td></td></tr><tr><td>递推方程</td><td></td><td></td><td></td></tr><tr><td>母函数</td><td></td><td></td><td></td></tr><tr><td>Polya计数</td><td></td><td></td><td></td></tr><tr><td>快速傅里叶（FFT）</td><td></td><td></td></tr></tbody></table></div><h3 id="组合数学之排列"><a href="#组合数学之排列" class="headerlink" title="组合数学之排列"></a>组合数学之排列</h3><div class="table-container"><table><thead><tr><th>排列分类</th><th>使用频率</th><th>了解程度</th><th>参考学习</th></tr></thead><tbody><tr><td>不可重排列</td><td></td><td></td><td></td></tr><tr><td>可重排列</td><td></td><td></td><td></td></tr><tr><td>圆排列</td><td></td><td></td><td></td></tr><tr><td>不尽相异元素全排列</td><td></td><td></td><td></td></tr><tr><td>多重集的排列</td><td></td><td></td></tr></tbody></table></div><h3 id="组合数学之组合"><a href="#组合数学之组合" class="headerlink" title="组合数学之组合"></a>组合数学之组合</h3><div class="table-container"><table><thead><tr><th style="text-align:center">组合分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">不可重组合</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">可重组合</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">不相邻组合</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">多重集的组合</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">大组合数取模</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="组合数学之常用公式与定理"><a href="#组合数学之常用公式与定理" class="headerlink" title="组合数学之常用公式与定理"></a>组合数学之常用公式与定理</h3><div class="table-container"><table><thead><tr><th style="text-align:center">公式定理</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">二项式定理</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">常见恒等式</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">鸽巢原理</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">容斥原理</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">帕斯卡恒等式</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">卢卡斯定理</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">错排问题</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="组合数学之常见数列"><a href="#组合数学之常见数列" class="headerlink" title="组合数学之常见数列"></a>组合数学之常见数列</h3><div class="table-container"><table><thead><tr><th style="text-align:center">数列</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">斐波那契数列</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">卡特兰数列</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="组合数学之递推方程"><a href="#组合数学之递推方程" class="headerlink" title="组合数学之递推方程"></a>组合数学之递推方程</h3><div class="table-container"><table><thead><tr><th style="text-align:center">递推方程</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">线性递推方程</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">非线性递推方程</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">BM算法</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="组合数学之母函数"><a href="#组合数学之母函数" class="headerlink" title="组合数学之母函数"></a>组合数学之母函数</h3><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">普通母函数</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指数型母函数</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="5-计算几何"><a href="#5-计算几何" class="headerlink" title="5.计算几何"></a>5.计算几何</h2><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">点与向量</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">点与线</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">多边形</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">圆形</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">凸包、误差处理</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">离散化</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">扫描线</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">半平面交</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">旋转卡壳</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="计算几何之点与向量"><a href="#计算几何之点与向量" class="headerlink" title="计算几何之点与向量"></a>计算几何之点与向量</h3><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">点与向量的表示</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">内积与外积</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">四则运算</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h3 id="计算几何之点与线"><a href="#计算几何之点与线" class="headerlink" title="计算几何之点与线"></a>计算几何之点与线</h3><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">直线与线段的表示</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">判断点与线的关系</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="计算几何之点与线之判断点与线的关系"><a href="#计算几何之点与线之判断点与线的关系" class="headerlink" title="计算几何之点与线之判断点与线的关系"></a>计算几何之点与线之判断点与线的关系</h4><div class="table-container"><table><thead><tr><th style="text-align:center">分类</th><th style="text-align:center">使用频率</th><th style="text-align:center">了解程度</th><th style="text-align:center">参考学习</th></tr></thead><tbody><tr><td style="text-align:center">点在直线上</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">两直线交点</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">点线距（直线）</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">点线距（线段）</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">点在线上的投影点</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">点在线段上</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">两线段相交</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML/CSS</title>
      <link href="2019/04/06/HTML-CSS/"/>
      <url>2019/04/06/HTML-CSS/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><blockquote><p>层叠样式表(英文全称:Cascading Style Sheets)是一种用来表现HTML(标准通用标记语言的一个应用)或XML(标准通用标记语言的一个子集)等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 </p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28285910&auto=1&height=66"></iframe><p><a href="https://baike.so.com/doc/1039566-1099520.html#1039566-1099520-7" style="color:red;" target="_blank" rel="noopener">More about CSS</a> </p><blockquote><p>这里研究超链接文字的颜色</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-css">&lt;a href=&quot;http://www.baidu.com&quot; style=&quot;color:red;&quot;&gt;内容&lt;/a&gt;</code></pre><p><strong>测试</strong></p><p><a href="http://www.runoob.com/css/css-tutorial.html" style="color:black;" target="_blank" rel="noopener">CSS教程</a></p><p><a href="http://www.runoob.com/cssref/css-colors.html" style="color:red;" target="_blank" rel="noopener">CSS颜色</a></p><p><a href="http://www.runoob.com/cssref/css-colornames.html" style="color:lawngreen;" target="_blank" rel="noopener">CSS颜色名称</a></p><p><a href="http://www.runoob.com/cssref/css-colors-legal.html" style="color:green;" target="_blank" rel="noopener">CSS合法颜色值</a></p><p><a href="http://www.runoob.com/cssref/css-colorsfull.html" style="color:yellow;" target="_blank" rel="noopener">CSS颜色十六进制值</a></p><p><a href="http://www.runoob.com/cssref/css3-browsersupport.html" style="color:blue;" target="_blank" rel="noopener">CSS颜色浏览器支持</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他语言のHTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZOJ 1060 Sorting It All Out</title>
      <link href="2019/04/06/ZOJ-1060-Sorting-It-All-Out/"/>
      <url>2019/04/06/ZOJ-1060-Sorting-It-All-Out/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点，m个关系描述</p><p>三种情况：</p><p>1.只用前几个关系即可排序</p><p>2.未完成排序就发现了矛盾</p><p>3.描述太少不能排序</p></blockquote><a id="more"></a><p><strong>Link</strong> <a href="http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=60" target="_blank" rel="noopener">http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=60</a></p><h3 id="拓扑排序（判环）"><a href="#拓扑排序（判环）" class="headerlink" title="拓扑排序（判环）"></a>拓扑排序（判环）</h3><blockquote><p>不同的是，此题要求排序是唯一的，排序不唯一视为不能排序</p></blockquote><pre><code class="lang-c++">for(int i = 0; i &lt; n; ++i)        if(!in[i] &amp;&amp; flag[i])///入度为0且被提到的字符才可入队            q.push(i);    while(q.size())    {        if(q.size() &gt; 1)///最初入队数&gt;1则排序不唯一            sign = 1;</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;///n个点， m个关系描述int in[30];int real_in[30];int node_num;///已有点bool flag[30];///所涉字符bool vis_sort;///明确答案（排序完毕）bool vis_conflict;///明确答案（明确矛盾）bool sign;///能排序但不唯一 即 不能排序int step_sort;int step_conflict;vector&lt;int&gt; v[30];vector&lt;int&gt; ans;void bfs(int step){    sign = 0;    ans.clear();    for(int i = 0; i &lt; n; ++i)        in[i] = real_in[i];    queue&lt;int&gt; q;    for(int i = 0; i &lt; n; ++i)        if(!in[i] &amp;&amp; flag[i])///入度为0且被提到的字符才可入队            q.push(i);    int sum = 0;///入队节点数    while(q.size())    {        if(q.size() &gt; 1)///最初入队数&gt;1则排序不唯一            sign = 1;        int tem = q.front();        ans.push_back(tem);        sum++;        if(sum == n)            if(!sign)            {                vis_sort = 1;///找到(唯一的)答案                step_sort = step;            }        q.pop();        for(int i = 0; i &lt; v[tem].size(); ++i)        {            in[ v[tem][i] ]--;///入度少的先排在前面，入度多的后放            if(in[ v[tem][i] ] == 0)                q.push(v[tem][i]);        }    }    if(sum != node_num)    {        vis_conflict = 1;        step_conflict = step;    }    return ;}int main(){    while(cin &gt;&gt; n &gt;&gt; m)    {        vis_sort = 0;///是否找到答案        vis_conflict = 0;///是否确定矛盾        node_num = 0;        memset(real_in, 0, sizeof(real_in));        memset(flag, 0, sizeof(flag));        for(int i = 0; i &lt; 30; ++i)            v[i].clear();        ans.clear();        if(n == 0 &amp;&amp; m == 0)            break;        string s;        for(int i = 1; i &lt;= m; ++i)        {            cin &gt;&gt; s;            if(vis_conflict || vis_sort)///明确矛盾后只顾完成输入即可                continue;            int a = s[0] - &#39;A&#39; ;///字符映射到 0 ~ n - 1            if(!flag[a])            {                node_num++;                flag[a] = 1;            }            int b = s[2] - &#39;A&#39; ;            if(!flag[b])            {                node_num++;                flag[b] = 1;            }            v[a].push_back(b);            real_in[b]++;            bfs(i);        }        if(vis_conflict)            printf(&quot;Inconsistency found after %d relations.\n&quot;, step_conflict);        else if(vis_sort)        {            printf(&quot;Sorted sequence determined after %d relations: &quot;, step_sort);            int sz = ans.size();            for(int i = 0; i &lt; sz; ++i)                cout &lt;&lt; char(ans[i] + 65);            cout &lt;&lt; &#39;.&#39; &lt;&lt; &#39;\n&#39;;        }        else            cout &lt;&lt; &quot;Sorted sequence cannot be determined.&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>多次增删，代码已不再精简，建议看以下代码</p><p><a href="https://blog.csdn.net/qq_33132383/article/details/70198616" style="color:green;" target="_blank" rel="noopener">Someone’s code</a></p></blockquote><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;vector&gt;#define MM(s,q) memset(s,q,sizeof(s))#define INF 0x3f3f3f3f#define MAXN 100005#define Lchild id&lt;&lt;1#define Rchild (id&lt;&lt;1)+1using namespace std;int in[MAXN], In[MAXN], flag,  vis[30], finish, wrong;char s[10];string ans;vector&lt;int&gt; vec[60];void topsort(int n, int t) {    for (int i = 1; i &lt;= n; i++) in[i] = In[i];    int  cnt = 0; // 已经出现的数目    queue&lt;int&gt; Q;    for (int i = 1; i &lt;= n; i++)        if (vis[i]) {            cnt++;            if (in[i] == 0) Q.push(i);        }    int num = 0, sign = 0; // num-&gt;拓扑排序中出现的元素个数    while (!Q.empty()) {        if (Q.size() &gt; 1) sign = 1; // 这次拓扑排序序列不唯一        int u = Q.front();        num++;        Q.pop();        ans[num - 1] = (char)(u - 1 + &#39;A&#39;);        for (int i = 0; i &lt; vec[u].size(); i++) {            int v = vec[u][i];            in[v]--;            if (in[v] == 0) Q.push(v);        }    }    ans[num] = &#39;\0&#39;;    if (num &lt; cnt) { // 出现环        flag = 1, wrong = t;        return;    }    if (sign == 1) return; // 不确定    if (cnt == n)  // 序列唯一        flag = 1, finish = t;}int main() {    int n, m, a, b;    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) {        MM(In, 0);        MM(vis, 0);        flag = finish = wrong = 0;        for (int i = 1; i &lt;= n; i++)vec[i].clear();        for (int i = 1; i &lt;= m; i++) {            scanf(&quot;%s&quot;, s);            a = s[0] - &#39;A&#39; + 1, b = s[2] - &#39;A&#39; + 1;            vis[a] = vis[b] = 1;            vec[a].push_back(b);            In[b]++;            if (flag == 0)  // 还没有结果                topsort(n, i);        }        if (finish) printf(&quot;Sorted sequence determined after %d relations: %s.\n&quot;, finish, ans.c_str());        else if (wrong) printf(&quot;Inconsistency found after %d relations.\n&quot;, wrong);        else printf(&quot;Sorted sequence cannot be determined.\n&quot;);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 图论の拓扑排序(判环) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>睡前小故事</title>
      <link href="2019/04/05/%E7%9D%A1%E5%89%8D%E5%B0%8F%E6%95%85%E4%BA%8B/"/>
      <url>2019/04/05/%E7%9D%A1%E5%89%8D%E5%B0%8F%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="小葵花妈妈课堂开课了：孩子不听故事睡不着怎么办？多半是惯的，打一顿就好…"><a href="#小葵花妈妈课堂开课了：孩子不听故事睡不着怎么办？多半是惯的，打一顿就好…" class="headerlink" title="小葵花妈妈课堂开课了：孩子不听故事睡不着怎么办？多半是惯的，打一顿就好…"></a>小葵花妈妈课堂开课了：孩子不听故事睡不着怎么办？多半是惯的，打一顿就好…</h3><a id="more"></a><blockquote><p>热心父母追问：因为他睡不着，专门去给他买了安眠药，嘱咐他按时吃，结果过去看他还没吃药就睡着了，请问这种情况怎么办？</p><p>回答：不吃药怎么能行！赶快叫醒他，待他清醒了赶快吃上安眠药，估计就能睡个好觉了…</p><p>追问：明白了，谢谢您！</p></blockquote><h3 id="睡前小故事"><a href="#睡前小故事" class="headerlink" title="睡前小故事"></a>睡前小故事</h3><blockquote><p>①从前有个少年，他懵懂无知，他太过自我……他觉得自己独一无二，觉得自己与众不同，觉得自己能屈能伸，觉得自己张弛有度……看，原来这是一个自恋的人，无自知之明，妄自菲薄，自命不凡，活在自己的世界里。不过也有好的一面，自恋也是自信啊，他在思修课上做了一次演讲（脱稿，想到啥说啥的那种），完全是为了锻炼自己，那一刻，我很崇拜他，要是搁以前，他在众人面前做学习经验总结，照着稿子念都念不清楚。所以，我还是挺喜欢他的，毕竟他在努力改变、提升自己。</p><p>②某一天，他遇上了一个女生，深得他心。他变了……他不再那么自信，反而多了些自卑，突然发现自身有那么多缺点，而她那么耀眼，他想：他们，怎么可能……看到他的变化，我想起了不知从哪儿听到的一句话：之前他总是一个人，无所忧虑，无所畏惧，如同刀枪不入，故所向披靡、孤独求败。可当他有了所爱之人，就有了牵挂，就有了软肋，浑身的缺点都就暴露出来了，有时竟经不起风吹……</p><p>③他远远地看着她，满心欢喜，扬起手来想跟她打招呼，可他迟疑了，为什么？是怕打扰到她吧。或许她在忙，跟她打了招呼怕是会耽误她的时间，而这是他所不愿看到的。过了很久很久，他熬不住了（其实在我看来也没多久，只是过程之煎熬使他度日如年），他想跟她说句话，哪怕只是一两句。他又扬起手来，可是，他又迟疑了：我是思念她、需要她，可是她并不思念我啊，她也并不是有多需要我，否则她又怎会从未跟我打过招呼……(嗯，她是他的单曲循环，他是她的随机播放……)</p><p>④他有些痛苦，他觉得委屈。他放下了胳膊低下了头，叹了口气回了首，失望地看着来时的路。在路的开头，有两个佝偻的身影，像是互相搀扶着，他们也扬着胳膊，就像他一样，只不过他们太久没有放下，手臂显得僵直了。（原来……他们为什么不直接……难道是……怕耽误我时间！……又觉得我并不是很需要他们，并没有多想他们……可是，我竟从未发现……）他流着鼻涕抽搐着嘴，越看越模糊，模糊到只剩两个黑点……</p><p>⑤那一幕，就像梦一样不真实，却又真实地不像梦……</p></blockquote><p><img src="https://i.loli.net/2019/04/05/5ca744f73b081.jpg" alt="目送"></p><p><strong>嗯，他常常为挣钱而发愁，却总是劝你在外边多吃自己爱吃的，不要怕花钱。她记性越来越差，却清楚地记得你爱吃的小吃，总想着把它们带给你，你挑食，她累了一天了，在做饭时还单独做你喜欢的。</strong></p><h3 id="附龙应台《目送》片段"><a href="#附龙应台《目送》片段" class="headerlink" title="附龙应台《目送》片段"></a>附龙应台《目送》片段</h3><blockquote><p>①华安上小学第一天，我和他手牵着手，穿过好几条街，到维多利亚小学。很多很多的孩子，在操场上等候上课的第一声铃响。小小的手，圈在爸爸的、妈妈的手心里，怯怯的眼神，打量着周遭。他们是幼儿园的毕业生，但是他们还不知道一个定律：一件事情的毕业，永远是另一件事情的开启。</p><p>②铃声一响，顿时人影错杂，奔往不同方向，但是在纷乱的人群里，我无比清楚地看着自己孩子的背影－－就好像在一百个婴儿同时哭声大作时，你仍旧能够准确听出自己那一个的位置。华安背着一个彩色的书包往前走，但是他不断地回头；好像穿越一条无边无际的时空长河，他的视线和我凝望的眼光隔空交会。我看着他瘦小的背影消失在门里。</p><p>③十六岁，他到美国作交换生一年。我送他到机场。告别时，照例拥抱，我的头只能贴到他的胸口，好像抱住了长颈鹿的脚。他很明显地在勉强忍受母亲的深情。</p><p>④他在长长的行列里，等候护照检验；我就站在外面，用眼睛跟着他的背影一寸一寸往前挪。终于轮到他，在海关窗口停留片刻，然后拿回护照，闪入一扇门，倏乎不见。</p><p>⑤我一直在等候，等候他消失前的回头一瞥。但是他没有，一次都没有。</p><p>⑥现在他二十一岁，上的大学，正好是我教课的大学。但即使是同路，他也不愿搭我的车。即使同车，他戴上耳机──只有一个人能听的音乐，是一扇紧闭的门。有时他在对街等候公交车，我从高楼的窗口往下看：一个高高瘦瘦的青年，眼睛望向灰色的海；我只能想象，他的内在世界和我的一样波涛深邃，但是，我进不去。一会儿公交车来了，挡住了他的身影。车子开走，一条空荡荡的街，只立着一只邮筒。</p><p>⑦我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。</p><p>⑧我慢慢地、慢慢地意识到，我的落寞，彷佛和另一个背影有关。</p><p>⑨博士学位读完之后，我回台湾教书。到大学报到第一天，父亲用他那辆运送饲料的廉价小货车长途送我。他没开到大学正门口，而是停在侧门的窄巷边。卸下行李之后，他爬回车内，准备回去，明明启动了引擎，却又摇下车窗，头伸出来说：女儿，爸爸觉得很对不起你，这种车子实在不是送大学教授的车子。</p><p>⑩我看着他的小货车小心地倒车，然后噗噗驶出巷口，留下一团黑烟。直到车子转弯看不见了，我还站在那里，一口皮箱旁。</p><p>(11)每个礼拜到医院去看他，是十几年后的时光了。推着他的轮椅散步，他的头低垂到胸口。有一次，发现排泄物淋满了他的裤腿，我蹲下来用自己的手帕帮他擦拭，裙子也沾上了粪便，但是我必须就这样赶回台北上班。护士接过他的轮椅，我拎起皮包，看着轮椅的背影，在自动玻璃门前稍停，然后没入门后。</p><p>(12)火葬场的炉门前，棺木是一只巨大而沉重的抽屉，缓缓往前滑行。没有想到可以站得那么近，距离炉门也不过五公尺。雨丝被风吹斜，飘进长廊内。我掠开雨湿了前额的头发，深深、深深地凝望，希望记得这最后一次的目送。</p><p>(13)我慢慢地、慢慢地了解到，所谓父女母子一场，只不过意味着，你和他的缘分就是今生今世不断地在目送他的背影渐行渐远。你站立在小路的这一端，看着他逐渐消失在小路转弯的地方，而且，他用背影默默告诉你：不必追。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1251 Jungle roads</title>
      <link href="2019/04/03/POJ-1251-Jungle-roads-0/"/>
      <url>2019/04/03/POJ-1251-Jungle-roads-0/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>左侧图显示当前所有使用中的道路，以及现在每月的维护费用。当然，村庄之间必需有一些公路能够相通，即使路线并不像以前一样短。怎样才使每月的花费最小，并且所维持的道路，将连接所有村庄。 </p></blockquote><a id="more"></a><p><strong>Link</strong> <a href="http://poj.org/problem?id=1251" target="_blank" rel="noopener">http://poj.org/problem?id=1251</a></p><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><blockquote><p>并查集 + sort(edge, edge + cnt, cmp) = Kruskal</p><p>结构体存边：遍历每条边，unite每条边的两点</p></blockquote><h3 id="Code-of-Kruskal"><a href="#Code-of-Kruskal" class="headerlink" title="Code of Kruskal"></a>Code of Kruskal</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 30;int n;///n个点int ans;int pre[N];int cnt;struct edge{    int there, here, w;} a[1005];bool cmp(edge a, edge b){    return a.w &lt; b.w;}void init(){    cnt = 0;    ans = 0;    for(int i = 0; i &lt;= n; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}int unite(edge t){    int x = found(t.there);    int y = found(t.here);    if(x != y)    {        pre[y] = x;        return t.w;    }    return 0;}int main(){///    cout &lt;&lt; int(&#39;A&#39;) &lt;&lt; &#39;\n&#39;;    65///    cout &lt;&lt; &#39;A&#39; - 64 &lt;&lt; &#39;\n&#39;;    1    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {//        getchar();        init();        for(int i = 1; i &lt; n; ++i)        {            char now, nxt;            int num, w;//            scanf(&quot;%c%d&quot;, &amp;now, &amp;num);//            getchar();            cin &gt;&gt; now &gt;&gt; num;            while(num--)            {//                scanf(&quot;%c%d&quot;, &amp;nxt, &amp;w);//                getchar();                cin &gt;&gt; nxt &gt;&gt; w;                a[cnt].there = now - 65;                a[cnt].here = nxt - 65;                a[cnt++].w = w;            }        }        sort(a, a + cnt, cmp);        for(int i = 0; i &lt; cnt; ++i)///遍历所有边            ans += unite(a[i]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>对于这个题，用scanf输入总会RE，非法内存访问？cin一次过</p></blockquote><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><blockquote><p>查找部分类似Dijkstra</p><p>邻接矩阵存边：遍历每个点，依次连接</p><p>注意图是双向的！</p><p>邻接矩阵存边: 注定遍历“点”（某些算法所必需）</p><p>结构体存边: 注定遍历“边”（高效）</p></blockquote><h3 id="Code-of-Prim"><a href="#Code-of-Prim" class="headerlink" title="Code of Prim"></a>Code of Prim</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;int n;///点的个数bool vis[30];int mp[30][30], low[30];///low[i]表示已成图所有点到点i的最小权值void prim(){    int ans = 0;    memset(vis, 0, sizeof(vis));    int pos = 1;///起点    vis[1] = 1;    for(int i = 1; i &lt;= n; ++i)///更新当前检测点到其他所有点的最小距离        low[i] = mp[pos][i];    int cnt = n;    while(--cnt)///n个点，循环n-1次,一次不能多    {        int mmin = INF;        for(int i = 1; i &lt;= n; ++i)///类dijkstra查找            if(vis[i] == 0 &amp;&amp; low[i] &lt; mmin)///未连接入图且...            {                mmin = low[i];                pos = i;            }///     if(mmin == INF)有些题不能连成树        vis[pos] = 1;///连入图并更新已成图所有点到其他所有点的最小距离        ans += mmin;        for(int i = 1; i &lt;= n; ++i)        {            if(vis[i] == 0 &amp;&amp; low[i] &gt; mp[pos][i])                low[i] = mp[pos][i];        }    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        memset(mp, INF, sizeof(mp));        for(int i = 1; i &lt; n; ++i)        {            char now, nxt;            int num, w;            cin &gt;&gt; now &gt;&gt; num;            while(num--)            {                cin &gt;&gt; nxt &gt;&gt; w;                mp[now - 64][nxt - 64] = w;///点为1~n                mp[nxt - 64][now - 64] = w;///点为1~n            }        }        prim();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最小生成树のKruskal </tag>
            
            <tag> 最小生成树のPrim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>带权并查集</title>
      <link href="2019/04/01/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2019/04/01/%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="HihoCoder"><a href="#HihoCoder" class="headerlink" title="HihoCoder"></a>HihoCoder</h3><blockquote><p>小Hi的学校总共有N名学生，编号1-N。学校刚刚进行了一场全校的古诗文水平测验。  </p><p>学校没有公布测验的成绩，所以小Hi只能得到一些小道消息，例如X号同学的分数比Y号同学的分数高S分。  </p><p>小Hi想知道利用这些消息，能不能判断出某两位同学之间的分数高低？</p></blockquote><a id="more"></a><p><strong>Link</strong> <a href="http://hihocoder.com/problemset/problem/1515" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1515</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>第一行包含三个整数N, M和Q。N表示学生总数，M表示小Hi知道消息的总数，Q表示小Hi想询问的数量。  </p><p>以下M行每行三个整数，X, Y和S。表示X号同学的分数比Y号同学的分数高S分。  </p><p>以下Q行每行两个整数，X和Y。表示小Hi想知道X号同学的分数比Y号同学的分数高几分。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对于每个询问，如果不能判断出X比Y高几分输出-1。否则输出X比Y高的分数。 </p></blockquote><h3 id="sample-Input"><a href="#sample-Input" class="headerlink" title="sample Input"></a>sample Input</h3><pre><code class="lang-c++">10 5 3  1 2 10  2 3 10  4 5 -10  5 6 -10  2 5 10  1 10  1 5  3 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>-1</p><p>20</p><p>0</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, q;int pre[N];int val[N];void init(){    for(int i = 0; i &lt;= n; ++i)    {        pre[i] = i;        val[i] = 0;    }}int found(int x){    if(x == pre[x])        return x;    int tem = pre[x];    pre[x] = found(pre[x]);    val[x] = val[x] + val[ tem ];    return pre[x];}void unite(int x, int y, int s){    int xx = found(x);    int yy = found(y);    if(xx != yy)        pre[yy] = xx;    val[yy] = s + val[x] - val[y];///类似向量}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q))    {        init();        int x, y, s;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;s);            unite(x, y, s);        }        while(q--)        {            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);            int xx = found(x);            int yy = found(y);            if(xx != yy)                cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; val[y] - val[x] &lt;&lt; &#39;\n&#39;;///x离其公共祖先近,val[x]更小        }    }    return 0;}</code></pre><h3 id="关于Found递归函数的探索"><a href="#关于Found递归函数的探索" class="headerlink" title="关于Found递归函数的探索"></a>关于Found递归函数的探索</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;int n, m, q;int pre[N];int val[N];void init(){    for(int i = 0; i &lt;= n; ++i)    {        pre[i] = i + 1;        val[i] = 1;    }    pre[n] = n;    val[n] = 0;}int found(int x){    cout &lt;&lt; &quot;x : &quot; &lt;&lt; x &lt;&lt; &#39;\n&#39;;    if(x == pre[x])        return x;    int tem = pre[x];    cout &lt;&lt; x &lt;&lt; &quot;&#39;s initial pre is &quot; &lt;&lt; tem &lt;&lt; &#39;\n&#39;;    pre[x] = found(pre[x]);///程序返回后向下运行    cout &lt;&lt; x &lt;&lt; &quot;&#39;s final pre is &quot; &lt;&lt; pre[x] &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;initial val[&quot; &lt;&lt; x &lt;&lt; &quot;] : &quot; &lt;&lt; val[x] &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;now val[&quot; &lt;&lt; tem &lt;&lt; &quot;] : &quot; &lt;&lt; val[tem] &lt;&lt; &#39;\n&#39;;    val[x] = val[x] + val[ tem ];    cout &lt;&lt; &quot;val[&quot; &lt;&lt; x &lt;&lt; &quot;] : &quot; &lt;&lt; val[x] &lt;&lt; &#39;\n&#39;;    return pre[x];}//int found(int x)//{//    if(x == pre[x])//        return x;////    int tem = pre[x];////    pre[x] = found(pre[x]);///向里递归，压缩每个节点的路径////    val[x] = val[x] + val[ tem ];///向外return，更新每个节点的val//    return pre[x];//}int main(){    n = 5;    init();    for(int i = 0; i &lt;= 5; ++i)        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; pre[i] &lt;&lt; &#39; &#39; &lt;&lt; val[i] &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; found(0) &lt;&lt; &#39;\n&#39;;}</code></pre><p><img src="https://i.postimg.cc/BQq73Nw1/JI7-WBXYFI15-I-B4-HQOJH7.jpg" alt="递归"></p><blockquote><p>妙不可言…</p><p><del>戴荃并查集：我要,这铁棒有何用？我要，这变化又如何？</del></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2236 The Suspects HDU 1213 How Many Tables</title>
      <link href="2019/03/31/POJ-2236-The-Suspects-HDU-1213-How-Many-Tables/"/>
      <url>2019/03/31/POJ-2236-The-Suspects-HDU-1213-How-Many-Tables/</url>
      
        <content type="html"><![CDATA[<h3 id="The-Suspects"><a href="#The-Suspects" class="headerlink" title="The Suspects"></a>The Suspects</h3><blockquote><p>n个人（0  ~  n-1）m个小组</p><p>起初0是嫌疑人，与0共组的人都是嫌疑人，与嫌疑人共组的人也都是嫌疑人</p><p>问有多少嫌疑人</p></blockquote><a id="more"></a><p><strong>Link</strong> <a href="http://poj.org/problem?id=1611" target="_blank" rel="noopener">http://poj.org/problem?id=1611</a></p><h3 id="Code-并查集模板"><a href="#Code-并查集模板" class="headerlink" title="Code(并查集模板)"></a>Code(并查集模板)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 30005;int pre[N];int n, m;void init(){    for(int i = 0; i &lt; n; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)//        x = pre[y];///可笑...        pre[y] = x;    return ;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        if(n == 0 &amp;&amp; m == 0)            break;        init();        while(m--)        {            int tem, t, first;            scanf(&quot;%d&quot;, &amp;tem);            scanf(&quot;%d&quot;, &amp;first);            while(--tem)            {                scanf(&quot;%d&quot;, &amp;t);                unite(first, t);            }        }        int standard = found(0);        int ans = 0;        for(int i = 0; i &lt; n; ++i)        {            if(found(i) == standard)                ans++;        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }}</code></pre><h3 id="How-many-tables"><a href="#How-many-tables" class="headerlink" title="How many tables"></a>How many tables</h3><blockquote><p>n个人（1~n）m个关系</p><p>认识的人坐一桌，最少需要几桌</p><p>我认识我朋友，我朋友认识他三姨夫，那么我和我朋友的三姨夫彼此认识？？？</p></blockquote><p><strong>Link</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1213" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1213</a></p><h3 id="Code（并查集模板）"><a href="#Code（并查集模板）" class="headerlink" title="Code（并查集模板）"></a>Code（并查集模板）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 1005;int pre[N];bool vis[N];int n, m;void init(){    for(int i = 0; i &lt;= n; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[x] = y;    return ;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        memset(vis, 0, sizeof(vis));        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        init();///最初在主函数里忘写了，后来有写在n被赋值之前...        int there, here;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            unite(there, here);        }        int ans = 0;        for(int i = 1; i &lt;= n; ++i)            if(!vis[ found(i) ])            {                vis[ found(i) ] = 1;                ans++;            }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1860 Currency Exchange</title>
      <link href="2019/03/31/POJ-1860-Currency-Exchange/"/>
      <url>2019/03/31/POJ-1860-Currency-Exchange/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点m个关于路的叙述</p><p>起点start 初始钱币ini</p><p>此 彼    此-&gt;彼汇率  手续费    彼到此汇率  手续费</p></blockquote><a id="more"></a><p><strong>The link of this problem</strong> <a href="http://poj.org/problem?id=1860" target="_blank" rel="noopener">http://poj.org/problem?id=1860</a></p><h3 id="最短路变形"><a href="#最短路变形" class="headerlink" title="最短路变形"></a>最短路变形</h3><blockquote><p>“最远路”</p><p>Bellman-Ford 判 正权环</p></blockquote><h3 id="Code-of-Bellman-Ford"><a href="#Code-of-Bellman-Ford" class="headerlink" title="Code of Bellman-Ford"></a>Code of Bellman-Ford</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;///点的上界const int inf = 0x3f3f3f3f;int cnt;///边的计数struct edge///Bellman-Ford 算法暴力遍历双向边,无pre{    int from, to;    double w, cost;} a[N &lt;&lt; 1]; ///等同于邻接矩阵了int n, m;///n为点的个数（注意编号是0 ~ n - 1还是1 ~ n），m为双向边的描述double dis[N];///起点到某点的等效最短路(抄模板时顺手写了int)double ini;void add(int from, int to, double w, double cost){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].cost = cost;    cnt++;}bool Bellman_Ford(int start){    memset(dis, 0, sizeof(dis));    dis[start] = ini;///自己换自己 1 : 1    int tot = n - 1;    while(tot--)///n个点，n次松弛    {        bool flag = 0;///优化        for(int i = 0; i &lt; cnt; ++i)///对所有边            if(dis[ a[i].to ] &lt; (dis[ a[i].from ] - a[i].cost) * a[i].w)            {                flag = 1;                dis[ a[i].to ] = (dis[ a[i].from ] - a[i].cost) * a[i].w;            }        if(!flag)            break;    }    for(int i = 0; i &lt; cnt; ++i)        if(dis[ a[i].to ] &lt; (dis[ a[i].from ] - a[i].cost) * a[i].w)            return 1;///有正权环    return 0;}int main(){    int start;//    while(~scanf(&quot;%d%d%d%lf&quot;, &amp;n, &amp;m, &amp;start, &amp;ini))    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; start &gt;&gt; ini)    {        cnt = 0;        int b, c;        double d, e, f, g;        for(int i = 0; i &lt; m; ++i)        {//            scanf(&quot;%d%d%lf%lf%lf%lf&quot;, &amp;b, &amp;c, &amp;d, &amp;e, &amp;f, &amp;g);            cin &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g;            add(b, c, d, e);            add(c, b, f, g);///Debug一小时最后发现错把b写成d!!!!!!!!        }        if(Bellman_Ford(start))            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のBellman-Ford </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2240 Arbitrage</title>
      <link href="2019/03/31/POJ-2240-Arbitrage/"/>
      <url>2019/03/31/POJ-2240-Arbitrage/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>存在多种货币，给出它们兑换时的汇率，问是否存在一种货币，经过多次兑换，最终换回自己时钱多了……</p></blockquote><a id="more"></a><p><strong>The link of the problem</strong> <a href="http://poj.org/problem?id=2240" target="_blank" rel="noopener">http://poj.org/problem?id=2240</a></p><h3 id="最短路变形"><a href="#最短路变形" class="headerlink" title="最短路变形"></a>最短路变形</h3><blockquote><p>广义最短路: 存在多个状态，从此状态到彼状态的最优过渡方案</p><p>另外，用map从string映射到int</p></blockquote><h3 id="Code-of-Floyd"><a href="#Code-of-Floyd" class="headerlink" title="Code of Floyd"></a>Code of Floyd</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;///最短路:存在多个状态，从此状态到彼状态的最优过渡方案int n, m, num = 1;double dis[44][44];void floyd(){    for(int k = 0; k &lt; n; ++k)        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; n; ++j)///距离用+汇率用*                if(dis[i][j] &lt; dis[i][k] * dis[k][j])                    dis[i][j] = dis[i][k] * dis[k][j];}int main(){    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        map&lt;string, int&gt; mp;        string s;        for(int i = 0; i &lt; n; ++i)        {            cin &gt;&gt; s;            mp[s] = i;        }        memset(dis, 0, sizeof(dis));///初始化为0表示两货币无法兑换        for(int i = 0; i &lt; n; ++i)            dis[i][i] = 1;///自身换自身 1: 1        scanf(&quot;%d&quot;, &amp;m);        string a, b;        double tra;        for(int i = 0; i &lt; m; ++i)        {            cin &gt;&gt; a &gt;&gt; tra &gt;&gt; b;            dis[ mp[a] ][ mp[b] ] = tra;///单向路        }        floyd();        bool flag = 0;        for(int i = 0; i &lt; n; ++i)        {            if(dis[i][i] &gt; 1)            {                flag = 1;                break;            }        }        if(flag)            printf(&quot;Case %d: Yes\n&quot;, num++);        else            printf(&quot;Case %d: No\n&quot;, num++);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2236 Wireless Network</title>
      <link href="2019/03/30/POJ-2236-Wireless-Network/"/>
      <url>2019/03/30/POJ-2236-Wireless-Network/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n台坏掉的电脑（1~N），一个限制距离d</p><p>n个坐标（1~N），两种操作（O x 表示修复第x台电脑）（S x y表示询问：第x与第y台电脑能否直接或间接相连）</p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2236" target="_blank" rel="noopener">http://poj.org/problem?id=2236</a></p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><blockquote><p>不过用 while(ch = getchar()) 超时，用while(cin &gt;&gt; ch)就过，前者读不到EOF？</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const double eps = 1e-6;int n, d;int pre[1005];bool vis[1005];///修没修int x[1005];int y[1005];void init()///初始化顶级是自身{    for(int i = 0; i &lt;= n; ++i)        pre[i] = i;}int found(int x){    if(x != pre[x])        pre[x] = found(pre[x]);///路径压缩    return pre[x];}void unite(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)        pre[y] = x;    return ;}bool check(int a, int b){    if((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]) &lt;= d * d)        return 1;    return 0;}int main(){    ///全局处的n我又在主函数里定义了！！！    scanf(&quot;%d%d&quot;, &amp;n, &amp;d);    init();///勿忘在主函数里调用(而且是在n输入后调用！！！)    for(int i = 1; i &lt;= n; ++i)        scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]);    getchar();///涉及字符输入注意吃回车    char ch;    vector&lt;int&gt; vec;//    while(ch = getchar())    while(cin &gt;&gt; ch)    {        if(ch == &#39;O&#39;)        {            int tem;            scanf(&quot;%d&quot;, &amp;tem);            getchar();            vis[tem] = 1;            for(int i = 1; i &lt;= n; ++i)                if(vis[i] &amp;&amp; i != tem &amp;&amp; check(i, tem))                    unite(i, tem);///tem与所有修好的点联合一遍        }        else if(ch == &#39;S&#39;)        {            int there, here;            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            getchar();            int p = found(there);            int q = found(here);            if(p == q)                cout &lt;&lt; &quot;SUCCESS&quot; &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;FAIL&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 1797 Heavy Transportation</title>
      <link href="2019/03/29/POJ-1797-Heavy-Transportation/"/>
      <url>2019/03/29/POJ-1797-Heavy-Transportation/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>n个点，m个关于边的叙述（边的权值代表路的最大承载量）</p><p>求从1到n，路上的最大承载量</p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=1797" target="_blank" rel="noopener">http://poj.org/problem?id=1797</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>最短路变形</p><p>最大化最小值：</p><p>两条路：</p><ol><li><p>当前直达</p></li><li><p>中转</p><p>择优（承载量大的那条）</p></li></ol><p>这里有个相反的：最小化最大值： <a href="https://fireworks99.github.io/2019/03/28/POJ-2253-Frogger/" target="_blank" rel="noopener">https://fireworks99.github.io/2019/03/28/POJ-2253-Frogger/</a></p></blockquote><h3 id="Code-of-Dijkstra"><a href="#Code-of-Dijkstra" class="headerlink" title="Code of Dijkstra"></a>Code of Dijkstra</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;#define check cout &lt;&lt; &quot;Let&#39;s check : &quot; &lt;&lt; &#39;\n&#39;;const int INF = 0x3f3f3f3f;const int N = 1010;///点 的上限int n, m;bool vis[N];///是否用过它int mp[N][N];int dis[N];void dijkstra(int start){    memset(vis, 0, sizeof(vis));    memset(dis, -1, sizeof(dis));    for(int i = 1; i &lt;= n; ++i)///邻接表下的dijkstra要先处理start        dis[i] = mp[start][i];    vis[start] = 1;    for(int i = 1; i &lt;= n; ++i)    {        int mmax = -1;        int pos;        for(int j = 1; j &lt;= n; ++j)///++j写成了++i...卡了半天            if(!vis[j] &amp;&amp; dis[j] &gt; mmax)            {                pos = j;                mmax = dis[j];            }        vis[pos] = 1;        for(int j = 1; j &lt;= n; ++j)        {            if(vis[j])///用过的点直接跳过                continue;            if(dis[j] &lt; min(dis[pos], mp[pos][j]))                dis[j] = min(dis[pos], mp[pos][j]);        }    }}int main(){    int t;    cin &gt;&gt; t;    int tem = t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int b, c, d;        memset(mp, -1, sizeof(mp));///邻接表要初始化        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            mp[b][c] = mp[c][b] = d;        }        dijkstra(1);        printf(&quot;Scenario #%d:\n%d\n\n&quot;, tem - t, dis[n]);    }    return 0;}</code></pre><h3 id="Code-of-spfa"><a href="#Code-of-spfa" class="headerlink" title="Code of spfa"></a>Code of spfa</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 1010;///点 的上限int n, m;bool vis[N];///vis[i] = 1表示点在队列里，0表示不在int dis[N];///从起点到某点（答案意义上的）“最短”距离int cnt, head[N];struct edge{    int from, to, w, pre;} a[N * N];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].to = from;    a[cnt].from = to;    a[cnt].w = w;    a[cnt].pre = head[to];    head[to] = cnt;    cnt++;}void spfa(int start){    memset(vis, 0, sizeof(vis));    memset(dis, -1, sizeof(dis));    dis[start] = INF;    vis[start] = 1;    queue&lt;int&gt; q;    q.push(start);    while(q.size())    {        int first = q.front();///当前检测点用作“中转点”        q.pop();        vis[first] = 0;        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            ///最大化最小值：选择（“最短直接”到）与（中转到）更大的那条路            ///即有多条路时选最优的            if(dis[t] &lt; min(dis[first], a[i].w))            {                dis[t] = min(dis[first], a[i].w);                q.push(t);                vis[t] = 1;            }        }    }}int main(){    int t;    cin &gt;&gt; t;    int tem = t;    while(t--)    {        cnt = 0;        memset(head, -1, sizeof(head));        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        int b, c, d;        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }        spfa(1);        printf(&quot;Scenario #%d:\n%d\n\n&quot;, tem - t, dis[n]);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3268 Silver Cow Party</title>
      <link href="2019/03/28/POJ-3268-Silver-Cow-Party/"/>
      <url>2019/03/28/POJ-3268-Silver-Cow-Party/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>有n个农场（1~N），给出M条单向路描述。每个农场派出一头牛去某个农场（X）参加聚会，聚会结束后要返回，当然它们来回都选择最短路（因为路是单向的，来回可能路径不同），问这n头牛中，来回所走路程最长的那头，它走的总路程是多少?</p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=3268" target="_blank" rel="noopener">http://poj.org/problem?id=3268</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>最短路，计算每头牛来回最短路之和，所有和中最大值即为答案</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;int m, n, x;///我程序里的m代表点，n代表边，与题目所述相反struct edge{    int from, to, w, pre;} a[N];int head[N], cnt, dis[1005][1005], times[1005], tot, sum;bool vis[1005];void init(int start){    for(int i = 0; i &lt;= m; ++i)        dis[start][i] = inf, times[i] = 0, vis[i] = 0;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}bool spfa(int start)///spfa里每个dis第一维下标都是start{    deque&lt;int&gt; q;    dis[start][start] = 0;    vis[start] = 1;    q.push_front(start);    tot = 1;    sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[start][first];        for(int i = head[first]; ~i; i = a[i].pre)        {            int t = a[i].to;            if(dis[start][t] &gt; dis[start][first] + a[i].w)            {                dis[start][t] = dis[start][first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;                    if(q.empty() || dis[start][t] &gt; dis[start][q.front()] || dis[start][t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[start][t];                    tot++;                    if(++times[t] &gt; n)                        return 0;                }            }        }    }    return 1;}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;m, &amp;n, &amp;x))    {        int b, c, d;        cnt = 0;        memset(head, -1, sizeof(head));        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }        int ans = 0;        for(int i = 1; i &lt;= m; ++i)        {            init(i);            if(spfa(i))            {                int tem = dis[i][x];                init(x);                if(tem != inf &amp;&amp; spfa(x))                {                    if(dis[x][i] != inf &amp;&amp; tem + dis[x][i] &gt; ans)                        ans = tem + dis[x][i];                }            }        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2253 Frogger</title>
      <link href="2019/03/28/POJ-2253-Frogger/"/>
      <url>2019/03/28/POJ-2253-Frogger/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Freddy Frog is sitting on a stone in the middle of a lake. Suddenly he notices Fiona Frog who is sitting on another stone. He plans to visit her, but since the water is dirty and full of tourists’ sunscreen, he wants to avoid swimming and instead reach her by jumping.  </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2253" target="_blank" rel="noopener">http://poj.org/problem?id=2253</a></p><blockquote><p>Unfortunately Fiona’s stone is out of his jump range. Therefore Freddy considers to use other stones as intermediate stops and reach her by a sequence of several small jumps.</p><p>To execute a given sequence of jumps, a frog’s jump range obviously must be at least as long as the longest jump occuring in the sequence.  The frog distance (humans also call it minimax distance) between two stones therefore is defined as the minimum necessary jump range over all possible paths between the two stones.   </p><p>You are given the coordinates of Freddy’s stone, Fiona’s stone and all other stones in the lake. Your job is to compute the frog distance between Freddy’s and Fiona’s stone.  </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input will contain one or more test cases. The first line of each test case will contain the number of stones n (2&lt;=n&lt;=200). The next n lines each contain two integers xi,yi (0 &lt;= xi,yi &lt;= 1000) representing the coordinates of stone #i. Stone #1 is Freddy’s stone, stone #2 is Fiona’s stone, the other n-2 stones are unoccupied. There’s a blank line following each test case. Input is terminated by a value of zero (0) for n. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case, print a line saying “Scenario #x” and a line saying “Frog Distance = y” where x is replaced by the test case number (they are numbered from 1) and y is replaced by the appropriate real number, printed to three decimals. Put a blank line after each test case, even after the last one. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2</p><p>0 0</p><p>3 4</p><p>3</p><p>17 4</p><p>19 4</p><p>18 5</p><p>0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Scenario #1</p><p>Frog Distance = 5.000</p><p>Scenario #2</p><p>Frog Distance = 1.414</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>此青蛙想到彼青蛙那里去，期间有许多石头，此青蛙可以通过这些石头跳过去。问至少要跳的最大距离，即所有路径上石头间的最大距离的最小值。 </p></blockquote><h3 id="最短路变形"><a href="#最短路变形" class="headerlink" title="最短路变形"></a>最短路变形</h3><blockquote><p>最小化最大值：</p><p>两条路：</p><ol><li><p>当前直达</p></li><li><p>中转</p><p>择优（最远“跳距”最小的那条）</p></li></ol><p>这里有个相反的：最大化最小值： <a href="https://fireworks99.github.io/2019/03/29/POJ-1797-Heavy-Transportation/" target="_blank" rel="noopener">https://fireworks99.github.io/2019/03/29/POJ-1797-Heavy-Transportation/</a></p></blockquote><h4 id="code-of-spfa"><a href="#code-of-spfa" class="headerlink" title="code of spfa"></a>code of spfa</h4><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n;bool vis[305];double dis[305][305];double ans[305];///ans[i]存:起点到i点所有路的所有路段（经最短化处理）中的最长边struct node{    double x, y;} a[305];void spfa(int start){    memset(vis, 0, sizeof(vis));    for(int i = 1; i &lt;= n; ++i)        ans[i] = inf;///inf是int型的，不能memset    ans[start] = 0;    vis[start] = 1;    queue&lt;int&gt; q;    q.push(start);    while(q.size())    {        int first = q.front();///中转站        q.pop();        vis[first] = 0;        for(int i = 1; i &lt;= n; ++i)            if(ans[i] &gt; max(ans[first], dis[first][i]))            {                ans[i] = max(ans[first], dis[first][i]);                if(!vis[i])                {                    q.push(i);                    vis[i] = 1;                }            }    }}int main(){    int cnt = 0;    while(cin &gt;&gt; n)    {        if(n == 0)            break;        cnt++;        for(int i = 1; i &lt;= n; ++i)            cin &gt;&gt; a[i].x &gt;&gt; a[i].y;        for(int i = 1; i &lt;= n; ++i)            for(int j = i + 1; j &lt;= n; ++j)                dis[i][j] = dis[j][i] = sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));        spfa(1);        printf(&quot;Scenario #%d\nFrog Distance = %.3f\n\n&quot;, cnt, ans[2]);    }    return 0;}</code></pre><h4 id="Code-of-Dijkstra"><a href="#Code-of-Dijkstra" class="headerlink" title="Code of Dijkstra"></a>Code of Dijkstra</h4><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n;bool vis[305];double dis[305][305];double ans[305];///ans[i]存:起点到i点所有路的所有路段（经最短化处理）中的最长边struct node{    double x, y;} a[305];void dijkstra(int start){    memset(vis, 0, sizeof(vis));    for(int i = 1; i &lt;= n; ++i)        ans[i] = inf;///inf是int型的，不能memset    ans[start] = 0;    for(int i = 1; i &lt;= n; ++i)    {        int mmin = inf;        int pos;        for(int j = 1; j &lt;= n; ++j)            if(!vis[j] &amp;&amp; ans[j] &lt; mmin)            {                pos = j;///距离i点最近点的标号                mmin = ans[j];///与i点相连点中、离i最近的点、距离i的距离            }        vis[pos] = 1;        for(int j = 1; j &lt;= n; ++j)            ans[j] = min(ans[j], max(ans[pos], dis[pos][j]));    }}int main(){    int cnt = 0;    while(cin &gt;&gt; n)    {        if(n == 0)            break;        cnt++;        for(int i = 1; i &lt;= n; ++i)            cin &gt;&gt; a[i].x &gt;&gt; a[i].y;        for(int i = 1; i &lt;= n; ++i)            for(int j = i + 1; j &lt;= n; ++j)                dis[i][j] = dis[j][i] = sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));        dijkstra(1);        printf(&quot;Scenario #%d\nFrog Distance = %.3f\n\n&quot;, cnt, ans[2]);    }    return 0;}</code></pre><h3 id="Code-of-Floyd"><a href="#Code-of-Floyd" class="headerlink" title="Code of Floyd"></a>Code of Floyd</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n;struct node{    double x, y;}a[205];double dis[505][505];///dis[i][j]存从i到j所有路的所有路段中最长的长度void floyd(){    for(int k = 1; k &lt;= n; ++k)        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                dis[i][j] = min(dis[i][j], max(dis[i][k], dis[k][j]));}int main(){    int cnt = 0;    while(cin &gt;&gt; n)    {        if(n == 0)            break;        cnt++;        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)            dis[i][j] = (i == j ? 0 : inf);        for(int i = 1; i &lt;= n; ++i)                cin &gt;&gt; a[i].x &gt;&gt; a[i].y;        for(int i = 1; i &lt;= n; ++i)            for(int j = i + 1; j &lt;= n; ++j)            dis[i][j] = dis[j][i] = sqrt((a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));        floyd();        printf(&quot;Scenario #%d\nFrog Distance = %.3f\n\n&quot;, cnt, dis[1][2]);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 最短路のDijkstra </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1425 sort</title>
      <link href="2019/03/25/HDU-1425-sort/"/>
      <url>2019/03/25/HDU-1425-sort/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给你n个整数，请按从大到小的顺序输出其中前m大的数。 </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1425" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1425</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>每组测试数据有两行，第一行有两个数n,m(0&lt;n,m&lt;1000000)，第二行包含n个各不相同，且都处于区间[-500000,500000]的整数。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对每组测试数据按从大到小的顺序输出前m大的数。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5 3</p><p>3 -35 92 213 -644</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>213 92 3</p></blockquote><h3 id="看哈希碰到的题，刚刚了解了输入挂，就推荐给我。莫非被监视了？"><a href="#看哈希碰到的题，刚刚了解了输入挂，就推荐给我。莫非被监视了？" class="headerlink" title="?看哈希碰到的题，刚刚了解了输入挂，就推荐给我。莫非被监视了？"></a>?看哈希碰到的题，刚刚了解了输入挂，就推荐给我。<del>莫非被监视了？</del></h3><h3 id="用挂Code"><a href="#用挂Code" class="headerlink" title="用挂Code"></a>用挂Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[1000005];int Scan(){    int res = 0, ch, flag = 0;    if( (ch = getchar() ) == &#39;-&#39;)///括号搞清楚        flag = 1;    else if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res = ch - &#39;0&#39;;    while( (ch = getchar()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)///= 与 == 分清        res = res * 10 + ch - &#39;0&#39;;    return flag ? -res : res;}void Out(int a){    if(a &lt; 0)    {        putchar(&#39;-&#39;);        a *= -1;    }    if(a &gt; 9)        Out(a / 10);    putchar(a % 10 + &#39;0&#39;);}bool cmp(int a, int b){    return a &gt; b;}int main(){    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        for(int i = 0; i &lt; n; ++i)            a[i] = Scan();        sort(a, a + n, cmp);        for(int i = 0; i &lt; m; ++i)        {            Out(a[i]);            printf(&quot;%c&quot;, i == m - 1 ? &#39;\n&#39; : &#39; &#39;);        }    }    return 0;}</code></pre><h4 id="emmm…用C-TLE了，用G-勉强过"><a href="#emmm…用C-TLE了，用G-勉强过" class="headerlink" title="emmm…用C++TLE了，用G++勉强过"></a>emmm…用C++TLE了，用G++勉强过</h4><p><img src="https://i.loli.net/2019/03/25/5c98ca408c412.png" alt="en"></p><h3 id="hash-空间换时间"><a href="#hash-空间换时间" class="headerlink" title="hash?(空间换时间)"></a>hash?(空间换时间)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int hash1[1000005];int main(){    int n, m;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        while(n--)        {            int t;            scanf(&quot;%d&quot;,&amp;t);            hash1[t + 500000]++;        }        for(int i = 500000 * 2; i &gt;= 0; i--)        {            if(hash1[i] != 0)            {                m--;                printf(&quot;%d%c&quot;, i - 500000, m == 0 ? &#39;\n&#39; : &#39; &#39;);                if(m == 0)                    break;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の哈希 </tag>
            
            <tag> 技巧の输入挂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出挂</title>
      <link href="2019/03/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%82/"/>
      <url>2019/03/25/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%82/</url>
      
        <content type="html"><![CDATA[<h3 id="关于输入挂"><a href="#关于输入挂" class="headerlink" title="关于输入挂"></a>关于输入挂</h3><blockquote><p>输入速度：getchar  &gt;  scanf  &gt;  cin</p><p>特点：快糙猛？</p></blockquote><a id="more"></a><h2 id="探索输入挂"><a href="#探索输入挂" class="headerlink" title="探索输入挂"></a>探索输入挂</h2><h4 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h4><blockquote><p>随机产生一百万个整型数，写入指定文件里</p></blockquote><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    srand(time(NULL));    freopen(&quot;00out.txt&quot;, &quot;w&quot;, stdout);    int n;    int num = 1000000;    while(num--)    {        n = rand() % 1000;        cout &lt;&lt; n &lt;&lt; &#39; &#39;;    }    return 0;}</code></pre><h4 id="开始探索"><a href="#开始探索" class="headerlink" title="开始探索"></a>开始探索</h4><blockquote><p>分别用输入挂（getchar）、scanf、cin读入一百万个整型数字，看运行时间</p></blockquote><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1000005;int a[N];int b[N];int Scan()     ///输入外挂{    int res = 0, ch ,flag = 0;    if( (ch = getchar()) == &#39;-&#39; )        flag = 1;    else if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res = ch - &#39;0&#39;;    while((ch = getchar()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res = res * 10 + ch - &#39;0&#39;;    return flag ? -res : res;}void Out(int a)    ///输出外挂{    if(a &lt; 0)    {        putchar(&#39;-&#39;);        a *= -1;    }    if(a &gt; 9)        Out(a / 10);    putchar(a % 10 + &#39;0&#39;);}int main(){    clock_t start, over;    double  duration;    freopen(&quot;00out.txt&quot;, &quot;r&quot;, stdin);    start = clock();    for(int i = 0; i &lt; 1000000; ++i)        a[i] = Scan();    over = clock();    duration = double(over - start) / CLOCKS_PER_SEC;    cout &lt;&lt; duration &lt;&lt; &quot; (s)&quot; &lt;&lt; &#39;\n&#39;;    fclose(stdin);    freopen(&quot;00out.txt&quot;, &quot;r&quot;, stdin);    start = clock();    for(int i = 0; i &lt; 1000000; ++i)        scanf(&quot;%d&quot;, &amp;a[i]);    over = clock();    duration = double(over - start) / CLOCKS_PER_SEC;    cout &lt;&lt; duration &lt;&lt; &quot; (s)&quot; &lt;&lt; &#39;\n&#39;;    fclose(stdin);    freopen(&quot;00out.txt&quot;, &quot;r&quot;, stdin);    start = clock();    for(int i = 0; i &lt; 1000000; ++i)        cin &gt;&gt; a[i];    over = clock();    duration = double(over - start) / CLOCKS_PER_SEC;    cout &lt;&lt; duration &lt;&lt; &quot; (s)&quot; &lt;&lt; &#39;\n&#39;;    fclose(stdin);}</code></pre><p><strong>结果</strong></p><p><img src="https://i.loli.net/2019/03/25/5c98b20809e7d.png" alt="结果"></p><blockquote><p>读入挂(getchar) —— 33ms</p><p>scanf —— 136ms</p><p>cin —— 1412ms</p></blockquote><h3 id="关于double的读入挂（一般用不到）"><a href="#关于double的读入挂（一般用不到）" class="headerlink" title="关于double的读入挂（一般用不到）"></a>关于double的读入挂（一般用不到）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;double Scan(){    int ch, pos = 1, num = 0;///num为字符串总长度，pos为小数点排第几位    double res = 0;    bool flag = 0, found = 0;    if( (ch = getchar()) == &#39;-&#39; )        flag = 1;    else if(ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)        res = ch - &#39;0&#39;;    num++;    while((ch = getchar()) &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39; || ch == &#39;.&#39;)        {            num++;            if(ch == &#39;.&#39;)            {                found = 1;                pos++;            }            else            {                res = res * 10 + ch - &#39;0&#39;;                if(!found)                    pos++;            }        }    res *= pow(0.1, num - pos);    return flag ? -res  : res ;}int main(){    double ans;    while(ans = Scan())    {        cout &lt;&lt; fixed &lt;&lt; std::setprecision(10) &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><pre><code class="lang-c++">scanf(&quot;%d&quot;, &amp;n);getchar();for(int i = 0; i &lt; n; ++i)    a[i] = Scan();</code></pre><blockquote><p>中间的<code>getchar()</code>不加上可能输出测试时表面上看没影响，但就是会WA！</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 技巧の输入挂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3126 Prime Path</title>
      <link href="2019/03/22/POJ-3126-Prime-Path/"/>
      <url>2019/03/22/POJ-3126-Prime-Path/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给出两个素数，求从这个变到那个需要几步。（变法：每步仅改变一位数）</p></blockquote><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=3126" target="_blank" rel="noopener">http://poj.org/problem?id=3126</a></p><a id="more"></a><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int tot;int prime[1500];bool vis[10500];bool flag[10500];struct node{    int val, step;};queue&lt;node&gt; q;void get_prime(){    memset(vis, 1, sizeof(vis));    tot = 0;    vis[0] = vis[1] = 0;    for(int i = 2; i &lt; 10410; ++i)    {        if(vis[i])            prime[++tot] = i;///下面的 j&lt;= tot 决定了这里从1开始存        for(int j = 1; j &lt;= tot &amp;&amp; prime[j] * i &lt;= 10100; ++j)        {            vis[ prime[j] * i ] = 0;            if(i % prime[j] == 0)                break;        }    }}///起初这里写了形参队列q，结果在此函数内q不是全局内的qvoid seek(node now, node nxt, int t){    if(!flag[t] &amp;&amp; vis[t])///未访问过且为素数    {        flag[t] = 1;        nxt.val = t;        nxt.step = now.step + 1;        q.push(nxt);    }}int bfs(int a, int b){    while(q.size())        q.pop();    memset(flag, 0, sizeof(flag));    node now, nxt;    now.val = a;    now.step = 0;    flag[a] = 1;    q.push(now);    while(q.size())    {        now = q.front();        q.pop();        if(now.val == b)            return now.step;        int t;        for(int i = 1; i &lt;= 9; i += 2)///个位换奇数        {            t = now.val / 10 * 10 + i;            seek(now, nxt, t);        }        for(int i = 0; i &lt;= 9; ++i)///十位        {            t = (now.val / 100 * 10 + i) * 10 + now.val % 10;///此处及后面同位置易出错            seek(now, nxt, t);        }        for(int i = 0; i &lt;= 9; ++i)///百位        {            t = (now.val / 1000 * 10 + i) * 100 + now.val % 100;            seek(now, nxt, t);        }        for(int i = 1; i &lt;= 9; ++i)///千位        {            t = i * 1000 + now.val % 1000;            seek(now, nxt, t);        }    }    return inf;}int main(){    get_prime();    int t, a, b;    cin &gt;&gt; t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        int ans = bfs(a, b);        if(ans != inf)            cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
            <tag> 数论の素数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FZU 2150 Fire Game</title>
      <link href="2019/03/21/FZU-2150-Fire-Game/"/>
      <url>2019/03/21/FZU-2150-Fire-Game/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>今有草地一片，’#’为草，’.’为空地，草可燃，地不可。有二童子顽劣之至，以焚尽草地为娱。二人可于两处分别点火，瞬间即燃。火势凶猛，所到之处，寸草不生。凡火所在，唯待一刻，便四处蔓延。问：待草烧尽，耗时几何？</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>各种点火组合皆遍历一遍,找出最优解。</p><p>BFS：将两个起点一起放入队列中遍历，vis数组标记该点是否已燃。检查终点，若所有草地被燃，答案即为终点时的time（我曾想问：若终点之前的某点以满足条件（即所有草地皆已燃），那答案是不是会更小些？后来想想这个点就是终点，vis尽被标记找不到其他点了）</p></blockquote><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><blockquote><p><del>我也太那啥那啥了…一点不那啥…还是太那啥了…</del></p><p>刚开始想着两个点”分别“但“同时“bfs，还担心一个vis不够用（这个火燃到这里应该允许另一个火也可以经过这），后来想想，都是火，分啥你我啊!</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m;string s[15];bool flag;bool vis[15][15];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};int tot;struct grass{    int x, y;} g[105];struct node{    int x, y, tim;};bool check(){    for(int i = 0; i &lt; n; ++i)        for(int j = 0; j &lt; m; ++j)        {            if(!vis[i][j] &amp;&amp; s[i][j] == &#39;#&#39;)///有草地剩余                return 0;        }    return 1;}int bfs(grass a, grass b){    queue&lt;node&gt; q;    node first, nxt;    first.x = a.x;    first.y = a.y;    first.tim = 0;    vis[a.x][a.y] = 1;    q.push(first);    first.x = b.x;    first.y = b.y;    first.tim = 0;    vis[b.x][b.y] = 1;    q.push(first);    while(q.size())    {        first = q.front();        q.pop();        for(int i = 0; i &lt; 4; ++i)        {            int xx = first.x + dx[i];            int yy = first.y + dy[i];            if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; s[xx][yy] == &#39;#&#39; )            {                vis[xx][yy] = 1;                nxt.x = xx;                nxt.y = yy;                nxt.tim = first.tim + 1;                q.push(nxt);            }        }    }    if(check())        return first.tim;    return inf;}int main(){//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    int t;    cin &gt;&gt; t;    int tem = t;    while(t--)    {        tot = 0;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)                if(s[i][j] == &#39;#&#39;)                {                    g[tot].x = i;                    g[tot].y = j;                    tot++;                }        flag = 0;        int ans = inf;        for(int i = 0; i &lt; tot; ++i)            for(int j = i; j &lt; tot; ++j)///j == i不能漏（只有一处可点的地方）            {                memset(vis, 0, sizeof(vis));                int res = bfs(g[i], g[j]);                if(res &lt; ans)                    ans = res;            }        if(ans == inf)            cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Just-say-something-I-want-to-say"><a href="#Just-say-something-I-want-to-say" class="headerlink" title="Just say something I want to say"></a>Just say something I want to say</h3><blockquote><p>刚开始做这题有自己的想法，然后发现漏洞，各种弥补，一点一点添置，一点一点改进，结果写了二百多行，写了三天还是…写的<del>江郎才尽</del>没办法了看了一眼题解，原来想多了，一些地方没想明白整的很复杂…</p><p>这让我想起高中的时候，那时候要想得高分倡导多做题，不要吊死在一棵树上。可我做不到，这道题我有想法，付出再多精力与时间把它做出来也是值得的。可事实是即使这样我也做不出来，然而负反馈调节就出现了：我都付出那么多了必须把它做出来，可我就是做不出来，如果此时放弃那么岂不前功尽弃，如果此时不放弃岂不浪费更多时间…</p><p>这好像是心理学的某个定理（也可能不是）：你买了一张电影票，看了一会儿发现电影不怎么样，甚至有些厌恶，这时候明明可以离开的，可转念一想：钱都花了，不看完好像损失了什么。然而最终事实是：你浪费了时间去做了自己讨厌的事，一切似乎只是因为“患得患失”的性格？以说：当断则断？（能屈能伸？张弛有度？）说起来倒容易……</p></blockquote><h3 id="贴一些废代码泄愤（勿看）"><a href="#贴一些废代码泄愤（勿看）" class="headerlink" title="贴一些废代码泄愤（勿看）"></a>贴一些废代码泄愤（勿看）</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m;bool flag;///BFS can&#39;t find the answer,output &quot;-1&quot;.string s[15];bool vis1[15][15];bool vis2[15][15];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};int zc[4];int zd[4];///从某点出发可以走四个方向，起初自作聪明写3int tot;struct grass{    int x, y;} g[105];struct node{    int x, y, tim;    set&lt;int&gt; st;///存放当前状态已燃之草的序号} ;int bfs(grass c, grass d){    bool flag1 = 0;    bool flag2 = 0;    node nowc, nowd, nxtc[4], nxtd[4], last1, last2;    nowc.x = c.x;    nowc.y = c.y;    nowc.tim = 0;    for(int i = 0; i &lt; tot; ++i)        if(g[i].x == c.x &amp;&amp; g[i].y == c.y)        {            nowc.st.insert(i);            break;        }    vis1[c.x][c.y] = 1;    queue&lt;node&gt; q1;    q1.push(nowc);    nowd.x = d.x;    nowd.y = d.y;    nowd.tim = 0;    for(int i = 0; i &lt; tot; ++i)        if(g[i].x == d.x &amp;&amp; g[i].y == d.y)        {            nowd.st.insert(i);            break;        }    vis2[d.x][d.y] = 1;    queue&lt;node&gt; q2;    q2.push(nowd);    while(q1.size() || q2.size())    {        ///取队列首元素        if(q1.size() == 1)            last1 = q1.front();        if(q2.size() == 1)            last2 = q2.front();        if(q1.empty())            nowc = last1;        else        {            flag1 = 1;            nowc = q1.front();            q1.pop();        }        if(q2.empty())            nowd = last2;        else        {            flag2 = 1;            nowd = q2.front();            q2.pop();        }        cout &lt;&lt; &quot;have a check : &quot; &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; &quot;nowc &quot; &lt;&lt; nowc.x &lt;&lt; &#39; &#39; &lt;&lt; nowc.y &lt;&lt; &#39; &#39; &lt;&lt; nowc.tim &lt;&lt; &#39; &#39; &lt;&lt; nowc.st.size() &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; &quot;nowd &quot; &lt;&lt; nowd.x &lt;&lt; &#39; &#39; &lt;&lt; nowd.y &lt;&lt; &#39; &#39; &lt;&lt; nowd.tim &lt;&lt; &#39; &#39; &lt;&lt; nowd.st.size() &lt;&lt; &#39;\n&#39;;        ///出口判断        if(nowc.st.size() + nowd.st.size() &gt;= tot)        {            cout &lt;&lt; &quot;It seems to be a exit.&quot; &lt;&lt; &#39;\n&#39;;            set&lt;int&gt; totst = nowc.st;            for(set&lt;int&gt; ::iterator it = nowd.st.begin(); it != nowd.st.end(); ++it)                totst.insert(*it);            cout &lt;&lt; &quot;tot : &quot; &lt;&lt; totst.size() &lt;&lt; &#39;\n&#39;;            if(totst.size() == tot)            {                flag = 1;                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowc.tim + nowd.tim &lt;&lt; &#39;\n&#39;;                return nowc.tim + nowd.tim;            }//            flag = 1;//            if(nowc.st.size() == tot &amp;&amp; nowd.st.size() != tot)//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowc.tim &lt;&lt; &#39;\n&#39;;//                return nowc.tim;//            }//            else if(nowd.st.size() == tot &amp;&amp; nowc.st.size() != tot)//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowd.tim &lt;&lt; &#39;\n&#39;;//                return nowd.tim;//            }//            else//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; min(nowc.tim, nowd.tim) &lt;&lt; &#39;\n&#39;;//                return min(nowc.tim, nowd.tim);//            }        }        ///搜索nxt        int zcnum = 0;        int zdnum = 0;        memset(zc, 0, sizeof(zc));        memset(zd, 0, sizeof(zd));        int nxtcnum = 0;        int nxtdnum = 0;        for(int i = 0; i &lt; 4; ++i)        {            int xx, yy;            if(flag1)            {                xx = nowc.x + dx[i];                yy = nowc.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis1[xx][yy] &amp;&amp; s[xx][yy] == &#39;#&#39;)                {                    vis1[xx][yy] = 1;                    nxtc[nxtcnum].x = xx;                    nxtc[nxtcnum].y = yy;                    nxtcnum++;//                    nxtc.tim = nowc.tim + 1;//                    nxtc.st = nowc.st;                    for(int j = 0; j &lt; tot; ++j)                        if(g[j].x == xx &amp;&amp; g[j].y == yy)                        {                            zc[zcnum++] = j;                            break;                        }//                    q1.push(nxtc);                }            }            if(flag2)            {                xx = nowd.x + dx[i];                yy = nowd.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis2[xx][yy] &amp;&amp; s[xx][yy] == &#39;#&#39;)                {                    vis2[xx][yy] = 1;                    nxtd[nxtdnum].x = xx;                    nxtd[nxtdnum].y = yy;                    nxtdnum++;//                    nxtd.tim = nowd.tim + 1;//                    nxtd.st = nowd.st;                    for(int j = 0; j &lt; tot; ++j)                        if(g[j].x == xx &amp;&amp; g[j].y == yy)                        {                            zd[zdnum++] = j;                            break;                        }//                    q2.push(nxtd);                }            }        }        for(int i = 0; i &lt; nxtcnum; ++i)        {            nxtc[i].tim = nowc.tim + 1;            nxtc[i].st = nowc.st;            for(int j = 0; j &lt; zcnum; ++j)                nxtc[i].st.insert(zc[j]);            q1.push(nxtc[i]);        }        for(int i = 0; i &lt; nxtdnum; ++i)        {            nxtd[i].tim = nowd.tim + 1;            nxtd[i].st = nowd.st;            for(int j = 0; j &lt; zdnum; ++j)                nxtd[i].st.insert(zd[j]);            q2.push(nxtd[i]);        }    }    cout &lt;&lt; &quot;There is no solution!&quot; &lt;&lt; &#39;\n&#39;;    return inf;}int main(){    int t;    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; t;    int tem = t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        tot = 0;        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)                if(s[i][j] == &#39;#&#39;)                {                    g[tot].x = i;                    g[tot].y = j;                    tot++;                }        if(tot &lt;= 2)        {            if(tot &gt; 0)            {                cout &lt;&lt; &quot;the number of the grass is less than 3&quot; &lt;&lt; &#39;\n&#39;;                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: 0&quot; &lt;&lt; &#39;\n&#39;;            }            else            {                cout &lt;&lt; &quot;there is no grass!&quot; &lt;&lt; &#39;\n&#39;;                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;            }        }        else        {            int ans = inf;            flag = 0;///0表示无合适方案            for(int i = 0; i &lt; tot; ++i)                for(int j = i + 1; j &lt; tot; ++j)                {                    cout &lt;&lt; &quot;The new solution for this question :&quot; &lt;&lt; &#39;\n&#39;;                    cout &lt;&lt; &quot;position :&quot; &lt;&lt; g[i].x &lt;&lt; &#39; &#39; &lt;&lt; g[i].y &lt;&lt; &#39; &#39; &lt;&lt; g[j].x &lt;&lt; &#39; &#39; &lt;&lt; g[j].y &lt;&lt; &#39;\n&#39;;                    memset(vis1, 0, sizeof(vis1));                    memset(vis2, 0, sizeof(vis2));                    int res = bfs(g[i], g[j]);                    if(res &lt; ans)                        ans = res;                }            if(flag)                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m;bool flag;///BFS can&#39;t find the answer,output &quot;-1&quot;.string s[15];bool vis1[15][15];bool vis2[15][15];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};int zc[4];int zd[4];///从某点出发可以走四个方向，起初自作聪明写3int tot;struct grass{    int x, y;} g[105];struct node{    int x, y, tim;    set&lt;int&gt; st;///存放当前状态已燃之草的序号} ;int bfs(grass c, grass d){    bool flag1 = 0;    bool flag2 = 0;    node nowc, nowd, nxtc, nxtd, last1, last2;    nowc.x = c.x;    nowc.y = c.y;    nowc.tim = 0;    for(int i = 0; i &lt; tot; ++i)        if(g[i].x == c.x &amp;&amp; g[i].y == c.y)        {            nowc.st.insert(i);            break;        }    vis1[c.x][c.y] = 1;    queue&lt;node&gt; q1;    q1.push(nowc);    nowd.x = d.x;    nowd.y = d.y;    nowd.tim = 0;    for(int i = 0; i &lt; tot; ++i)        if(g[i].x == d.x &amp;&amp; g[i].y == d.y)        {            nowd.st.insert(i);            break;        }    vis2[d.x][d.y] = 1;    queue&lt;node&gt; q2;    q2.push(nowd);    while(q1.size() || q2.size())    {        ///取队列首元素        if(q1.size() == 1)            last1 = q1.front();        if(q2.size() == 1)            last2 = q2.front();        if(q1.empty())            nowc = last1;        else        {            flag1 = 1;            nowc = q1.front();            q1.pop();        }        if(q2.empty())            nowd = last2;        else        {            flag2 = 1;            nowd = q2.front();            q2.pop();        }        cout &lt;&lt; &quot;have a check : &quot; &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; &quot;nowc &quot; &lt;&lt; nowc.x &lt;&lt; &#39; &#39; &lt;&lt; nowc.y &lt;&lt; &#39; &#39; &lt;&lt; nowc.tim &lt;&lt; &#39; &#39; &lt;&lt; nowc.st.size() &lt;&lt; &#39;\n&#39;;        cout &lt;&lt; &quot;nowd &quot; &lt;&lt; nowd.x &lt;&lt; &#39; &#39; &lt;&lt; nowd.y &lt;&lt; &#39; &#39; &lt;&lt; nowd.tim &lt;&lt; &#39; &#39; &lt;&lt; nowd.st.size() &lt;&lt; &#39;\n&#39;;        ///出口判断//        if(nowc.st.size() + nowd.st.size() &gt;= tot)//        {//            cout &lt;&lt; &quot;It seems to be a exit.&quot; &lt;&lt; &#39;\n&#39;;//            set&lt;int&gt; totst = nowc.st;//            for(set&lt;int&gt; ::iterator it = nowd.st.begin(); it != nowd.st.end(); ++it)//                totst.insert(*it);//            cout &lt;&lt; &quot;tot : &quot; &lt;&lt; totst.size() &lt;&lt; &#39;\n&#39;;//            if(totst.size() == tot)//            {//                flag = 1;//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowc.tim + nowd.tim &lt;&lt; &#39;\n&#39;;//                return nowc.tim + nowd.tim;//            }//            flag = 1;//            if(nowc.st.size() == tot &amp;&amp; nowd.st.size() != tot)//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowc.tim &lt;&lt; &#39;\n&#39;;//                return nowc.tim;//            }//            else if(nowd.st.size() == tot &amp;&amp; nowc.st.size() != tot)//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; nowd.tim &lt;&lt; &#39;\n&#39;;//                return nowd.tim;//            }//            else//            {//                cout &lt;&lt; &quot;The ans is : &quot; &lt;&lt; min(nowc.tim, nowd.tim) &lt;&lt; &#39;\n&#39;;//                return min(nowc.tim, nowd.tim);//            }//        }        ///搜索nxt//        int zcnum = 0;//        int zdnum = 0;//        memset(zc, 0, sizeof(zc));//        memset(zd, 0, sizeof(zd));//        int nxtcnum = 0;//        int nxtdnum = 0;        for(int i = 0; i &lt; 4; ++i)        {            int xx, yy;            if(flag1)            {                xx = nowc.x + dx[i];                yy = nowc.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis1[xx][yy] &amp;&amp; s[xx][yy] == &#39;#&#39;)                {                    vis1[xx][yy] = 1;                    nxtc.x = xx;                    nxtc.y = yy;                    nxtc.tim = nowc.tim + 1;                    nxtc.st = nowc.st;                    for(int j = 0; j &lt; tot; ++j)                        if(g[j].x == xx &amp;&amp; g[j].y == yy)                        {                            nxtc.st.insert(j);                            break;                        }                    q1.push(nxtc);                }            }            if(flag2)            {                xx = nowd.x + dx[i];                yy = nowd.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis2[xx][yy] &amp;&amp; s[xx][yy] == &#39;#&#39;)                {                    vis2[xx][yy] = 1;                    nxtd.x = xx;                    nxtd.y = yy;                    nxtd.tim = nowd.tim + 1;                    nxtd.st = nowd.st;                    for(int j = 0; j &lt; tot; ++j)                        if(g[j].x == xx &amp;&amp; g[j].y == yy)                        {                            nxtd.st.insert(j);                            break;                        }                    q2.push(nxtd);                }            }        }//        for(int i = 0; i &lt; nxtcnum; ++i)//        {//            nxtc[i].tim = nowc.tim + 1;//            nxtc[i].st = nowc.st;//            for(int j = 0; j &lt; zcnum; ++j)//                nxtc[i].st.insert(zc[j]);//            q1.push(nxtc[i]);//        }//        for(int i = 0; i &lt; nxtdnum; ++i)//        {//            nxtd[i].tim = nowd.tim + 1;//            nxtd[i].st = nowd.st;//            for(int j = 0; j &lt; zdnum; ++j)//                nxtd[i].st.insert(zd[j]);//            q2.push(nxtd[i]);//        }    }    cout &lt;&lt; &quot;There is no solution!&quot; &lt;&lt; &#39;\n&#39;;    return inf;}int main(){    int t;    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; t;    int tem = t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        tot = 0;        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)                if(s[i][j] == &#39;#&#39;)                {                    g[tot].x = i;                    g[tot].y = j;                    tot++;                }        if(tot &lt;= 2)        {            if(tot &gt; 0)            {                cout &lt;&lt; &quot;the number of the grass is less than 3&quot; &lt;&lt; &#39;\n&#39;;                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: 0&quot; &lt;&lt; &#39;\n&#39;;            }            else            {                cout &lt;&lt; &quot;there is no grass!&quot; &lt;&lt; &#39;\n&#39;;                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;            }        }        else        {            int ans = inf;            flag = 0;///0表示无合适方案            for(int i = 0; i &lt; tot; ++i)                for(int j = i + 1; j &lt; tot; ++j)                {                    cout &lt;&lt; &quot;The new solution for this question :&quot; &lt;&lt; &#39;\n&#39;;                    cout &lt;&lt; &quot;position :&quot; &lt;&lt; g[i].x &lt;&lt; &#39; &#39; &lt;&lt; g[i].y &lt;&lt; &#39; &#39; &lt;&lt; g[j].x &lt;&lt; &#39; &#39; &lt;&lt; g[j].y &lt;&lt; &#39;\n&#39;;                    memset(vis1, 0, sizeof(vis1));                    memset(vis2, 0, sizeof(vis2));                    int res = bfs(g[i], g[j]);                    if(res &lt; ans)                        ans = res;                }            if(flag)                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;Case :&quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m, ans;bool flag;///针对 “-1”string s[15];bool vis1[15][15];bool vis2[15][15];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};struct node{    int x, y, step;} a[100];int tot;struct grass{    int x, y;} g[100];int bfs(grass c, grass d){    int num = 2;    node now1, now2, nxt1, nxt2;    int ans_step = 0;    now1.x = c.x;    now1.y = c.y;    now1.step = 0;    vis1[c.x][c.y] = 1;    now2.x = d.x;    now2.y = d.y;    now2.step = 0;    vis2[d.x][d.y] = 1;    queue&lt;node&gt; q1;    queue&lt;node&gt; q2;    q1.push(now1);    q2.push(now2);    while(q1.size() || q2.size())///刚开始记错了写成&amp;&amp;    {//        cout &lt;&lt; &quot;Check the size : &quot; &lt;&lt; &#39;\n&#39;;//        cout &lt;&lt; q1.size() &lt;&lt; &#39; &#39; &lt;&lt; q2.size() &lt;&lt; &#39;\n&#39;;        bool flag1 = 0;        bool flag2 = 0;        bool flag_front = 0;        if(q1.size())        {            flag1 = 1;            now1 = q1.front();            q1.pop();        }        if(q2.size())        {            flag2 = 1;            now2 = q2.front();            q2.pop();        }        int xx, yy;        for(int i = 0; i &lt; 4; ++i)        {            if(flag1)            {                xx = now1.x + dx[i];                yy = now1.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; s[xx][yy] == &#39;#&#39; &amp;&amp; !vis1[xx][yy])                {                    vis1[xx][yy] = 1;                    nxt1.x = xx;                    nxt1.y = yy;                    nxt1.step = now1.step + 1;                    q1.push(nxt1);                    if(!vis2[xx][yy])                    {                        cout &lt;&lt; &quot;num++ &#39;s position&quot; &lt;&lt; xx &lt;&lt; &#39; &#39; &lt;&lt; yy &lt;&lt; &#39;\n&#39;;                        num++;                        flag_front = 1;                        if(num == tot)                        {                            flag = 1;                            return nxt1.step + now2.step;                        }                    }                }            }            if(flag2)            {                xx = now2.x + dx[i];                yy = now2.y + dy[i];                if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; s[xx][yy] == &#39;#&#39; &amp;&amp; !vis2[xx][yy])                {                    vis2[xx][yy] = 1;                    nxt2.x = xx;                    nxt2.y = yy;                    nxt2.step = now2.step + 1;                    q2.push(nxt2);                    if(!vis1[xx][yy])                    {                        cout &lt;&lt; &quot;num++ &#39;s position&quot; &lt;&lt; xx &lt;&lt; &#39; &#39; &lt;&lt; yy &lt;&lt; &#39;\n&#39;;                        num++;                        if(num == tot)                        {                            flag = 1;                            if(flag_front)                            return nxt1.step + nxt2.step;                            else                            return now1.step + nxt2.step;                        }                    }                }            }        }    }//    cout &lt;&lt; &quot;There is not a right method!&quot; &lt;&lt; &#39;\n&#39;;//    cout &lt;&lt; &quot;num :&quot; &lt;&lt; num &lt;&lt;&#39;\n&#39;;    return inf;}int main(){    int t;    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; t;    int tem = t;    while(t--)    {        tot = 0;        flag = 0;        ans = inf;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)            {                if(s[i][j] == &#39;#&#39;)                {                    g[tot].x = i;                    g[tot].y = j;                    tot++;                }            }//        cout &lt;&lt; &quot;Check the grass : &quot; &lt;&lt; &#39;\n&#39;;//        for(int i = 0; i &lt; tot; ++i)//            cout &lt;&lt; g[i].x &lt;&lt; &#39; &#39; &lt;&lt; g[i].y &lt;&lt; &#39;\n&#39;;        if(tot &lt;= 2)        {//            cout &lt;&lt; &quot;The number of grass is less than 3.&quot; &lt;&lt; &#39;\n&#39;;            if(tot &gt; 0)                cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: 0&quot; &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;        }        else        {//            cout &lt;&lt; &quot;Check the dapei : &quot; &lt;&lt; &#39;\n&#39;;            for(int i = 0; i &lt; tot; ++i)                for(int j = i + 1; j &lt; tot; ++j)                {                    cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39;\n&#39;;                    cout &lt;&lt; &quot;position : &quot; &lt;&lt; g[i].x &lt;&lt; &#39; &#39; &lt;&lt; g[i].y &lt;&lt; &#39; &#39; &lt;&lt; g[j].x &lt;&lt; &#39; &#39; &lt;&lt; g[j].y &lt;&lt; &#39;\n&#39;;                    memset(vis1, 0, sizeof(vis1));                    memset(vis2, 0, sizeof(vis2));                    int res = bfs(g[i], g[j]);                    cout &lt;&lt; &quot;Check the bfs : &quot; &lt;&lt; res &lt;&lt; &#39;\n&#39;;                    if(res &lt; ans)                        ans = res;                }            if(flag)                cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;Case &quot; &lt;&lt; tem - t &lt;&lt; &quot;: -1&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2612 Find a way</title>
      <link href="2019/03/18/HDU-2612/"/>
      <url>2019/03/18/HDU-2612/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Pass a year learning in Hangzhou, yifenfei arrival  hometown Ningbo at finally. Leave Ningbo one year, yifenfei have many people to  meet. Especially a good friend Merceki. Yifenfei’s home is at the  countryside, but Merceki’s home is in the center of city. So yifenfei made  arrangements with Merceki to meet at a KFC. There are many KFC in Ningbo, they  want to choose one that let the total time to it be most smallest.  Now give  you a Ningbo map, Both yifenfei and Merceki can move up, down ,left, right to  the adjacent road by cost 11 minutes. </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=2612" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2612</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input contains multiple test cases. Each test  case include, first two integers n, m. (2&lt;=n,m&lt;=200).  Next n lines,  each line included m character.</p><p>‘Y’ express yifenfei initial position.</p><p>‘M’     express Merceki initial position.</p><p>‘#’ forbid road; </p><p>‘.’ Road.</p><p>‘@’  KCF </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case output the minimum total time that  both yifenfei and Merceki to arrival one of KFC.You may sure there is always  have a KFC that can let them meet.</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">4 4Y.#@.....#..@..M4 4Y.#@.....#..@#.M5 5Y..@..#....#...@..M.#...#</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>66</p><p>88</p><p>66</p></blockquote><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><blockquote><p>Y和M两个人要在任意一个KFC见面，求两人路径和中最短的一个</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>两次BFS求出两人到所有KFC的路径长，再找出和最短的那个</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;///BFS需要以结构体形式将数据临时存起来以备后来去遍历///DFS没有要存储的临时数据///由于DFS要用到递归，我感觉比BFS思想更复杂些int n, m, ydex, ydey, mdex, mdey;string s[205];bool vis[205][205];int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};struct node{    int x, y, step;};int tot;///kfc的a[]辅助，计总个数struct kfc{    int x, y, y_step, m_step, tot_step;} a[40005];void kfc_init(){    for(int i = 0; i &lt; 205; ++i)    {        a[i].y_step = inf;        a[i].m_step = inf;    }}///BFS擅长于最小（短）值，DFS擅长于连接体（相连）问题void bfs(int x, int y, bool flag)///写之前一定想好bfs还是dfs{    int cnt = 0;///若是DFS(有递归属性)，不要在函数里定义啥    vis[x][y] = 1;    queue&lt;node&gt; q;    node now;    now.x = x;    now.y = y;    now.step = 0;    q.push(now);    while(q.size())    {        now = q.front();        q.pop();        if(s[now.x][now.y] == &#39;@&#39;)        {            cnt++;            for(int i = 0; i &lt; tot; ++i)            {                if(a[i].x == now.x &amp;&amp; a[i].y == now.y)                {                    if(flag == 0)                        a[i].y_step = now.step;                    else                        a[i].m_step = now.step;                    break;                }            }            if(cnt == tot)                return ;        }        for(int i = 0; i &lt; 4; ++i)        {            int xx = now.x + dx[i];            int yy = now.y + dy[i];            if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; s[xx][yy] != &#39;#&#39;)            {                vis[xx][yy] = 1;                node nxt;                nxt.x = xx;                nxt.y = yy;                nxt.step = now.step + 1;                q.push(nxt);            }        }    }}int main(){//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        kfc_init();        tot = 0;        memset(vis, 0, sizeof(vis));        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)            {                if(s[i][j] == &#39;Y&#39;)                {                    ydex = i;                    ydey = j;                }                if(s[i][j] == &#39;M&#39;)                {                    mdex = i;                    mdey = j;                }                if(s[i][j] == &#39;@&#39;)                {                    a[tot].x = i;                    a[tot].y = j;                    tot++;                }            }        bfs(ydex, ydey, 0);        memset(vis, 0, sizeof(vis));        bfs(mdex, mdey, 1);        int ans = inf;        for(int i = 0; i &lt; tot; ++i)        {            a[i].tot_step = a[i].y_step + a[i].m_step;            if(ans &gt; a[i].tot_step)                ans = a[i].tot_step;        }        cout &lt;&lt; ans * 11 &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><blockquote><p>突然发现DFS比BFS更难以梳理清楚、难实现，因为涉及递归……</p><p>相较于DFS，BFS就显得友好多了……</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS路径输出</title>
      <link href="2019/03/18/BFS%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA/"/>
      <url>2019/03/18/BFS%E8%B7%AF%E5%BE%84%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="记录路径"><a href="#记录路径" class="headerlink" title="记录路径"></a>记录路径</h3><blockquote><p>pre存当前点的前一个点的位置标号（序号），类似的还有最长递增子序列的路径记录，还有链式前向星，都是一个方法。</p></blockquote><a id="more"></a><h3 id="POJ-3984-迷宫问题"><a href="#POJ-3984-迷宫问题" class="headerlink" title="POJ 3984 迷宫问题"></a>POJ 3984 迷宫问题</h3><p><strong>题目链接</strong><a href="http://poj.org/problem?id=3984" target="_blank" rel="noopener">http://poj.org/problem?id=3984</a></p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int m[10][10];bool vis[10][10];///寻找路径 问题：来过便不再来int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};struct node{    int x, y, pre;///a[i].pre存它前一个点在a[]中标号（序号）}a[30];void print(node t){    vector&lt;node&gt; vec;    while(t.pre != -1)///逆序存放    {        vec.push_back(t);        t = a[t.pre];    }    vec.push_back(a[0]);    int sz = vec.size();    for(int i = sz - 1; i &gt;= 0; --i)        printf(&quot;(%d, %d)\n&quot;, vec[i].x - 1, vec[i].y - 1);}void bfs(){    int now = 0;    int nxt = 1;    a[now].x = 1;    a[now].y = 1;    a[now].pre = -1;    vis[1][1] = 1;    while(now &lt; nxt)///等效于while(!q.empty())    {        if(a[now].x == 5 &amp;&amp; a[now].y == 5)        {            print(a[now]);            return ;        }        for(int i = 0; i &lt; 4; ++i)        {            int xx = a[now].x + dx[i];            int yy = a[now].y + dy[i];            if(xx &gt;= 1 &amp;&amp; xx &lt;= 5 &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= 5 &amp;&amp; m[xx][yy] == 0 &amp;&amp; !vis[xx][yy])            {                vis[xx][yy] = 1;                a[nxt].x = xx;                a[nxt].y = yy;                a[nxt].pre = now;                nxt++;///搜到终点，周围点条件不满足此if,nxt停增            }        }        now++;    }}int main(){    for(int i = 1; i &lt;= 5; ++i)        for(int j = 1; j &lt;= 5; ++j)        scanf(&quot;%d&quot;, &amp;m[i][j]);    bfs();    return 0;}</code></pre><h3 id="SDNUOJ-1220-Look-for-homework"><a href="#SDNUOJ-1220-Look-for-homework" class="headerlink" title="SDNUOJ 1220 Look for homework"></a>SDNUOJ 1220 Look for homework</h3><p><strong>题目链接</strong> <a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1220" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/problem/show/1220</a></p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;string s[15];bool vis[15][15];///“目标方向”逆时针转90°即可，想图（ignore this sentence）/// D L R Uint dx[] = {1, 0, 0, -1};int dy[] = {0, -1, 1, 0};struct node{    int x, y, pre, step;    char ch;} a[105];void print(node t){    vector&lt;node&gt; vec;    while(t.pre != -1)    {        vec.push_back(t);        t = a[t.pre];    }    int sz = vec.size();    for(int i = sz - 1; i &gt;= 0; --i)    {        cout &lt;&lt; vec[i].ch;//        cout &lt;&lt; vec[i].x &lt;&lt; &#39; &#39; &lt;&lt; vec[i].y &lt;&lt; &#39;\n&#39;;    }    cout &lt;&lt; &#39;\n&#39;;}void bfs(){    int now = 0;    int nxt = 1;    a[now].x = 0;    a[now].y = 0;    a[now].pre = -1;    a[now].step = 0;    vis[0][0] = 1;    while(now &lt; nxt)    {        if(a[now].x == n - 1 &amp;&amp; a[now].y == m - 1)        {            cout &lt;&lt; a[now].step &lt;&lt; &#39;\n&#39;;            print(a[now]);            return ;        }        for(int i = 0; i &lt; 4; ++i)        {            int xx = a[now].x + dx[i];            int yy = a[now].y + dy[i];            if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; !vis[xx][yy] &amp;&amp; s[xx][yy] == &#39;0&#39;)///注意这里是字符0            {                vis[xx][yy] = 1;///又忘了访问后标记                a[nxt].x = xx;                a[nxt].y = yy;                a[nxt].step = a[now].step + 1;                a[nxt].pre = now;                switch(i)                {                case 0:                    a[nxt].ch = &#39;D&#39;;                    break;                case 1:                    a[nxt].ch = &#39;L&#39;;                    break;                case 2:                    a[nxt].ch = &#39;R&#39;;                    break;                default:                    a[nxt].ch = &#39;U&#39;;                }                nxt++;            }        }        now++;    }}int main(){//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(vis, 0, sizeof(vis));        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        bfs();    }    return 0;}</code></pre><h3 id="POJ-3414-Pots"><a href="#POJ-3414-Pots" class="headerlink" title="POJ 3414 Pots"></a>POJ 3414 Pots</h3><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=3414" target="_blank" rel="noopener">http://poj.org/problem?id=3414</a></p><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int a, b, c;bool vis[1005][1005];map&lt;int, string&gt; mp;void init(){    mp[0] = &quot;FILL(1)&quot;;    mp[1] = &quot;FILL(2)&quot;;    mp[2] = &quot;DROP(1)&quot;;    mp[3] = &quot;DROP(2)&quot;;    mp[4] = &quot;POUR(1,2)&quot;;    mp[5] = &quot;POUR(2,1)&quot;;}struct status{    int p1, p2, step, pre;    string s;} d[1005];int bfs(){    memset(vis, 0, sizeof(vis));    int now = 0;    int nxt = 1;    d[now].p1 = 0;    d[now].p2 = 0;    d[now].step = 0;    d[now].pre = -1;    vis[0][0] = 1;    while(now &lt; nxt)    {//        cout &lt;&lt; now &lt;&lt; &#39; &#39; &lt;&lt; d[now].p1 &lt;&lt; &#39; &#39; &lt;&lt; d[now].p2 &lt;&lt; &#39; &#39; &lt;&lt; d[now].step &lt;&lt; &#39; &#39; &lt;&lt; d[now].pre &lt;&lt; &#39; &#39; &lt;&lt; d[now].s &lt;&lt; &#39;\n&#39;;        if(d[now].p1 == c || d[now].p2 == c)            return now;        if(d[now].p1 &lt; a &amp;&amp; !vis[a][d[now].p2])        {            vis[a][d[now].p2] = 1;            d[nxt].p1 = a;            d[nxt].p2 = d[now].p2;            d[nxt].step = d[now].step + 1;            d[nxt].pre = now;            d[nxt].s = mp[0];            nxt++;        }        if(d[now].p2 &lt; a &amp;&amp; !vis[d[now].p1][b])        {            vis[d[now].p1][b] = 1;            d[nxt].p1 = d[now].p1;            d[nxt].p2 = b;            d[nxt].step = d[now].step + 1;            d[nxt].pre = now;            d[nxt].s = mp[1];            nxt++;        }        if(d[now].p1 != 0 &amp;&amp; !vis[0][d[now].p2])        {            vis[0][d[now].p2] = 1;            d[nxt].p1 = 0;            d[nxt].p2 = d[now].p2;            d[nxt].step = d[now].step + 1;            d[nxt].pre = now;            d[nxt].s = mp[2];            nxt++;        }        if(d[now].p2 != 0 &amp;&amp; !vis[d[now].p1][0])        {            vis[d[now].p1][0] = 1;            d[nxt].p1 = d[now].p1;            d[nxt].p2 = 0;            d[nxt].step = d[now].step + 1;            d[nxt].pre = now;            d[nxt].s = mp[3];            nxt++;        }        if(d[now].p1 != 0 &amp;&amp; d[now].p2 &lt; b)/// A -&gt; B        {            if(d[now].p1 &gt;= b - d[now].p2)///A剩的多余B缺的            {                int t = b - d[now].p2;                if(!vis[d[now].p1 - t][b])                {                    vis[d[now].p1 - t][b] = 1;                    d[nxt].p1 = d[now].p1 - t;                    d[nxt].p2 = b;                    d[nxt].step = d[now].step + 1;                    d[nxt].pre = now;                    d[nxt].s = mp[4];                    nxt++;                }            }            else///A所剩少于B所缺            {                if(!vis[0][d[now].p2 + d[now].p1])                {                    vis[0][d[now].p2 + d[now].p1] = 1;                    d[nxt].p1 = 0;                    d[nxt].p2 = d[now].p2 + d[now].p1;                    d[nxt].step = d[now].step + 1;                    d[nxt].pre = now;                    d[nxt].s = mp[4];///注意                    nxt++;                }            }        }        if(d[now].p1 &lt; a &amp;&amp; d[now].p2 != 0)/// B -&gt; A        {            if(d[now].p2 &gt;= a - d[now].p1)/// B中剩的多            {                int t = a - d[now].p1;                if(!vis[a][d[now].p2 - t])                {                    vis[a][d[now].p2 - t] = 1;                    d[nxt].p1 = a;                    d[nxt].p2 = d[now].p2 - t;                    d[nxt].step = d[now].step + 1;                    d[nxt].pre = now;                    d[nxt].s = mp[5];                    nxt++;                }            }            else ///A中缺的多            {                if(!vis[d[now].p1 + d[now].p2][0])                {                    vis[d[now].p1 + d[now].p2][0] = 1;                    d[nxt].p1 = d[now].p1 + d[now].p2;                    d[nxt].p2 = 0;                    d[nxt].step = d[now].step + 1;                    d[nxt].pre = now;                    d[nxt].s = mp[5];                    nxt++;                }            }        }        now++;///漏了这句    }    return inf;}int main(){    init();    while(~scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c))    {        int ans = bfs();        if(ans != inf)        {            cout &lt;&lt; d[ans].step &lt;&lt; &#39;\n&#39;;            vector&lt;status&gt; vec;            while(d[ans].pre != -1)            {                vec.push_back(d[ans]);                ans = d[ans].pre;            }            int sz = vec.size();            for(int i = sz - 1; i &gt;= 0; --i)                cout &lt;&lt; vec[i].s &lt;&lt; &#39;\n&#39;;        }        else            cout &lt;&lt; &quot;impossible&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uva 11624 Fire!</title>
      <link href="2019/03/18/uva-11624/"/>
      <url>2019/03/18/uva-11624/</url>
      
        <content type="html"><![CDATA[<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>帮助J走出一个大火蔓延的迷宫。J每分钟可以超上下左右四个方向移动，而所有着火的格子每一分钟都会往四个方向蔓延一格。迷宫中有一些障碍，J和火都无法进入。当J走出迷宫的边界时，逃离成功。 </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="https://vjudge.net/problem/UVA-11624" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-11624</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>先将火蔓延到所有点的最短时间通过bfs求出来（到不了的地方初始化为无穷大）</p><p>然后再对人行走的过程用bfs进行模拟，从而计算出该人到达每个点的最短时间（如果人到达该点的最短时间晚于火到达的最短时间，那么该点不能走 ）</p><p>注意：开始时起火的格子可能不止一个</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m;char mp[1005][1005];///存图bool vis[1005][1005];///bfs 的辅助（这种vis[数组]可多次使用）int fire[1005][1005];///火蔓延到某点所需时间int dx[] = {0, 0, 1, -1};int dy[] = {1, -1, 0, 0};struct node{    int x, y, step;};void fire_bfs(queue&lt;node&gt; f){    node first;    while(f.size())    {        first = f.front();        f.pop();        for(int i = 0; i &lt; 4; ++i)        {            int xx = first.x + dx[i];            int yy = first.y + dy[i];            ///多一个判断条件多省一些时间            if(xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; mp[xx][yy] == &#39;.&#39; &amp;&amp; fire[xx][yy] == inf)            {                node t;                t.x = xx;                t.y = yy;                t.step = first.step + 1;                fire[xx][yy] = t.step;///特别注意判断条件对应量的改动，否则判断失效                f.push(t);            }        }    }}void bfs(int jx, int jy){    node tj, tem, nxt;    tj.x = jx;    tj.y = jy;    tj.step = 0;    vis[jx][jy] = 1;///刚开始忘了这句    queue&lt;node&gt; j;    j.push(tj);    while(j.size())    {        tem = j.front();        j.pop();        if(tem.x == 1 || tem.x == n || tem.y == 1 || tem.y == m)        {            cout &lt;&lt; tem.step + 1 &lt;&lt; &#39;\n&#39;;            return ;        }        for(int i = 0; i &lt; 4; ++i)        {            nxt.x = tem.x + dx[i];            nxt.y = tem.y + dy[i];            nxt.step = tem.step + 1;            if(nxt.x &gt;= 1 &amp;&amp; nxt.x &lt;= n &amp;&amp; nxt.y &gt;= 1 &amp;&amp; nxt.y &lt;= m &amp;&amp; mp[nxt.x][nxt.y] == &#39;.&#39; &amp;&amp; vis[nxt.x][nxt.y] == 0 &amp;&amp; fire[nxt.x][nxt.y] &gt; nxt.step)            {                vis[nxt.x][nxt.y] = 1;                j.push(nxt);            }        }    }    cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; &#39;\n&#39;;}int main(){    int t;//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    cin &gt;&gt; t;    while(t--)    {        queue&lt;node&gt; f;        int jx, jy;        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);        getchar();        memset(mp, 0, sizeof(mp));        memset(vis, 0, sizeof(vis));        memset(fire, inf, sizeof(fire));        for(int i = 1; i &lt;= n; ++i)///存图最好不从0开始存        {            for(int j = 1; j &lt;= m; ++j)            {                scanf(&quot;%c&quot;, &amp;mp[i][j]);                if(mp[i][j] == &#39;F&#39;)                {                    node tf;                    tf.x = i;                    tf.y = j;                    tf.step = 0;                    fire[i][j] = 0;                    f.push(tf);                }                if(mp[i][j] == &#39;J&#39;)                {                    jx = i;                    jy = j;                }            }            getchar();        }//        for(int i = 1; i &lt;= n; ++i)//        {//            for(int j = 1; j &lt;= m; ++j)//                cout &lt;&lt; mp[i][j];//            cout &lt;&lt; &#39;\n&#39;;//        }        fire_bfs(f);        bfs(jx, jy);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sprintf</title>
      <link href="2019/03/17/sprintf/"/>
      <url>2019/03/17/sprintf/</url>
      
        <content type="html"><![CDATA[<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><blockquote><p>#include <cstring\> </cstring\></p></blockquote><h3 id="作用之一"><a href="#作用之一" class="headerlink" title="作用之一"></a>作用之一</h3><blockquote><p>数字转字符串</p></blockquote><a id="more"></a><h3 id="HDU-6468"><a href="#HDU-6468" class="headerlink" title="HDU 6468"></a>HDU 6468</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6468" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=6468</a></p><h3 id="Code-of-TLE"><a href="#Code-of-TLE" class="headerlink" title="Code of TLE"></a>Code of TLE</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6 + 5;struct node{    char s[10];} a[N];bool cmp(node a, node b){    return strcmp(a.s, b.s) &lt; 0;}void slove(int n, int k){    for(int i = 1; i &lt;= n; ++i)        sprintf(a[i].s, &quot;%d&quot;, i);    sort(a + 1, a + n + 1, cmp);    cout &lt;&lt; a[k].s &lt;&lt; &#39;\n&#39;;}int main(){    int t, n, k;    cin &gt;&gt; t;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);        slove(n, k);    }    return 0;}</code></pre><blockquote><p>虽然这份代码超时了，但sprintf的这个作用还是很强的，不知道他之前还模拟这个过程</p></blockquote><h3 id="Code-of-privious-TLE"><a href="#Code-of-privious-TLE" class="headerlink" title="Code of privious TLE"></a>Code of privious TLE</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string s[1000005];bool cmp(string a, string b){    return a &lt; b;}int main(){    int t;    cin &gt;&gt; t;    int n, k;    while(t--)    {        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);        for(int i = 1; i &lt;= n; ++i)        {            int tem = i;            while(tem)            {                s[i] = s[i] + char(tem % 10 + &#39;0&#39;);                tem /= 10;            }            reverse(s[i].begin(), s[i].end());        }        sort(s + 1, s + n + 1, cmp);        cout &lt;&lt; s[k] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="还有stringstream的按空格截取"><a href="#还有stringstream的按空格截取" class="headerlink" title="还有stringstream的按空格截取"></a>还有stringstream的按空格截取</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int t;    cin &gt;&gt; t;    getchar();    while(t--)    {        string s, tem;        getline(cin, s);        bool flag = 0;        ///按空格截取s为tem        stringstream ss(s);        while(ss &gt;&gt; tem)        {            if(flag)                cout &lt;&lt; &#39; &#39;;            flag = 1;            reverse(tem.begin(), tem.end());            cout &lt;&lt; tem ;        }        cout &lt;&lt; &#39;\n&#39;;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 大数</title>
      <link href="2019/03/15/JAVA-%E5%A4%A7%E6%95%B0/"/>
      <url>2019/03/15/JAVA-%E5%A4%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>条件判断：</strong> JAVA中<code>while(n-- &gt; 0)</code>异于c++的<code>while(n--)</code></p><p><strong>Prepare to Input</strong></p><pre><code class="lang-java">Scanner in = new Scanner(System.in);//in可换为cin或scan//......in.close();//in可换cin或scan</code></pre><a id="more"></a><h3 id="Input-、Initialize-and-Output"><a href="#Input-、Initialize-and-Output" class="headerlink" title="Input 、Initialize and Output"></a>Input 、Initialize and Output</h3><pre><code class="lang-java">import java.math.BigDecimal;import java.math.BigInteger;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in = new Scanner(System.in);        //以下输入后面的括号是用于进制转换的，输入某进制数将其转十进制        //JAVA强大处之一        int a = in.nextInt();        double b = in.nextDouble();        BigInteger c = in.nextBigInteger();        BigDecimal d = in.nextBigDecimal();        in.nextLine();//getchar();        String k = in.next();        //cin &gt;&gt; k;        String e = in.nextLine();    //getline(cin, e);        int f = 6;        double g = 3.1415926;        BigInteger h = new BigInteger(&quot;666&quot;);//不带引号毁精度        BigDecimal i = new BigDecimal(&quot;3.1415926&quot;);        String j = &quot;LX&quot;;        System.out.println(a);        System.out.println(b);        System.out.println(c);        System.out.println(d);        System.out.println(e);        System.out.println(f);        System.out.println(g);        System.out.println(h);        System.out.println(i);        System.out.println(j);        System.out.printf(&quot;%d\n&quot;,a);        in.close();    }}</code></pre><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><pre><code class="lang-java">BigInteger a = BigInteger.valueOf(200);//无引号BigInteger b = BigInteger.TEN;a = a.add(b);a = a.subtract(b);a = a.multiply(b);a = a.divide(b);a = a.mod(b);</code></pre><p><strong>HDU 1002(大数加法)</strong></p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1002" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1002</a></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-java">import java.util.*;import java.io.BufferedInputStream;import java.math.BigInteger;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner cin = new Scanner(new BufferedInputStream(System.in));        int n = cin.nextInt();        int i = 1;        while(n-- &gt; 0)         {            BigInteger a = cin.nextBigInteger();            BigInteger b = cin.nextBigInteger();            System.out.println(&quot;Case &quot; + i + &quot;:&quot;);            System.out.println(a + &quot; + &quot; + b + &quot; = &quot; + a.add(b));            if(n &gt; 0)                System.out.println();            i++;        }        cin.close();    }}</code></pre><h2 id="HDU-1042-（N-）"><a href="#HDU-1042-（N-）" class="headerlink" title="HDU 1042 （N!）"></a>HDU 1042 （N!）</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1042" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1042</a></p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-java">import java.io.BufferedInputStream;import java.math.BigInteger;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in = new Scanner(new BufferedInputStream(System.in));        while(in.hasNextInt()) {            int n = in.nextInt();            BigInteger ans = new BigInteger(&quot;1&quot;);            BigInteger num = new BigInteger(&quot;1&quot;);            for(int i = 1; i &lt;= n; ++i) {                ans = ans.multiply(num);                num = num.add(new BigInteger(&quot;1&quot;));            }            System.out.println(ans);        }        in.close();    }}</code></pre><h2 id="HDU-1250-Fibonacci"><a href="#HDU-1250-Fibonacci" class="headerlink" title="HDU 1250(Fibonacci)"></a>HDU 1250(Fibonacci)</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1250" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1250</a></p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">import java.io.BufferedInputStream;import java.math.BigInteger;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in = new Scanner(new BufferedInputStream(System.in));        BigInteger [] f = new BigInteger[10005];        f[1] = f[2] = f[3] = f[4] = new BigInteger(&quot;1&quot;);        for(int i = 5; i &lt; 10005; ++i)            f[i] = f[i - 1].add(f[i - 2]).add(f[i - 3]).add(f[i - 4]);        while(in.hasNext()) {            int n = in.nextInt();            System.out.println(f[n]);        }        in.close();    }}</code></pre><h2 id="POJ-3199（N-M）"><a href="#POJ-3199（N-M）" class="headerlink" title="POJ 3199（N ^ M）"></a>POJ 3199（N ^ M）</h2><p><a href="http://poj.org/problem?id=3199" target="_blank" rel="noopener">http://poj.org/problem?id=3199</a></p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-java">import java.io.BufferedInputStream;import java.math.BigInteger;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in = new Scanner(new BufferedInputStream(System.in));        BigInteger n, m, ans;        while(in.hasNext()) {            n = in.nextBigInteger();            m = in.nextBigInteger();            if(n.compareTo(BigInteger.ZERO) == 0 &amp;&amp; m.compareTo(BigInteger.ZERO) == 0)                break;            ans = n.pow(m.intValue());            System.out.println(ans);        }        in.close();    }}</code></pre><h3 id="关于compareTo"><a href="#关于compareTo" class="headerlink" title="关于compareTo"></a>关于compareTo</h3><blockquote><p>compareTo() 方法用于将 Number 对象与方法的参数进行比较。可用于比较 Byte, Long, Integer等。</p><p>该方法用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。</p></blockquote><ul><li>如果指定的数与参数相等返回0。</li><li>如果指定的数小于参数返回 -1。</li><li>如果指定的数大于参数返回 1。</li></ul><p>还有记得<code>ans = n.pow(m.intValue());</code></p><h3 id="SDNU-1488"><a href="#SDNU-1488" class="headerlink" title="SDNU 1488"></a>SDNU 1488</h3><blockquote><p>输入两个八进制数a、b，也以八进制形式输出（a - b）的值。</p></blockquote><h4 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h4><pre><code class="lang-java">import java.math.BigInteger;import java.util.Scanner;public class Main {    public static void main(String[] args) {        // TODO Auto-generated method stub        Scanner in = new Scanner(System.in);        while(in.hasNextInt()) {            int t = in.nextInt();            while(t-- &gt; 0) {                //将数字以8进制读入并转为十进制                BigInteger c = in.nextBigInteger(8);                BigInteger d = in.nextBigInteger(8);                BigInteger ans;                if(c.subtract(d) == BigInteger.valueOf(1) || c == d);                    {                     ans = c.subtract(d);//十进制减法                     String a = ans.toString(8);//十进制数ans转为8进制字符串                    System.out.println(a);                    }                if(c.subtract(d) == BigInteger.valueOf(-1))                {                    ans = d.subtract(c);                    String a = ans.toString(8);                    System.out.println(&quot;-&quot; + a);                }            }        }        in.close();    }}</code></pre><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><blockquote><p>String a = ans.toString(num); //将十进制数ans转为num进制字符串</p></blockquote><h3 id="已知数字的进制转换"><a href="#已知数字的进制转换" class="headerlink" title="已知数字的进制转换"></a>已知数字的进制转换</h3><blockquote><p>十进制转其他进制</p></blockquote><pre><code class="lang-JAVA">        int i = 36;        String a = Integer.toBinaryString(i);//二        String b = Integer.toHexString(i);//十六        String c = Integer.toOctalString(i);//八        String d = Integer.toString(i,35);// &lt;= 35进制</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 其他语言のJAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2635 The Embarrassed Cryptographer</title>
      <link href="2019/03/15/POJ-2635-The-Embarrassed-Cryptographer/"/>
      <url>2019/03/15/POJ-2635-The-Embarrassed-Cryptographer/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>The young and very promising cryptographer Odd Even has implemented the security module of a large system with thousands of users, which is now in use in his company. The cryptographic keys are created from the product of two primes, and are believed to be secure because there is no known method for factoring such a product effectively.  </p></blockquote><a id="more"></a><blockquote><p>What Odd Even did not think of, was that both factors in a key should be large, not just their product. It is now possible that some of the users of the system have weak keys. In a desperate attempt not to be fired, Odd Even secretly goes through all the users keys, to check if they are strong enough. He uses his very poweful Atari, and is especially careful when checking his boss’ key. </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of no more than 20 test cases. Each test case is a line with the integers 4 &lt;= K &lt;= 10100 and 2 &lt;= L &lt;= 106. K is the key itself, a product of two primes. L is the wanted minimum size of the factors in the key. The input set is terminated by a case where K = 0 and L = 0. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each number K, if one of its factors are strictly less than the required L, your program should output “BAD p”, where p is the smallest factor in K. Otherwise, it should output “GOOD”. Cases should be separated by a line-break </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">143 10143 20667 20667 302573 302573 404 26 36 315 39999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     29999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     39999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     9999819999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     9999829999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     9999839999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     9999849999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999536689     9999859936798836621706335903766366605021199756127575438907144689843371764114998372849970522970722679648297     10000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999924165887     10000009999999999999999997709341477512928270733515750111494296807693217401592660013176273247584305454312971     10000009999999999988881245087379264540384030358544520360773252628174690915590034078934845096473005364364269     10000009999999999999999999999999999999999999999999999999999999999999999999997947710886296926452585995644787     10000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999998743929569     10000009999999999999999999999999999999999999999999999999999999999999999999999996406876316697599258447653751     10000009999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999995271511     10000009999664515006205757944572422495695942633452678405393581216966782816097132509526872495414067984894021     10000000 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="lang-c++">GOODBAD 11GOODBAD 23GOODBAD 31GOODBAD 2BAD 2GOODGOODGOODGOODGOODGOODBAD 999983BAD 999983BAD 587BAD 100043GOODGOODGOODGOODGOODBAD 16603BAD 9103</code></pre><p><strong>题解</strong> <a href="https://blog.csdn.net/lyy289065406/article/details/6648530" target="_blank" rel="noopener">https://blog.csdn.net/lyy289065406/article/details/6648530</a></p><h3 id="My-Code"><a href="#My-Code" class="headerlink" title="My Code"></a>My Code</h3><pre><code class="lang-c++">#include &lt;ctime&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000005;bool vis[N + 5];///我RE了一下午四处改动，最后竟是因为vis[N]这里小了！！！///因为会访问vis[N],数组开到N，自然最后到 N - 1int p[N + 5];int tot;int k[105];///千进制下的Kint L;void get_prime(){//    clock_t start, over;//    start = clock();    tot = 0;    memset(vis, 1, sizeof(vis));///初始化全为素数    vis[0] = vis[1] = 0;    for(int i = 2; i &lt;= N; ++i)    {        if(vis[i])            p[++tot] = i;        for(int j = 1; j &lt;= tot &amp;&amp; p[j] * i &lt;= N; ++j)        {            vis[ p[j] * i ] = 0;            if(i % p[j] == 0)                break;        }    }//    over = clock();//    cout &lt;&lt; (double)(over - start) / CLOCKS_PER_SEC &lt;&lt; &quot;(s)&quot; &lt;&lt; &#39;\n&#39;;//    cout &lt;&lt; &quot;tot : &quot; &lt;&lt; tot &lt;&lt; &#39;\n&#39;;    return ;}///大数（高精度）取模bool mod(int * k, int len, int p){    int ans = 0;    for(int i = len - 1; i &gt;= 0; --i)///逆序存放的        ans = (ans * 1000 + k[i]) % p;///同余模定理    if(!ans)///被整除        return 1;    else        return 0;}int main(){    get_prime();    char sk[105];//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(cin &gt;&gt; sk &gt;&gt; L &amp;&amp; L)    {        memset(k, 0, sizeof(k));        int sklen = strlen(sk);        ///十进制转千进制（局部“顺序”， 全局“逆序”）        ///如K=1234567=[  1][234][567] ，则Kt=[567][234][1  ]        for(int i = 0; i &lt; sklen; ++i)        {            int num = (sklen + 2 - i) / 3 - 1;            k[num] = k[num] * 10 + (sk[i] - &#39;0&#39;);        }        int klen = (sklen + 2) / 3;        bool flag = 1;        int idx = 1;///从第1个素数开始找        while(p[idx] &lt; L)        {            if(mod(k, klen, p[idx]))            {                flag = 0;                cout &lt;&lt; &quot;BAD &quot; &lt;&lt; p[idx] &lt;&lt; &#39;\n&#39;;                break;            }            idx++;        }        if(flag)            cout &lt;&lt; &quot;GOOD&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论の同余定理 </tag>
            
            <tag> 数论の大数求余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同余（模）定理</title>
      <link href="2019/03/14/%E5%90%8C%E4%BD%99%EF%BC%88%E6%A8%A1%EF%BC%89%E5%AE%9A%E7%90%86/"/>
      <url>2019/03/14/%E5%90%8C%E4%BD%99%EF%BC%88%E6%A8%A1%EF%BC%89%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="同余定义（德国-高斯）："><a href="#同余定义（德国-高斯）：" class="headerlink" title="同余定义（德国/高斯）："></a>同余定义（德国/高斯）：</h2><blockquote><p>两个整数 a、b，如果他们同时除以一个自然数p，所得的余数相同，则称a,b对于模p同余，记作a≡b（mod p）。读作：a同余于b模m。 </p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=505771816&auto=1&height=66"></iframe><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><blockquote><ol><li>(a + b) % p = (a % p + b % p) % p</li><li>(a - b) % p =  ( (a % p - b % p) + p ) % p</li><li>(a * b) % p = (a % p) * (b % p) % p</li><li>若 a ≡ b(mod p)，则 (a - b) mod p ≡ 0</li><li>若 a ≡ b(mod p)，则 (a ^ n) mod p ≡  (b ^ n) mod p</li></ol></blockquote><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><blockquote><p>求 2001 ^ 2003 % 13</p></blockquote><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><blockquote><p>2001 % 13 = 12，即2001 同余于 12 （模13）</p><p>根据性质5，原问题等于求 12 ^ 2003 % 13</p><p>找出 12 的几次幂 同余于 1 （模13），发现 12 ^ 2 ≡ 1 (mod 13)</p><p>(12 ^ 2003) % 13 = [ (12 ^ 2) ^ 1001   *   (12 ^ 1)] % 13 </p><p>根据性质5， 上式 = [ (1 ^ 1001)  *  (12 ^ 1) ] % 13 = 12 </p></blockquote><p><strong>也就口算笔算可以，用程序写出来实用性弱，远不如快速幂万能（在适合的情况下比快速幂快）</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">int same_remainer(int a, int b, int c){    a = a % c;    int t = 0;    for(int i = 1; i &lt; sqrt(b); ++i)    {        if(int(pow(a, i)) % c == 1)        {            t = i;            break;        }    }    for(int i = 0; t != 0; ++i)        if((b - i) % t == 0)        {            b = i;            break;        }    return (int)pow(a, b) % c;}</code></pre><h3 id="大数（高精度）求余"><a href="#大数（高精度）求余" class="headerlink" title="大数（高精度）求余"></a>大数（高精度）求余</h3><blockquote><p>1234 = ( (1 * 10 + 2) * 10 + 3 )  * 10 + 4</p><p>利用性质1、3可解</p><p>1234 % n = ((((1 * 10 ) % n + 2 % n) % n * 10 % n + 3 % n) % n * 10 % n + 4 % n)  % n</p></blockquote><h3 id="Code-大数求余"><a href="#Code-大数求余" class="headerlink" title="Code(大数求余)"></a>Code(大数求余)</h3><pre><code class="lang-c++">#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main(){    string a;    int n;    while(cin &gt;&gt; a &gt;&gt; n)    {        int ans = 0;        int sz = a.size();        for(int i = 0; i &lt; sz; ++i)            ans = ((ans * 10) % n + (a[i] - &#39;0&#39;) % n) % n;        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 数论の同余定理 </tag>
            
            <tag> 数论の大数求余 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 3279 Fliptile</title>
      <link href="2019/03/14/POJ-3279-Fliptile/"/>
      <url>2019/03/14/POJ-3279-Fliptile/</url>
      
        <content type="html"><![CDATA[<h2 id="关于翻转问题"><a href="#关于翻转问题" class="headerlink" title="关于翻转问题"></a>关于翻转问题</h2><blockquote><p>例:给定一个01串，现有翻转规则：</p><p>翻转某一个位置时其后面2个位置也会跟着翻转，也就是每次翻转都会翻转3个连续的位置。要将01串全部翻转为0，求最小的翻转次数</p><p>形似这类题的问题叫做翻转问题，也可以叫开关问题</p></blockquote><a id="more"></a><p><strong>原文出处</strong> <a href="https://blog.csdn.net/ac_hell/article/details/51077320" target="_blank" rel="noopener">https://blog.csdn.net/ac_hell/article/details/51077320</a></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>①.若某一个位置被翻转了n次，则其实际上被翻转了n%2次，因为翻转2k次相当与没翻转，翻转2k+1次相当于翻转了1次，因为要求最小翻转次数，所以对于某一个位置要么只（主动）翻转一次，要么不（主动）翻转。</p><p>②.分析易知翻转的顺序并不影响最终结果。（理解不了可自己举个例子在纸上模拟下）</p><p>③.现在我们着眼于第1个位置，可知若要将第1个位置进行翻转只有翻转它自己，因为没有其他位置的翻转会引起它的翻转。由①可知若第1个位置为1则必须且进行翻转（并将其后2个进行连带翻转）且以后不再进行翻转，因为再进行翻转就一共翻转了2次相当于没翻转。然后着眼于第2个位置，由于第1个位置不再进行翻转，所以要想翻转第2个位置只有翻转它自己，因为没有其他位置的翻转会引起它的翻转…………………以此类推直至最后剩下的个数＜3个，因为每次都翻转3个，而剩下的少于3个了就不再进行考虑了，此时只需判断剩下的是否全为0的即可，若不全为0，则不存在全部翻转为0的方案</p></blockquote><h2 id="POJ-3279"><a href="#POJ-3279" class="headerlink" title="POJ 3279"></a>POJ 3279</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Farmer John knows that an intellectually satisfied cow is a happy cow who will give more milk. He has arranged a brainy activity for cows in which they manipulate an <em>M</em> × <em>N</em> grid (1 ≤ <em>M</em> ≤ 15; 1 ≤ <em>N</em> ≤ 15) of square tiles, each of which is colored black on one side and white on the other side.</p><p>As one would guess, when a single white tile is flipped, it changes to black; when a single black tile is flipped, it changes to white. The cows are rewarded when they flip the tiles so that each tile has the white side face up. However, the cows have rather large hooves and when they try to flip a certain tile, they also flip all the adjacent tiles (tiles that share a full edge with the flipped tile). Since the flips are tiring, the cows want to minimize the number of flips they have to make.</p><p>Help the cows determine the minimum number of flips required, and the locations to flip to achieve that minimum. If there are multiple ways to achieve the task with the minimum amount of flips, return the one with the least lexicographical ordering in the output when considered as a string. If the task is impossible, print one line with the word “IMPOSSIBLE”.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em>  Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes the colors (left to right) of row i of the grid with <em>N</em> space-separated integers which are 1 for black and 0 for white </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>Lines 1..<em>M</em>: Each line contains <em>N</em> space-separated integers, each specifying how many times to flip that particular location. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>4 4</p><p>1 0 0 1</p><p>0 1 1 0</p><p>0 1 1 0</p><p>1 0 0 1</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0 0 0 0</p><p>1 0 0 1</p><p>1 0 0 1</p><p>0 0 0 0</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>1代表黑色格子，0代表白色格子，目标是把黑色全翻转为白色</p><p>但翻转任意一个格子，与他相邻的格子都会被翻转</p><p>求解最小翻转方案</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;bool a[20][20];///a[i][j]若为1表示坐标为(i, j)的格子是黑色的，0表示白色bool b[20][20];///b[i][j]若为1表示(在当前方案中)坐标为(i, j)的格子作出翻转，0表示不转bool ans[20][20];int dx[] = {-1, 1, 0, 0, 0};int dy[] = {0, 0, 0, -1, 1};int n, m;int step_min = inf;///a[i][j]与b[i][j]都不代表翻转后(i, j)格子的颜色，可以用以下color函数找bool color(int x, int y){    int flag = a[x][y];    ///它现在的颜色受其上下左右中是否翻转的影响    for(int i = 0; i &lt; 5; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m)            flag += b[xx][yy];    }    return flag &amp; 1;}int slove(){    int sum = 0;    for(int i = 2; i &lt;= n; ++i)///从第二行起检测是否需要反转        for(int j = 1; j &lt;= m; ++j)            if(color(i - 1, j))///如果它上面是黑色，那么这格需要反转                b[i][j] = 1;    ///检测最后一行是否全白    for(int i = 1; i &lt;= m; ++i)        if(color(n, i))            return inf;    ///计算总翻转次数    for(int i = 1; i &lt;= n; ++i)        for(int j = 1; j &lt;= m; ++j)            sum += b[i][j];    return sum;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++i)///涉及坐标问题，下标从1开始        for(int j = 1; j &lt;= m; ++j)            cin &gt;&gt; a[i][j];    ///（按照字典序）枚举第一行所有的翻转方案    for(int num = 0; num &lt; (1 &lt;&lt; m); ++num)    {        memset(b, 0, sizeof(b));        for(int i = 1; i &lt;= m; ++i)            b[1][i] = num &gt;&gt; (m - i) &amp; 1;        int tem = slove();        if(tem &lt; step_min)        {            step_min = tem;            memcpy(ans, b, sizeof(b));        }    }    if(step_min == inf)        cout &lt;&lt; &quot;IMPOSSIBLE&quot; &lt;&lt; &#39;\n&#39;;    else    {        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= m; ++j)                printf(&quot;%d%c&quot;, ans[i][j], j == m ? &#39;\n&#39;: &#39; &#39; );    }    return 0;}</code></pre><h3 id="部分代码解释"><a href="#部分代码解释" class="headerlink" title="部分代码解释"></a>部分代码解释</h3><pre><code class="lang-c++">///（按照字典序）枚举第一行所有的翻转方案for(int num = 0; num &lt; (1 &lt;&lt; m); ++num)</code></pre><p>这就相当于一个集合有m个元素，则有 （2 ^ m）个子集。</p><p>对应着，第一行有m个元素，有（2 ^ m）种翻转方案</p><pre><code class="lang-c++">for(int i = 1; i &lt;= m; ++i)            b[1][i] = num &gt;&gt; (m - i) &amp; 1;</code></pre><p>这是按照字典序枚举了第一行的所有翻转方案，效果如下</p><pre><code class="lang-c++">0 0 0 00 0 0 10 0 1 00 0 1 10 1 0 00 1 0 10 1 1 00 1 1 11 0 0 01 0 0 11 0 1 01 0 1 11 1 0 01 1 0 11 1 1 01 1 1 1</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の翻转问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>尺取法</title>
      <link href="2019/03/12/%E5%B0%BA%E5%8F%96%E6%B3%95/"/>
      <url>2019/03/12/%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="尺取法"><a href="#尺取法" class="headerlink" title="尺取法"></a>尺取法</h3><blockquote><p>尺取，取的是 ： 多段等效区间（等效体现在：满足题目要求）</p><p>某些时候需要保证数列的单调性才能使用</p></blockquote><a id="more"></a><h3 id="POJ-3061"><a href="#POJ-3061" class="headerlink" title="POJ 3061"></a>POJ 3061</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>A sequence of N positive integers (10 &lt; N &lt; 100 000), each of them less than or equal 10000, and a positive integer S (S &lt; 100 000 000) are given. Write a program to find the minimal length of the subsequence of consecutive elements of the sequence, the sum of which is greater than or equal to S. </p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>The first line is the number of test cases. For each test case the program has to read the numbers N and S, separated by an interval, from the first line. The numbers of the sequence are given in the second line of the test case, separated by intervals. The input will finish with the end of file. </p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>For each the case the program has to print the result on separate line of the output file.if no answer, print 0. </p></blockquote><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><pre><code class="lang-c++">210 155 1 3 5 10 7 4 9 2 85 111 2 3 4 5</code></pre><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><blockquote><p>2</p><p>3</p></blockquote><h4 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h4><blockquote><p>给出长为n的数列，求出总和不小于S的连续子序列的最小长度 </p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>“<strong>连续</strong>子序列”体现尺取的特点，而且不需要数列单调</p></blockquote><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int t, n, s;int a[100005];void slove(){    int ans = n;    int l = 0, r = 0, sum = 0, len = 0;    while(r &lt;= n - 1)    {        while(sum &lt; s &amp;&amp; r &lt;= n - 1)        {            sum += a[r];            ++r;            ++len;        }        while(sum &gt;= s)///退出时sum &lt; s(所以下面len + 1)        {            sum -= a[l];            ++l;            --len;        }        ans = min(ans, len + 1);    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;}int main(){    cin &gt;&gt; t;    while(t--)    {        int sum = 0;        scanf(&quot;%d%d&quot;, &amp;n, &amp;s);        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            sum += a[i];        }        if(sum &lt; s)            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39;\n&#39;;        else            slove();    }    return 0;}</code></pre><h3 id="POJ-2566"><a href="#POJ-2566" class="headerlink" title="POJ 2566"></a>POJ 2566</h3><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote><p>给出一个整数列，求一段子序列之和的绝对值最接近所给出的t。输出该段子序列之和及左右端点。 </p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><blockquote><p>PS：（任意两个前缀和的差值取abs）得到对应区间的和的abs</p><p>此题等效区间的“等效”在于：某个区间和的abs（即某两个前缀和的差值）十分接近t</p><p>1.输入时计算前缀和（sum[i].val）及当前位置(sum[i].pos)</p><p>2.根据val排序</p><p>3.依次尺取得到一个个的某区间的和的abs，这些值是某种意义上的“等效”</p><p>（正是由于排序才有的一段段等效区间）</p><p>4.更新（不断更新至遍历完成找到答案）</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;int n, k;struct LX{    int val, pos;}sum[N];bool cmp(LX a, LX b){    return a.val &lt; b.val;}void slove(int t){    int tem;///某个区间和的绝对值    int mmin = inf;///tem与t的最小差值    int ans;    int l = 0, r = 1, tl = l, tr = r;///L从0开始不会漏区间    while(r &lt;= n &amp;&amp; mmin != 0)    {        ///不要以为sum[2] - sum[4]是不合理的（是区间[3,4]内元素和的abs）        ///这里tem取的是区间[l + 1, r]        tem = abs(sum[r].val - sum[l].val);        if(abs(tem - t) &lt; mmin)///更新        {            mmin = abs(tem - t);            ans = tem;            tl = sum[l].pos;            tr = sum[r].pos;        }        if(tem &lt; t)            r++;        if(tem &gt; t)            l++;        if(l == r)            r++;    }    if(tl &gt; tr)        swap(tl, tr);    cout &lt;&lt; ans &lt;&lt; &#39; &#39; &lt;&lt; tl + 1 &lt;&lt; &#39; &#39; &lt;&lt; tr &lt;&lt; &#39;\n&#39;;}int main(){//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; n &amp;&amp; k)    {        int t;        int tem = 0;        sum[0].val = 0;        sum[0].pos = 0;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;tem);            sum[i].val = sum[i - 1].val + tem;            sum[i].pos = i;        }        sort(sum , sum + 1 + n, cmp);///0也参与排序可检测区间[1,1]//        for(int i = 0; i &lt;= n; ++i)//            cout &lt;&lt; sum[i].val &lt;&lt; &#39; &#39;;//        cout &lt;&lt; &#39;\n&#39;;        for(int i = 0; i &lt; k; ++i)        {            scanf(&quot;%d&quot;, &amp;t);            slove(t);        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の尺取法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异或寻异</title>
      <link href="2019/03/11/%E5%BC%82%E6%88%96%E5%AF%BB%E5%BC%82/"/>
      <url>2019/03/11/%E5%BC%82%E6%88%96%E5%AF%BB%E5%BC%82/</url>
      
        <content type="html"><![CDATA[<h3 id="关于异或"><a href="#关于异或" class="headerlink" title="关于异或"></a>关于异或</h3><blockquote><p>a为任意数字：</p><p>0 ^ a = a</p><p>a ^ a = 0</p></blockquote><a id="more"></a><h3 id="给出n个数字，-有一个数字只出现奇数次，其余出现偶数次，找出这个数字"><a href="#给出n个数字，-有一个数字只出现奇数次，其余出现偶数次，找出这个数字" class="headerlink" title="给出n个数字， 有一个数字只出现奇数次，其余出现偶数次，找出这个数字"></a>给出n个数字， 有一个数字只出现奇数次，其余出现偶数次，找出这个数字</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;int a[1000005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        if(n == 0)            break;        int ans = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            ans ^= a[i];        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="给出n个数字，有两个数字只出现奇数次，其余出现偶数次，找出这两个数字"><a href="#给出n个数字，有两个数字只出现奇数次，其余出现偶数次，找出这两个数字" class="headerlink" title="给出n个数字，有两个数字只出现奇数次，其余出现偶数次，找出这两个数字"></a>给出n个数字，有两个数字只出现奇数次，其余出现偶数次，找出这两个数字</h3><p><strong>更多解析</strong> <a href="https://www.jianshu.com/p/cb400b455772" target="_blank" rel="noopener">https://www.jianshu.com/p/cb400b455772</a></p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[1000005];int find_pos(int tem){    int pos = 0;    while(!(tem &amp; 1))    {        tem &gt;&gt;= 1;        pos++;    }    return pos;}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        int ans = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            ans ^= a[i];        }        int res = ans;        int pos = find_pos(ans);        for(int i = 0; i &lt; n; ++i)        {            if((a[i] &gt;&gt; pos) &amp; 1)                ans ^= a[i];        }        res ^= ans;///ÎÞÐòÊä³ö        cout &lt;&lt; ans &lt;&lt; &#39; &#39; &lt;&lt; res &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="给出n个数字，有三个数字只出现一次，其余出现两次，找出这三个数字"><a href="#给出n个数字，有三个数字只出现一次，其余出现两次，找出这三个数字" class="headerlink" title="给出n个数字，有三个数字只出现一次，其余出现两次，找出这三个数字"></a>给出n个数字，有三个数字只出现一次，其余出现两次，找出这三个数字</h3><blockquote><p>设f(n)为n最低位1所在位。</p><p>全部异或一次，得 x = a ^ b ^ c.(倘若保证 x != 0问题就像上面一样简单了)</p><p>x 不是 a、b、c 中的任一个</p><p>（反证：假设x = a, 由 a = a ^ b ^ c 得 b ^ c = 0, 得 b = c, 与题目矛盾）</p><p>所以 x ^ a, x ^ b, x ^ c 都不为0，所以f(x ^ a), f(x ^ b), f(x ^ c)都不为0，</p><p>那么 y = f(x ^ a) ^ f(x ^ b) ^ f(x ^ c) 也不为0 </p><p>所以 y 的二进制至少有一位是1，假设其最低位1在M位上</p><div class="table-container"><table><thead><tr><th>f(x ^ a)</th><th>f(x ^ b)</th><th>f(x ^ c)</th><th>y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>有以下两种情况：</p><p>1.<strong>f(x ^ a),f(x ^ b),f(x ^ c)三个式子中只有一个，其第M位是1</strong></p><p>2.三个式子第M位皆为1（倘若仅两个式子第M位为1，y的第M位是0）</p><p>第二种情况是错误的，反驳如下：</p><p>假设2成立，那么 (x ^ a) ^ (x ^ b) ^ (x ^ c) 其第M位 = 1^1^1 = 1,然而</p><p>(x ^ a) ^ (x ^ b) ^ (x ^ c) = x ^ x ^ x ^ (a ^ b ^ c) = x ^ x ^ x ^ x第M位为0</p></blockquote><p><strong>根据结论 <em>x ^ a, x ^ b, x ^ c三个式子只有一个，其第M位为0</em> 找到一个数字，再按前面的方法找另两个</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;///a为任意数字:/// 0 ^ a = a/// a ^ a = 0int a[1000005];int find_pos(int tem){    if(tem == 0)        return 0;    int pos = 1;    while(!(tem &amp; 1))    {        tem &gt;&gt;= 1;        pos++;    }    return pos;}int main(){    int n;//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(~scanf(&quot;%d&quot;, &amp;n))    {        int first = 0;        int second, third;        int x = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i]);            x ^= a[i];        }        ///找 f(x ^ a) ^ f(x ^ b) ^ f(x ^ c)        int y = 0;        for(int i = 0; i &lt; n; ++i)        {            int t = x ^ a[i];            int tem = find_pos(x ^ a[i]);            y ^= tem;        }        int M = find_pos(y);        ///利用结论找到第一个特别的数字        for(int i = 0; i &lt; n; ++i)        {            if((   find_pos(x ^ a[i])&gt;&gt;(M - 1)   )  &amp;  1)                first ^= a[i];        }        ///问题简化        int ans = x ^ first;        int t = ans;        ///first丢到后面去        for(int i = 0; i &lt; n; ++i)        {            if(a[i] == first)            {                swap(a[i], a[n - 1]);                break;            }        }        ///找剩余两个数字        int pos = find_pos(ans);        for(int i = 0; i &lt; n - 1; ++i)        {            if((a[i] &gt;&gt; (pos - 1)) &amp; 1)                ans ^= a[i];        }        second = ans;        third = t ^ ans;///此输出无序        cout &lt;&lt; first &lt;&lt; &#39; &#39; &lt;&lt; second &lt;&lt; &#39; &#39; &lt;&lt; third &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 技巧の异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDUT Balloons 和 HDU 1241 Oil Deposits</title>
      <link href="2019/03/09/SDUT-Balloons/"/>
      <url>2019/03/09/SDUT-Balloons/</url>
      
        <content type="html"><![CDATA[<h3 id="题目共同解法"><a href="#题目共同解法" class="headerlink" title="题目共同解法"></a>题目共同解法</h3><blockquote><p>都是求某一类连接成块共有多少块，那么对每一块dfs，运行多少次dfs便有多少块</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Both Saya and Kudo like balloons. One day, they heard that in the central park, there will be thousands of people fly balloons to pattern a big image.  They were very interested about this event, and also curious about the image. Since there are too many balloons, it is very hard for them to compute anything they need. Can you help them?  You can assume that the image is an <em>N\</em>N<em> matrix, while each element can be either balloons or blank.  Suppose element </em>A<em> and element </em>B* are both balloons. They are connected if: </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2152.html" target="_blank" rel="noopener">http://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/2152.html</a></p><blockquote><p>i) They are adjacent; ii) There is a list of element <em>C</em>1, <em>C</em>2, … , <em>C**n</em>, while <em>A</em> and <em>C</em>1 are connected, <em>C</em>1 and <em>C</em>2 are connected …<em>C**n</em> and <em>B</em> are connected. And a connected block means that every pair of elements in the block is connected, while any element in the block is not connected with any element out of the block. To Saya, element <em>A(xa,ya)</em>and <em>B(xb,yb)</em> is adjacent if |xa-xb| + |ya-yb| ≤ 1  But to Kudo, element <em>A(xa,ya)</em> and element B (xb,yb) is adjacent if |xa-xb|≤1 and |ya-yb|≤1 They want to know that there’s how     many connected blocks with there own definition of adjacent?</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of several test cases.  The first line of input in each test case contains one integer <em>N</em> (0&lt;<em>N</em>≤100), which represents the size of the matrix.  Each of the next <em>N</em> lines contains a string whose length is <em>N</em>, represents the elements of the matrix. The string only consists of 0 and 1, while 0 represents a block and 1represents balloons.  The last case is followed by a line containing one zero.    </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p> For each case, print the case number (1, 2 …) and the connected block’s numbers with Saya and Kudo’s definition. Your output format should imitate the sample output. Print a blank line after each test case.    </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">511001001001111111010100100</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Case 1: 3 2</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>1.细节</p><p>2.输出格式：“Case” 、 空行</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 110;int a, b, n;string s[N];bool visa[N][N];bool visb[N][N];int dx[] = {-1, 1, 0, 0, -1, 1, 1, -1};int dy[] = {0, 0, 1, -1, 1, 1, -1, -1};void dfsa(int x, int y){    visa[x][y] = 1;    for(int i = 0; i &lt; 4; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; !visa[xx][yy] &amp;&amp; s[xx][yy] == &#39;1&#39;)        {            visa[xx][yy] = 1;            dfsa(xx, yy);        }    }    return ;}void dfsb(int x, int y){    visb[x][y] = 1;    for(int i = 0; i &lt; 8; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; n &amp;&amp; !visb[xx][yy] &amp;&amp; s[xx][yy] == &#39;1&#39;)        {            visb[xx][yy] = 1;            dfsb(xx, yy);        }    }    return ;}int main(){    int cnt = 1;    while(cin &gt;&gt; n &amp;&amp; n)    {        memset(visa, 0, sizeof(visa));        memset(visb, 0, sizeof(visb));        a = 0, b = 0;        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; n; ++j)                if(s[i][j] == &#39;1&#39;)                {                    if(!visa[i][j])                    {                        dfsa(i, j);                        a++;                    }                    if(!visb[i][j])                    {                        dfsb(i, j);                        b++;                    }                }        cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt &lt;&lt; &quot;: &quot; &lt;&lt; a &lt;&lt; &#39; &#39; &lt;&lt; b &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;        cnt++;    }}</code></pre><h3 id="Description-1"><a href="#Description-1" class="headerlink" title="Description"></a>Description</h3><blockquote><p>The GeoSurvComp geologic survey company is responsible  for detecting underground oil deposits. GeoSurvComp works with one large  rectangular region of land at a time, and creates a grid that divides the land  into numerous square plots. It then analyzes each plot separately, using sensing  equipment to determine whether or not the plot contains oil. A plot containing  oil is called a pocket. If two pockets are adjacent, then they are part of the  same oil deposit. Oil deposits can be quite large and may contain numerous  pockets. Your job is to determine how many different oil deposits are contained  in a grid.  </p></blockquote><p><strong>题目链接</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1241" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1241</a></p><h3 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input file contains one or more grids. Each grid  begins with a line containing m and n, the number of rows and columns in the  grid, separated by a single space. If m = 0 it signals the end of the input;  otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m  lines of n characters each (not counting the end-of-line characters). Each  character corresponds to one plot, and is either `*’, representing the absence  of oil, or `@’, representing an oil pocket. </p></blockquote><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each grid, output the number of distinct oil  deposits. Two different pockets are part of the same oil deposit if they are  adjacent horizontally, vertically, or diagonally. An oil deposit will not  contain more than 100 pockets. </p></blockquote><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">1 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0</code></pre><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>0</p><p>1</p><p>2</p><p>2</p></blockquote><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 105;int n, m;string s[N];int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};void dfs(int x, int y){    s[x][y] = &#39;*&#39;;    for(int i = 0; i &lt; 8; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; s[xx][yy] == &#39;@&#39;)        {            s[xx][yy] = &#39;*&#39;;            dfs(xx, yy);        }    }}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        if(n == 0 &amp;&amp; m == 0)            break;        int ans = 0;        for(int i = 0; i &lt; n; ++i)            cin &gt;&gt; s[i];        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; m; ++j)                if(s[i][j] == &#39;@&#39;)                {                    dfs(i, j);                    ans++;                }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2449 Remmarguts&#39; Date（第k短路）</title>
      <link href="2019/03/09/POJ-2449-Remmarguts-Date/"/>
      <url>2019/03/09/POJ-2449-Remmarguts-Date/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>“Erenow, the princess sent Remmarguts a letter, informing him that she would come to the hall and hold commercial talks with UDF if and only if the prince go and meet her via the K-th shortest path. (in fact, Uyuw does not want to come at all)” </p></blockquote><a id="more"></a><blockquote><p>Being interested in the trade development and such a lovely girl, Prince Remmarguts really became enamored. He needs you - the prime minister’s help! </p><p>DETAILS: UDF’s capital consists of N stations. The hall is numbered S, while the station numbered T denotes prince’ current place. M muddy directed sideways connect some of the stations. Remmarguts’ path to welcome the princess might include the same station twice or more than twice, even it is the station with number S or T. Different paths with same length will be considered disparate. </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The first line contains two integer numbers N and M (1 &lt;= N &lt;= 1000, 0 &lt;= M &lt;= 100000). Stations are numbered from 1 to N. Each of the following M lines contains three integer numbers A, B and T (1 &lt;= A, B &lt;= N, 1 &lt;= T &lt;= 100). It shows that there is a directed sideway from A-th station to B-th station with time T. </p><p>The last line consists of three integer numbers S, T and K (1 &lt;= S, T &lt;= N, 1 &lt;= K &lt;= 1000).</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>A single line consisting of a single integer number: the length (time required) to welcome Princess Uyuw using the K-th shortest path. If K-th shortest path does not exist, you should output “-1” (without quotes) instead. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2 2</p><p>1 2 5</p><p>2 1 4</p><p>1 2 2</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>14</p></blockquote><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><blockquote><p>给出一个有向图，求s到t的第k短路</p></blockquote><h3 id="关于-A-启发式搜索"><a href="#关于-A-启发式搜索" class="headerlink" title="关于 A* 启发式搜索"></a>关于 A* 启发式搜索</h3><blockquote><p>给搜索一个顺序使得搜索更加合理减少无谓的搜索. 如何来确定搜索的顺序？..也就是用一个值来表示 这个值为f[n]…</p><p>每次搜索取f[x]最小的拓展 那么这个f[n]=h[n]+g[n]</p><p> 其中f(n) 是节点n的估价函数，g(n)是在状态空间中从初始节点到n节点的实际代价，h(n)是从n到目标节点最佳路径的估计代价。</p><p>在这里主要是h(n)体现了搜索的启发信息，因为g(n)是已知的。如果说详细 点，g(n)代表了搜索的广度的优先趋势。但是当h(n) &gt;&gt; g(n)时，可以省略g(n),而提高效率。</p><p>  A<em>算法的估价函数可表示为：      f’(n) = g’(n) + h’(n)    这里，f’(n)是估价函数，g’(n)是起点到终点的最短路径值，h’(n)是n到目标的最短路经的启发值。由 于这个f’(n)其实是无法预先知道的，所以我们用前面的估价函数f(n)做近似。g(n)代替g’(n)，但 g(n)&gt;=g’(n) 才可（大多数情况下都是满足的，可以不用考虑），h(n)代替h’(n)，但h(n)&lt;=h’(n)才可（这一点特别的重 要）。可以证明应用这样的估价函数是可以找到最短路径的，也就是可采纳的。我们说应用这种估价函数的 最好优先算法就是A</em>算法。 </p></blockquote><p><strong>原文出处</strong> <a href="http://blog.sina.com.cn/s/blog_691ce2b701017fe3.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_691ce2b701017fe3.html</a></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;struct node///存放“边”{    int from, to, w, pre;} a[N &lt;&lt; 1];struct data{   ///g 表示起点到当前点的（第x短路）距离，h表终点到当前点的（第x短路）距离    int g, h;    int num;///num表示当前点（的排号 or 标号）    bool operator &lt; (data a) const///优先队列的排序（其实也不能这么讲） 使g+h小的在队首    {        return a.h + a.g &lt; h + g;    }};///head[]为正向边,tail[]为逆向边（某种等效思想:有向图逆用）///tot[i]=x;表示：此刻已经是从起点第x次到达 点i         ///表示：此刻已经检测到从起点到点i的第x短路int head[N], tail[N], cnt, dis[N], times[N], n, m, tot[N];int start, over, k;bool vis[N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = inf, times[i] = 0, vis[i] = 0, tot[i] = 0, head[i] = -1, tail[i] = -1;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    a[cnt].pre = tail[to];    tail[to] = cnt;    cnt++;}void dijkstra(int over)///求终点到各点的距离{    dis[over] = 0;    int now_pos = over;    while(now_pos != -1)    {   /// 人倒退着走 != 人在返回的路上直行        for(int i = tail[now_pos]; ~i; i = a[i].pre)        {            if(vis[ a[i].to ])                continue;            if(dis[ a[i].to ] == inf || dis[ a[i].to ] &gt; dis[now_pos] + a[i].w)                dis[ a[i].to ] = dis[now_pos] + a[i].w;        }        vis[now_pos] = 1;        int mmin = -1;        now_pos = -1;        for(int i = 0; i &lt; n; ++i)///遍历 0 ~ n - 1 这些点        {            if(!vis[i] &amp;&amp; dis[i] != inf &amp;&amp; (dis[i] &lt; mmin || mmin == -1 ))            {                mmin = dis[i];                now_pos = i;            }        }    }    return ;}///启发性搜索决定了先后搜索出来的是：最短、次短、第三短...第k短int Astar(int k){    data cur, nex;    priority_queue&lt;data&gt; q;    cur.num = start;    cur.g = 0;    cur.h = dis[start];    q.push(cur);    while(q.size())    {        cur = q.top();        q.pop();        tot[ cur.num ]++;///如果当前想拓展的点tot&gt;k就没必要拓展了///因为这个点已经是求到k+1短路了 从这个点继续往下搜肯定得到的是&gt;=k+1短路的路径        if (tot[ cur.num ] &gt; k)            continue;        if (tot[over] == k)///找到第K短路 返回            return cur.g;        for(int i = head[cur.num]; ~i; i = a[i].pre)///链式前向星遍历        {            nex.num = a[i].to;            nex.g = cur.g + a[i].w;            nex.h = dis[ a[i].to ];            q.push(nex);        }    }    return -1;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        init();        int b, c, d;        int tem = m;        while(tem--)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }        scanf(&quot;%d%d%d&quot;, &amp;start, &amp;over, &amp;k);        if(start == over)            k++;        dijkstra(over);        cout &lt;&lt; Astar(k) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 简单搜索のA* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1874 畅通工程续</title>
      <link href="2019/03/09/HDU-1874-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/"/>
      <url>2019/03/09/HDU-1874-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><blockquote><p>主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 </p><p>主要思想是每次找到离”已成图“最近的一个顶点，然后将该顶点连入图，然后更新“已成图”到其他顶点的最短路径。贪心算法。 </p><p>该算法要求图中不存在负权边！！！(无负权边自然无负权环)</p></blockquote><a id="more"></a><p><strong>更多关于Dijkstra算法过程</strong> <a href="https://blog.csdn.net/wenqiang1208/article/details/76473984" target="_blank" rel="noopener">https://blog.csdn.net/wenqiang1208/article/details/76473984</a></p><h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><blockquote><p>原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(VE)。但算法可以进行若干种优化，提高了效率。 </p><p>可有负权边，可判负权环。（突出特点！）</p></blockquote><p><strong>更多关于Bellman-Ford算法过程</strong> <a href="https://blog.csdn.net/a8082649/article/details/81812000" target="_blank" rel="noopener">https://blog.csdn.net/a8082649/article/details/81812000</a></p><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><blockquote><p><strong>Floyd-Warshall算法</strong>（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题 （ye可判负权环！！！）</p><p>注意点是从 0 ~ n-1 还是 1 ~ n</p></blockquote><p><strong>更多关于Floyd算法</strong> <a href="https://www.cnblogs.com/GumpYan/p/5540549.html" target="_blank" rel="noopener">https://www.cnblogs.com/GumpYan/p/5540549.html</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>某省自从实行了很多年的畅通工程计划后，终于修建了很多路。不过路多了也不好，每次要从一个城镇到另一个城镇时，都有许多种道路方案可以选择，而某些方案要比另一些方案行走的距离要短很多。这让行人很困扰。  现在，已知起点和终点，请你计算出要从起点到终点，最短需要行走多少距离。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>本题目包含多组数据，请处理到文件结束。 每组数据第一行包含两个正整数N和M(0&lt;N&lt;200,0&lt;M&lt;1000)，分别代表现有城镇的数目和已修建的道路的数目。城镇分别以0～N-1编号。 接下来是M行道路信息。每一行有三个整数A,B,X(0&lt;=A,B&lt;N,A!=B,0&lt;X&lt;10000),表示城镇A和城镇B之间有一条长度为X的双向道路。 再接下一行有两个整数S,T(0&lt;=S,T&lt;N)，分别代表起点和终点。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对于每组数据，请在一行里输出最短需要行走的距离。如果不存在从S到T的路线，就输出-1. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">3 30 1 10 2 31 2 10 23 10 1 11 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2</p><p>-1</p></blockquote><h3 id="Code-of-Dijkstra"><a href="#Code-of-Dijkstra" class="headerlink" title="Code of Dijkstra"></a>Code of Dijkstra</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;struct node///存放“边”{    int from, to, w, pre;} a[N];///n为点的个数，dis[i]表示从起点到点i目前最短路径int head[N], cnt, dis[N], times[N], n, m;bool vis[N];void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = inf, times[i] = 0, vis[i] = 0, head[i] = -1;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    a[cnt].pre = head[to];    head[to] = cnt;    cnt++;}void dijkstra(int start){    dis[start] = 0;    int now_pos = start;    while(now_pos != -1)    {        for(int i = head[now_pos]; ~i; i = a[i].pre)        {            if(vis[ a[i].to ])                continue;///最短路核心体现:起点到某点(a[i].to)距离 &gt; 起点经由此点(now_pos)到该点(a[i].to)距离就更新            if(dis[ a[i].to ] == inf || dis[ a[i].to ] &gt; dis[now_pos] + a[i].w)                dis[ a[i].to ] = dis[now_pos] + a[i].w;        }        vis[now_pos] = 1;        int mmin = -1;        now_pos = -1;        for(int i = 0; i &lt; n; ++i)///遍历 0 ~ n - 1 这些点        {            if(!vis[i] &amp;&amp; dis[i] != inf &amp;&amp; (dis[i] &lt; mmin || mmin == -1 ))            {                mmin = dis[i];                now_pos = i;            }        }    }    return ;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        init();        int b, c, d;        int tem = m;        while(tem--)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }        int start, over;        scanf(&quot;%d%d&quot;, &amp;start, &amp;over);        dijkstra(start);        if(dis[over] != inf)            cout &lt;&lt; dis[over] &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-of-Bellman-Ford"><a href="#Code-of-Bellman-Ford" class="headerlink" title="Code of Bellman-Ford"></a>Code of Bellman-Ford</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;struct node///存“边”{    int from, to, w;} a[N];int n, m, cnt, dis[N];void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    cnt++;}bool Bellman_Ford(int start){    dis[start] = 0;    int tot = n;    while(tot--)    {        bool flag = 0;///优化        for(int i = 0; i &lt; cnt; ++i)            if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            {                flag = 1;                dis[ a[i].to ] = dis[ a[i].from ] + a[i].w;            }            if(flag == 0)                break;    }    for(int i = 0; i &lt; cnt; ++i)///判负权环（负权回路）        if(dis[ a[i].to ] &gt; dis[ a[i].from ] + a[i].w)            return 0;    return 1;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m))    {        memset(dis, inf, sizeof(dis));        cnt = 0;        int b, c, d;        int tem = m;        while(tem--)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }        int start, over;        scanf(&quot;%d%d&quot;, &amp;start, &amp;over);        if(Bellman_Ford(start))        {            if(dis[over] != inf)                cout &lt;&lt; dis[over] &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre><h3 id="Code-of-Floyd"><a href="#Code-of-Floyd" class="headerlink" title="Code of Floyd"></a>Code of Floyd</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;int n, m;int e[210][210];void floyd(){    ///注意点是从 0 ~ n-1 还是 1 ~ n    for(int k = 0; k &lt; n; ++k)        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; n; ++j)                if(e[i][j] &gt; e[i][k] + e[k][j])                    e[i][j] = e[i][k] + e[k][j];}int main(){    while(cin &gt;&gt; n &gt;&gt; m)    {        ///注意点是从 0 ~ n-1 还是 1 ~ n        for(int i = 0; i &lt; n; ++i)            for(int j = 0; j &lt; n; ++j)                e[i][j] = (i == j ? 0 : inf);        int from, to, w;        for(int i = 0; i &lt; m; ++i)        {            cin &gt;&gt; from &gt;&gt; to &gt;&gt; w;            if(e[from][to] &gt; w)                e[from][to] = e[to][from] = w;        }        int start, over;        cin &gt;&gt; start &gt;&gt; over;        floyd();        if(e[start][over] == inf)            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; e[start][over] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 最短路のDijkstra </tag>
            
            <tag> 最短路のBellman-Ford </tag>
            
            <tag> 最短路のFloyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马航MH370 五年等待 未见归期</title>
      <link href="2019/03/08/%E9%A9%AC%E8%88%AAmh370-%E4%BA%94%E5%B9%B4%E7%AD%89%E5%BE%85-%E6%9C%AA%E8%A7%81%E5%BD%92%E6%9C%9F/"/>
      <url>2019/03/08/%E9%A9%AC%E8%88%AAmh370-%E4%BA%94%E5%B9%B4%E7%AD%89%E5%BE%85-%E6%9C%AA%E8%A7%81%E5%BD%92%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>马航MH370失联</strong></p><blockquote><p>2014年3月8日凌晨，马航MH370号班机从吉隆坡国际机场起飞，机上共载有239人，其中有154名中国人（中国大陆153人，中国台湾1人）。</p><p>该班机原定计划于北京时间早晨6：30抵达北京首都国际机场，但起飞后不足一小时便在马来西亚与越南海域的交界处，土珠岛以南约140海里及哥打巴鲁东北东约90海里处与马国梳邦空管中心（空中交通管制中心）失去联系。</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28315174&auto=1&height=66"></iframe><h3 id="822页的调查报告-却无法确定失联的真正原因"><a href="#822页的调查报告-却无法确定失联的真正原因" class="headerlink" title="822页的调查报告 却无法确定失联的真正原因"></a><strong>822页的调查报告 却无法确定失联的真正原因</strong></h3><blockquote><p>2018年5月29日，马航MH370搜寻工作结束。7月30日上午，马来西亚政府面向马航MH370失联者家属公布了最终报告，报告共计有822页。<strong>报告显示，调查组无法确定马航MH370航班失联的真正原因。</strong> </p><p>马来西亚交通部长陆兆福此前曾表示：“调查人员记录下的每一个字都会被收录在这份报告中。我们会确保报告的透明度，它将被完整地提交，不经任何编辑，没有添加或删除。”同时，报告7月31日提交给了马来西亚两院审议。 </p><p>马航MH370航班与机上239名机组人员和乘客，依旧在印度洋的深处，无影无踪，留给家属们无尽的痛苦，留给全世界无尽的迷思。</p><p>还未抵达的航班，我们仍在等你回来！</p></blockquote><p><strong>原文链接</strong> <a href="http://news.iqilu.com/guoji/20190308/4211477.shtml" target="_blank" rel="noopener">http://news.iqilu.com/guoji/20190308/4211477.shtml</a></p><p><img src="https://i.loli.net/2019/03/08/5c823555aa692.jpg" alt="马航"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1875 畅通工程再续</title>
      <link href="2019/03/08/HDU-1875-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD/"/>
      <url>2019/03/08/HDU-1875-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><blockquote><p>最小生成树是一副连通加权无向图中一棵权值最小的生成树 </p><p>主要可以使用Prim和Kruskal算法(借助并查集)实现</p><p>稠密图、点少边多：Prim</p><p>稀疏图、边多点少：Kruskal </p></blockquote><a id="more"></a><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><blockquote><ol><li>对所有权值进行从小到大排序</li><li>然后每次选取最小的权值，如果和已有点集构成环则跳过，否则加到该点集中。</li></ol></blockquote><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><blockquote><ol><li>将一个图分为两部分，一部分归为点集U，一部分归为点集V，U的初始集合为{V1}，V的初始集合为{ALL-V1}。</li><li>针对U开始找U中各节点的所有关联的边的权值最小的那个，然后将关联的节点Vi加入到U中，并且从V中删除（注意不能形成环）。</li><li>递归执行步骤2，直到V中的集合为空。</li></ol></blockquote><p><strong>更多</strong> <a href="http://www.cnblogs.com/JoshuaMK/p/prim_kruskal.html" target="_blank" rel="noopener">http://www.cnblogs.com/JoshuaMK/p/prim_kruskal.html</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为  100元/米。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>输入包括多组数据。输入首先包括一个整数T(T &lt;= 200)，代表有T组数据。 每组数据首先是一个整数C(C &lt;=  100),代表小岛的个数，接下来是C组坐标，代表每个小岛的坐标，这些坐标都是 0 &lt;= x, y &lt;= 1000的整数。</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>每组输入数据输出一行，代表建桥的最小花费，结果保留一位小数。如果无法实现工程以达到全部畅通，输出”oh!”.</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">2210 1020 2031 12 21000 1000</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1414.2</p><p>oh!</p></blockquote><h3 id="Code-of-Kruskal"><a href="#Code-of-Kruskal" class="headerlink" title="Code of Kruskal"></a>Code of Kruskal</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 125;int n;double ans;int pre[N];double x[N], y[N];struct node{    int there, here;    double w;} a[10005];bool cmp(node a, node b){    return a.w &lt; b.w;}void init(){    ans = 0;    for(int i = 0; i &lt;= n; ++i)///初始化顶级是自身        pre[i] = i;}//int found(int x)//{//    if(x == pre[x])///顶级是自身//        return x;//    return found(pre[x]);///一级一级地向上找至找到顶级//}int found(int x){    if(x != pre[x])///顶级是自身        pre[x] = found(pre[x]);    return pre[x];///压缩路径}bool judge(int a, int b){    int x = found(a);    int y = found(b);    if(x != y)    {        pre[x] = y;        return 1;    }    return 0;}int main(){    int t;//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        init();        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%lf%lf&quot;, &amp;x[i], &amp;y[i]);        int tot = 0;        double dis;        for(int i = 0; i &lt; n - 1; ++i)            for(int j = i + 1; j &lt; n; ++j)            {                dis = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));                if(dis &gt;= 10 &amp;&amp; dis &lt;= 1000)                {                    a[tot].there = i;                    a[tot].here = j;                    a[tot].w = dis;                    tot++;                }            }        sort(a, a + tot, cmp);        int flag = 0;        for(int i = 0; i &lt; tot; ++i)            if(judge(a[i].there, a[i].here))            {                ans += a[i].w;                flag++;            }        if(flag == n - 1)            printf(&quot;%.1f\n&quot;, ans * 100);        else//            cout &lt;&lt; &quot;oh!&quot; &lt;&lt; &#39;\n&#39;;            printf(&quot;oh!\n&quot;);    }    return 0;}</code></pre><h3 id="Code-of-Prim"><a href="#Code-of-Prim" class="headerlink" title="Code of Prim"></a>Code of Prim</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int inf = 0x3f3f3f3f;int n;bool vis[125];int x[125], y[125];double mp[125][125], low[125], ans;///low[i]表示已成图所有点到点i的最小权值void prim(){    ans = 0;    double mmin;    memset(vis, 0, sizeof(vis));    int pos = 1;///从点1开始    vis[1] = 1;    for(int i = 1; i &lt;= n; ++i)        low[i] = mp[pos][i];    int cnt = n;    while(--cnt)///只需连接 n - 1条，此循环便是 n - 1 次    {        mmin = inf;///此次连接中的最小权值        for(int j = 1; j &lt;= n; ++j)        {            if(vis[j] == 0 &amp;&amp; low[j] &lt; mmin)            {                mmin = low[j];                pos = j;            }        }        if(mmin == inf)///某次循环所查询点皆为不可连接点        {            cout &lt;&lt; &quot;oh!&quot; &lt;&lt; &#39;\n&#39;;            return ;        }        ///处理下一个点(pos)之前更新 low[]        vis[pos] = 1;        ans += mmin;        for(int j = 1; j &lt;= n; ++j)            if(vis[j] == 0 &amp;&amp; low[j] &gt; mp[pos][j])                low[j] = mp[pos][j];    }    printf(&quot;%.1f\n&quot;, ans * 100);}int main(){    int t;//    freopen(&quot;00in.tex&quot;, &quot;r&quot;, stdin);    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        scanf(&quot;%d&quot;, &amp;n);        for(int i = 1; i &lt;= n; ++i)            scanf(&quot;%d%d&quot;, &amp;x[i], &amp;y[i]);        memset(mp, 0, sizeof(mp));        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)            {                mp[i][j] = sqrt(1.0 * ((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])));//                cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; mp[i][j] &lt;&lt; &#39;\n&#39;;                if(mp[i][j] &lt; 10 || mp[i][j] &gt; 1000)                    mp[i][j] = inf;            }        prim();    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
            <tag> 最小生成树のKruskal </tag>
            
            <tag> 最小生成树のPrim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1232 畅通工程</title>
      <link href="2019/03/06/HDU-1232-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/"/>
      <url>2019/03/06/HDU-1232-%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="关于并查集"><a href="#关于并查集" class="headerlink" title="关于并查集"></a>关于并查集</h3><blockquote><p>并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。</p><p>特点是看似并不复杂，但数据量极大 。</p><p>是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题 。</p></blockquote><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000  )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。   注意:两个城市之间可以有多条道路相通,也就是说 </p><p>3 3 </p><p>1 2 </p><p>1 2 </p><p>2  1 这种输入也是合法的 当N为0时，输入结束，该用例不被处理。  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对每个测试用例，在1行里输出最少还需要建设的道路数目。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c">4 21 34 33 31 21 32 35 21 23 5999 00</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="lang-java">102998</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 1005;int pre[N];int n, m, ans;void init(){    ans = n - 1;    for(int i = 0; i &lt;= n; ++i)///初始化顶级是自身        pre[i] = i;}int found(int x){    if(x != pre[x])///顶级不是自身        pre[x] = found(pre[x]);///找的过程中顺带优化（压缩路径）    return pre[x];}void unite(int a, int b)///联合{    int x = found(a);    int y = found(b);    if(x != y)    {        pre[x] = y;///此题pre[y] = x亦可        ans--;    }    return ;}int main(){    int there, here;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        scanf(&quot;%d&quot;, &amp;m);        init();        for(int i = 0; i &lt; m; ++i)        {            scanf(&quot;%d%d&quot;, &amp;there, &amp;here);            unite(there, here);        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="非递归版found函数"><a href="#非递归版found函数" class="headerlink" title="非递归版found函数"></a>非递归版found函数</h3><pre><code class="lang-c++">int found(int x){    ///寻找根节点（最终顶级、最终祖先）    int root = x;    while(root != pre[root])///根节点特点：顶级是自身        root = pre[root];    ///路径压缩    int now = x;    while(now != root)///将路径上所有点的顶级改为根节点(root)    {        int nxt = pre[now];        pre[now] = root;        now = nxt;    }    return root;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合数与第二类斯特林数</title>
      <link href="2019/03/05/%E7%BB%84%E5%90%88%E6%95%B0/"/>
      <url>2019/03/05/%E7%BB%84%E5%90%88%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="求解组合数-C（n，m）"><a href="#求解组合数-C（n，m）" class="headerlink" title="求解组合数 C（n，m）"></a>求解组合数 C（n，m）</h3><blockquote><p>暂时有三种方法：</p><p>1.存在数组里递归求解</p><p>2.较为生猛地求解（连乘连除）</p><p>3.改良版（乘一次除一次）</p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1316351312&auto=1&height=66"></iframe><h3 id="Code-存于数组"><a href="#Code-存于数组" class="headerlink" title="Code(存于数组)"></a>Code(存于数组)</h3><pre><code class="lang-c++">long long c[105][105];void combine_init(){    memset(c, 0, sizeof(c));    c[0][0] = 1;    for(int i = 1; i &lt;= 105; ++i)    {        c[i][0] = c[i][i] = 1;        c[i][1] = i;        for(int j = 1; j &lt; i; ++j)            if(c[i][j] == 0)                c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]);/// % mod    }}</code></pre><h3 id="Code（连乘连除）"><a href="#Code（连乘连除）" class="headerlink" title="Code（连乘连除）"></a>Code（连乘连除）</h3><pre><code class="lang-c++">long long violent_combine(long long n,long long m){    if(m &lt; n - m)        m = n - m;///取个较大值    long long ans = 1;    for(long long i = m + 1; i &lt;= n; ++i)/// fac(n) / fac(m)        ans *= i;    for(long long i = 1; i &lt;= n - m; ++i)/// fac(n - m)        ans /= i;    return ans;}</code></pre><h3 id="Code-乘除共进"><a href="#Code-乘除共进" class="headerlink" title="Code(乘除共进)"></a>Code(乘除共进)</h3><pre><code class="lang-c++">long long combine(long long a, long long b){    if(b &gt; a - b)        b = a - b;///取个较小值    long long ans = 1;    for(int i = 1; i &lt;= b; ++i)    {        ans *= (a + 1 - i);/// fac(a) / fac(a - b)        ans /= i;          /// fac(b)    }    return ans;}</code></pre><h3 id="update-第二类斯特林数"><a href="#update-第二类斯特林数" class="headerlink" title="update 第二类斯特林数"></a>update 第二类斯特林数</h3><blockquote><p>c[n][m]把n个元素分到m个非空且不可区分的集合中去 </p></blockquote><pre><code class="lang-c++">memset(c, 0, sizeof(c));    c[1][1] = 1;    for(int i = 2; i&lt;= 105; ++i)        for(int j = 1; j &lt;= i; ++j)            if(c[i][j] == 0)                c[i][j] = (c[i - 1][j] * j + c[i - 1][j - 1]) % mod;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 组合数学の组合数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1089 拓扑排序</title>
      <link href="2019/03/05/SDNUOJ-1089-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>2019/03/05/SDNUOJ-1089-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给定一个有向图，若图无环，则将其进行拓扑排序并输出，否则输出IMPOSABLE。 </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>第一行为两个整数n(1&lt;=n&lt;=1000)、m(1&lt;=m&lt;=100000)； 之后m行，每行两个整数a、b(0 &lt; a, b &lt;= n)表示一条从a到b的有向边。 </p></blockquote><a id="more"></a><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>若存在环，输出IMPOSABLE，否则输出一行用一个空格隔开的拓扑排序的结果，若存在多个结果，输出字典序最小的。 </p></blockquote><h3 id="Sample-Input-自写"><a href="#Sample-Input-自写" class="headerlink" title="Sample Input(自写)"></a>Sample Input(自写)</h3><pre><code class="lang-c++">5 32 52 41 34 41 22 33 44 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1 2 3 4 5</p><p>IMPOSABLE</p></blockquote><h3 id="做题过程"><a href="#做题过程" class="headerlink" title="做题过程"></a>做题过程</h3><p><img src="https://i.loli.net/2019/03/05/5c7e5c6758430.jpg" alt="过程"></p><blockquote><p>原来的判环与输出结果都没问题，但要输出字典序最小的！我想了个办法：</p><p>邻接表存的时候按顺序放:</p></blockquote><pre><code class="lang-c++">            cin &gt;&gt; a &gt;&gt; b;            v[a].insert(lower_bound(v[a].begin(), v[a].end(), b), b);</code></pre><blockquote><p>但TLE了</p><p>用priority_queue一点点存：</p><p>RE了：</p><p>把模板搬过来没改数据范围，改完了交上</p><p>WA了：</p><p>对拍发现：有环时输出IMPOSABLE(可实施的、可强制的)而不是IMPOSSIBLE(不可能的)</p><p>最后AC了。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int in[1005];vector&lt;int&gt; ans;vector&lt;int&gt; v[100005];bool bfs(priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q){    int sum = 0;    while(q.size())    {        int tem = q.top();        ans.push_back(tem);        sum++;        q.pop();        for(int i = 0; i &lt; v[tem].size(); ++i)        {            in[ v[tem][i] ]--;            if(!in[ v[tem][i] ])                q.push(v[tem][i]);        }    }    return sum == n;}int main(){//    freopen(&quot;00in.txt&quot;, &quot;r&quot;, stdin);    while(cin &gt;&gt; n &gt;&gt; m)    {        priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;        memset(in, 0, sizeof(in));        ans.clear();        for(int i = 0; i &lt;= n; ++i)            v[i].clear();        int a, b;        for(int i = 1; i &lt;= m; ++i)        {            cin &gt;&gt; a &gt;&gt; b;//            v[a].insert(lower_bound(v[a].begin(), v[a].end(), b), b);            v[a].push_back(b);            in[b]++;        }        for(int i = 1; i &lt;= n; ++i)///1 ~ n            if(!in[i])                q.push(i);        if(!bfs(q))            cout &lt;&lt; &quot;IMPOSABLE&quot; &lt;&lt; &#39;\n&#39;;        else        {            int sz = ans.size();            for(int i = 0; i &lt; sz; ++i)                printf(&quot;%d%c&quot;, ans[i], i == sz - 1 ? &#39;\n&#39; : &#39; &#39;);        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 图论の拓扑排序(判环) </tag>
            
            <tag> 数据结构のpriority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1223 Tom&#39;s problem A</title>
      <link href="2019/03/04/SDNUOJ-1223-Tom-s-problem-A/"/>
      <url>2019/03/04/SDNUOJ-1223-Tom-s-problem-A/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In the future ,One day, tom feel so happy ,because he have a date with a girl,but they don’t live in the same city , so tom want you help him find the fastest way to the girl’s city,You should note that with the development of technology, transport can go beyond the speed of light, so the time you spend would be less than zero, but if you return to the past you can not have the date with the girl,there n(1&lt;n&lt;=100) city in this country and three are m(1&lt;m&lt;1000) roads in this country;</p></blockquote><a id="more"></a><blockquote><p>Tom in the first city,the girl in the city n;</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The fist line is m,n;</p><p>Next m lines is a,b,c (a,b is the name of city , c is the time you cost from city a to city b)</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>The shortest time to reach the girl’s city</p><p>(if tom return to the past ,out IMPOSSIBLE!)</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 21 2 103 41 2 102 3 103 4 -5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>10IMPOSSIBLE!</code></pre><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;struct node///存放“边”{    int from, to, w, pre;} a[N];///n为点的个数，dis[i]表示从起点到点i目前最短路径///tot为队列内元素个数，sum为队列内元素的dis[]之和int head[N], cnt, dis[N], times[N], tot, sum, n, m;bool vis[N];///vis[i]：0表示i不在队列里，1表示i在队列里void init(){    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = inf, times[i] = 0, vis[i] = 0, head[i] = -1;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;    a[cnt].from = to;    a[cnt].to = from;    a[cnt].w = w;    a[cnt].pre = head[to];    head[to] = cnt;    cnt++;}bool spfa(int start){    deque&lt;int&gt; q;    dis[start] = 0;///到自己的距离为0    vis[start] = 1;    q.push_front(start);    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];//        cout &lt;&lt; &quot;当前检测点 &quot; &lt;&lt; first &lt;&lt; &#39;\n&#39;;        for(int i = head[first]; ~ i; i = a[i].pre)        {            int t = a[i].to;//            cout &lt;&lt; &quot;当前检测终点 &quot; &lt;&lt; t &lt;&lt; &#39;\n&#39;;//            cout &lt;&lt; &quot;从起点到此终点最短路径 &quot; &lt;&lt; dis[t] &lt;&lt; &#39;\n&#39;;//            cout &lt;&lt; &quot;经由当前检测点到此终点最短路径 &quot; &lt;&lt; dis[first] + a[i].w &lt;&lt; &#39;\n&#39;;            ///若 “起点到终点t的距离” 大于 “起点经由first点到终点t的距离”            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;         ///极值优化             ///平均值优化                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                    if(++times[t] &gt;= n)                        return 0;                }            }        }    }    return 1;}int main(){    while(~scanf(&quot;%d%d&quot;, &amp;m, &amp;n))    {        init();        int b, c, d;        int tem = m;        while(tem--)        {            scanf(&quot;%d%d%d&quot;, &amp;b, &amp;c, &amp;d);            add(b, c, d);        }//        for(int i = 0; i &lt; cnt; ++i)//        cout &lt;&lt; a[i].from &lt;&lt; &#39; &#39; &lt;&lt; a[i].to &lt;&lt; &#39; &#39; &lt;&lt; a[i].w &lt;&lt; &#39; &#39; &lt;&lt; a[i].pre &lt;&lt; &#39;\n&#39;;        if(spfa(1))            cout &lt;&lt; dis[n] &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;IMPOSSIBLE!&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 最短路のspfa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>素数筛</title>
      <link href="2019/03/04/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>2019/03/04/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><blockquote><p>用筛法求素数的基本思想是:把从1开始的、某一范围内的正整数从小到大顺序排列， 1不是素数，首先把它筛掉。剩下的数中选择最小的数是素数，然后去掉它的倍数。依次类推，直到筛子为空时结束。 </p></blockquote><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=31273716&auto=1&height=66"></iframe><h3 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h3><pre><code class="lang-c++">void get_prime(long long n){    tot = 0;    memset(is, 1, sizeof(is));///bool类型数组全部初始化为1（默认全为质数）    is[0] = is[1] = 0;///0、1不是质数，单列    for(int i = 2; i &lt;= n; ++i)///遍历数组    {        if(is[i])///若此数未被标为0，则其未被前面质数筛掉，属于质数，用它去筛后面的数        {            pri[++tot] = i;///（1）将此数存于质数数组            pri[0]里没存数字            for(int j = i + i; j &lt;= n; j += i)///（2）从其2倍开始筛            {                is[j] = 0;            }        }    }}</code></pre><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p><strong>每个合数仅被它的最小质因子筛过，且为一次</strong></p><pre><code class="lang-c++">void prime(int n){    tot = 0;    memset(vis, 1, sizeof(vis));    vis[0] = vis[1] = false;    for (int i = 2; i &lt;= n; i++)    {        if (vis[i])            p[++tot] = i;        for (int j = 1; j &lt;= tot &amp;&amp; p[j] * i &lt;= n; j++)        {            vis[p[j]*i] = false;                          ///合数被他的最小质因子筛掉            if (i % p[j] == 0)                            ///&quot;只&quot;                break;        }    }}</code></pre><p><strong>关于</strong><code>if(i % p[j] == 0)</code></p><blockquote><p>其功能：保证每个数只被它最小的因子筛掉</p><p>其机理:</p><p>证明（反证）：</p><p>假设 i = k * a（k 为常数、a为较小、较靠前的质数）</p><p>如果没有上面那句代码 ，ka % a == 0 了还去找下一个素数（a + x）去筛</p><p>首先筛掉  <em>(a + x) <em> k </em> a</em>  这个数字</p><p>我们发现那个数字的所有因子中，a 是比 （a + x）更小的</p><p>那就违背线性筛概念了，反证得这句代码很重要</p></blockquote><p><code>//I&#39;m not sure if we need this, but too scared to delete.</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 数论の素数筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spfa算法</title>
      <link href="2019/03/04/spfa%E7%AE%97%E6%B3%95/"/>
      <url>2019/03/04/spfa%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="spfa算法（优化）"><a href="#spfa算法（优化）" class="headerlink" title="spfa算法（优化）"></a>spfa算法（优化）</h3><blockquote><p>spfa算法通常用于求含负权边的单源最短路径，以及判负权环。 </p><p>允许输入有重边（Dijkstra不可）</p></blockquote><a id="more"></a><h3 id="Code-of-improved-spfa"><a href="#Code-of-improved-spfa" class="headerlink" title="Code of improved spfa"></a>Code of improved spfa</h3><p><strong>据说有时单用slf好，lll对于某些题会t</strong></p><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;const int inf = 0x3f3f3f3f;struct node///存放“边”{    int from, to, w, pre;} a[N];///n为点的个数，dis[i]表示从起点到点i目前最短路径///tot为队列内元素个数，sum为队列内元素的dis[]之和int head[N], cnt, dis[N], times[N], tot, sum, n;bool vis[N];///vis[i]：0表示i不在队列里，1表示i在队列里void init()///受n影响，应安排在n被赋值之后{    cnt = 0;    for(int i = 0; i &lt;= n; ++i)        dis[i] = inf, times[i] = 0, vis[i] = 0, head[i] = -1;    return ;}void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cnt++;}bool spfa(int start){    deque&lt;int&gt; q;    dis[start] = 0;///到自己的距离为0    vis[start] = 1;    q.push_front(start);    tot = 1, sum = 0;    while(q.size())    {        int first = q.front();        q.pop_front();        vis[first] = 0;        tot--;        sum -= dis[first];        cout &lt;&lt; &quot;当前检测点 &quot; &lt;&lt; first &lt;&lt; &#39;\n&#39;;        for(int i = head[first]; ~ i; i = a[i].pre)        {            int t = a[i].to;            cout &lt;&lt; &quot;当前检测终点 &quot; &lt;&lt; t &lt;&lt; &#39;\n&#39;;            cout &lt;&lt; &quot;从起点到此终点最短路径 &quot; &lt;&lt; dis[t] &lt;&lt; &#39;\n&#39;;            cout &lt;&lt; &quot;经由当前检测点到此终点最短路径 &quot; &lt;&lt; dis[first] + a[i].w &lt;&lt; &#39;\n&#39;;            ///若 “起点到终点t的距离” 大于 “起点经由first点到终点t的距离”            if(dis[t] &gt; dis[first] + a[i].w)            {                dis[t] = dis[first] + a[i].w;                if(!vis[t])                {                    vis[t] = 1;         ///极值优化             ///平均值优化                    if(q.empty() || dis[t] &gt; dis[q.front()] || dis[t] * tot &gt;= sum)                        q.push_back(t);                    else                        q.push_front(t);                    sum += dis[t];                    tot++;                    if(++times[t] &gt; n)                        return 0;                }            }        }    }    return 1;}int main(){    n = 5;///5个点    init();    add(1, 2, 20);    add(2, 3, 30);    add(2, 4, 20);    add(4, 5, 20);    add(3, 5, 100);    if(spfa(1))        for(int i = 1; i &lt;= 5; ++i)            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; dis[i] &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="优先队列slf优化"><a href="#优先队列slf优化" class="headerlink" title="优先队列slf优化"></a>优先队列slf优化</h3><pre><code class="lang-c++">struct cmp{    bool operator()(int a, int b)    {        return dis[a] &gt; dis[b];    }};priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;///优先队列的极值优化</code></pre><h3 id="关于spfa死了"><a href="#关于spfa死了" class="headerlink" title="关于spfa死了"></a>关于spfa死了</h3><blockquote><p>spfa貌似不被人接受：SPFA 的受到怀疑和最终消亡，是 OI 界水平普遍提高、命题规范完善和出题人的使命感和责任心增强的最好见证。 </p></blockquote><p><strong>如何看待 SPFA 算法已死这种说法？</strong> <a href="https://www.zhihu.com/question/292283275/answer/484871888" target="_blank" rel="noopener">https://www.zhihu.com/question/292283275/answer/484871888</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 最短路のspfa </tag>
            
            <tag> 数据结构のpriority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组 解 POJ 2299 Quick-Sort</title>
      <link href="2019/03/03/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%A7%A3-POJ-2299-Quick-Sort/"/>
      <url>2019/03/03/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E8%A7%A3-POJ-2299-Quick-Sort/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence  9 1 0 5 4 ,</p></blockquote><a id="more"></a><blockquote><p>Ultra-QuickSort produces the output  0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. </p></blockquote><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">http://poj.org/problem?id=2299</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5</p><p>9 1 0 5 4</p><p>3</p><p>1 2 3</p><p>0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6</p><p>0</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>要查询出当前数字前面有几个比他大的数字，我们可以反着求，用前面的数字个数 - 比当前数字小的个数。而这个小的个数就是用树状数组的查询，开始时，我们把tree数组初始化为0，每当查询完毕一个数，我们就把tree[这个数]加一，这样我们只需要看看当前数字前面总共有多少个1就行了 </p></blockquote><p><strong>原文链接</strong> <a href="https://blog.csdn.net/weixin_43918531/article/details/87950037" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43918531/article/details/87950037</a></p><p><strong>树状数组</strong> <a href="https://www.cnblogs.com/hsd-/p/6139376.html" target="_blank" rel="noopener">https://www.cnblogs.com/hsd-/p/6139376.html</a></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 500005;struct node{    int val, pos, num;///pos :输入时的先后顺序                      ///num :由小到大的先后顺序}a[N];int tree[N];int n;long long sum;bool cmp_val(node a, node b){    return a.val &lt; b.val;}bool cmp_pos(node a, node b){    return a.pos &lt; b.pos;}int lowbit(int x)///得到x最低位1（后面补零）所代表的数{    return ( x &amp; (- x) );}void update(int pos)///单点更新（向上）{    for(int i = pos; i &lt;= n; i += lowbit(i))        tree[i]++;}int query(int pos)///区间查询（向下）{    int tem = 0;    for(int i = pos; i &gt;= 1; i -= lowbit(i))        tem += tree[i];    return tem;}int main(){//    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        sum = 0;        memset(tree, 0, sizeof(tree));        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;a[i].val);            a[i].pos = i;        }        sort(a + 1, a + 1 + n, cmp_val);///从小到大排序        for(int i = 1; i &lt;= n; ++i)            a[i].num = i;        sort(a + 1, a + 1 + n, cmp_pos);///按输入顺序排序        ///这个遍历过程需要其输入时的位置和其大小位置        for(int i = 1; i &lt;= n; ++i)        {///i代表输入先后顺序，a[i].num代表大小顺序（由小到大）            sum += i - 1 - query(a[i].num);            update(a[i].num);        }        cout &lt;&lt; sum &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链式前向星</title>
      <link href="2019/03/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"/>
      <url>2019/03/02/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h3><blockquote><p>链式前向星对于图的存储十分方便，我们可以对一个节点进行访问，遍历所有与他相连的边，从而访问与它临近的所有节点，比如说在bfs版本的spfa实现最短路时，就有很好的应用。</p><p>与邻接矩阵、邻接表不同的是，存的是“边”</p></blockquote><a id="more"></a><h3 id="Code-of-链式前向星存图与遍历"><a href="#Code-of-链式前向星存图与遍历" class="headerlink" title="Code of 链式前向星存图与遍历"></a>Code of 链式前向星存图与遍历</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100;struct node{    int from, to, w, pre;///pre存：与该边同一起点的下一条边的位置（排号，cnt计）}a[N];int head[N];///head[i]存：以i为起点的最新边的位置（排号，cnt计）int cnt = 1;void add(int from, int to, int w){    a[cnt].from = from;    a[cnt].to = to;    a[cnt].w = w;    a[cnt].pre = head[from];    head[from] = cnt;    cout &lt;&lt; &quot;边的排号 :&quot; &lt;&lt; cnt &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;边的起点 :&quot; &lt;&lt; a[cnt].from &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;边的终点 ：&quot; &lt;&lt; a[cnt].to &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;边的权重 ：&quot; &lt;&lt; a[cnt].w &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;共起点前一条边排号 : &quot; &lt;&lt; a[cnt].pre &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;共起点最新边排号 ：&quot; &lt;&lt; head[from] &lt;&lt; &#39;\n&#39;;    cnt++;}int main(){    int n;    int b, c, d;///起点、终点、权重    cin &gt;&gt; n;///存n条边    memset(head, -1, sizeof(head));    for(int i = 1; i &lt;= n; ++i)    {        cin &gt;&gt; b &gt;&gt; c &gt;&gt; d;        add(b, c, d);    }    for(int i = 1; i &lt;= 4; ++i)///对“点”        for(int k = head[i]; k != -1; k= a[k].pre)            cout &lt;&lt; i &lt;&lt; &quot;的相邻的点 ：&quot; &lt;&lt; a[k].to &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 数据结构の链式前向星 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序 解 POJ 2299 Quick-Sort</title>
      <link href="2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E8%A7%A3-POJ-2299-Quick-Sort/"/>
      <url>2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E8%A7%A3-POJ-2299-Quick-Sort/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence  9 1 0 5 4 ,</p></blockquote><a id="more"></a><blockquote><p>Ultra-QuickSort produces the output  0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. </p></blockquote><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">http://poj.org/problem?id=2299</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5</p><p>9 1 0 5 4</p><p>3</p><p>1 2 3</p><p>0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6</p><p>0</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>题目是“快排”，但我忘记快排是什么样的了，但归并排序与题目所描述契合，归并排序就是：比较相邻元素，进行数字移动，达到排序目的。我们只需要将中间“移动步数”这个量（我用tem表示的）累加起来即为答案</p></blockquote><h3 id="Code-of-this-problem-过程详解版"><a href="#Code-of-this-problem-过程详解版" class="headerlink" title="Code of this problem(过程详解版)"></a>Code of this problem(过程详解版)</h3><blockquote><p>中间输出了过程模拟，便于理解</p></blockquote><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 500005;int s[N];int ans[N];long long sum;///合并两个排好序的序列void my_merge(int * s, int start, int mid, int over){    cout &lt;&lt; &quot;本次排序开始&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;本次参与排序的数&quot; &lt;&lt; &#39;\n&#39;;    for(int t = start; t &lt;= over; ++t)        cout &lt;&lt; s[t] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    ///两个序列中的数相互比较，将较小的数先插入新的序列中    int i = start, j = mid + 1, k = start;    while(i &lt;= mid &amp;&amp; j &lt;= over)    {        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s[i] &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; s[j] &lt;&lt; &#39;\n&#39;;        if(s[i] &gt; s[j])        {            int tem = j - k;///此值记录了排序过程中移动数字的步数            cout &lt;&lt; &quot;tem的值 &quot; &lt;&lt; tem &lt;&lt; &#39;\n&#39;;            sum += tem;            ans[k++] = s[j++];        }        else            ans[k++] = s[i++];    }    ///剩余元素合并    while(i &lt;= mid)        ans[k++] = s[i++];    while(j &lt;= over)        ans[k++] = s[j++];    for(i = start; i &lt;= over; ++i)        s[i] = ans[i];    cout &lt;&lt; &quot;本次排序结果：&quot; &lt;&lt; &#39;\n&#39;;    for(i = start; i &lt;= over; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;本次排序结束&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;}void merge_sort(int * s, int start, int over){    if(start &lt; over)    {        int mid = (start + over) / 2;        merge_sort(s, start, mid);        merge_sort(s, mid + 1, over);        my_merge(s, start, mid, over);    }}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        sum = 0;        memset(s, 0, sizeof(s));        memset(ans, 0, sizeof(ans));        for(int i = 0; i &lt; n; ++i)            scanf(&quot;%d&quot;, &amp;s[i]);        merge_sort(s, 0, n - 1);        cout &lt;&lt; sum &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序图解版</title>
      <link href="2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3%E7%89%88/"/>
      <url>2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序过程探索"><a href="#归并排序过程探索" class="headerlink" title="归并排序过程探索"></a>归并排序过程探索</h3><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1296550461&auto=1&height=66"></iframe><p><img src="https://i.loli.net/2019/03/02/5c7a63cb8f244.png" alt="图片解析"></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int fr[N];int bk[N];///合并两个排好序的序列void my_merge(int * s, int start, int mid, int over){    cout &lt;&lt; &quot;合并开始&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;    int fr_len = mid - start + 1;    int bk_len = over - mid;    cout &lt;&lt; &quot;前部分长度 &quot; &lt;&lt; fr_len &lt;&lt; &quot; 后部分长度 &quot; &lt;&lt; bk_len &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; fr_len; ++i)        fr[i] = s[start + i];    for(int i = 0; i &lt; bk_len; ++i)        bk[i] = s[mid + 1 + i];    cout &lt;&lt; &quot;前部分元素&quot; &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; fr_len; ++i)        cout &lt;&lt; fr[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;后部分元素&quot; &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; bk_len; ++i)        cout &lt;&lt; bk[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    ///两个序列中的数相互比较，将较小的数先插入新的序列中    int i = 0, j = 0, k = start;    while(i &lt; fr_len &amp;&amp; j &lt; bk_len)    {        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; fr[i] &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; bk[j] &lt;&lt; &#39;\n&#39;;        if(fr[i] &lt; bk[j])            s[k++] = fr[i++];        else            s[k++] = bk[j++];    }    ///剩余元素合并    while(i &lt; fr_len)        s[k++] = fr[i++];    while(j &lt; bk_len)        s[k++] = bk[j++];    cout &lt;&lt; &quot;此次排序结果 ： &quot; &lt;&lt; &#39;\n&#39;;    for(int t = 0; t &lt; k; ++t)        cout &lt;&lt; s[t] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;本次合并结束&quot; &lt;&lt; &#39;\n&#39; &lt;&lt; &#39;\n&#39;;}void merge_sort(int * s, int start, int over){    if(start &lt; over)    {        int mid = (start + over) / 2;        merge_sort(s, start, mid);        merge_sort(s, mid + 1, over);        my_merge(s, start, mid, over);    }}int main(){    int s[] = {9, 4, 5, 7, 3, 6, 8, 2, 0, 1};    int len = sizeof(s) / sizeof(int);    int ans[len];    merge_sort(s, 0, len - 1);    for(int i = 0; i &lt; len; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 技巧の归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>2019/03/02/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><blockquote><p>归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 </p></blockquote><a id="more"></a><blockquote><p>归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 </p></blockquote><h3 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h3><blockquote><p>先将数据分开排序，然后再合并起来，最后形成一个排好的序列。 </p></blockquote><p><img src="https://i.loli.net/2019/03/02/5c7a4627673c8.jpg" alt="划分"></p><p><img src="https://i.loli.net/2019/03/02/5c7a465cd4ad2.jpg" alt="合并"></p><h3 id="Code-of-MERGE-SORT"><a href="#Code-of-MERGE-SORT" class="headerlink" title="Code of MERGE-SORT"></a>Code of MERGE-SORT</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int fr[N];int bk[N];///合并两个排好序的序列void my_merge(int * s, int start, int mid, int over){    int fr_len = mid - start + 1;    int bk_len = over - mid;    for(int i = 0; i &lt; fr_len; ++i)        fr[i] = s[start + i];    for(int i = 0; i &lt; bk_len; ++i)        bk[i] = s[mid + 1 + i];    ///两个序列中的数相互比较，将较小的数先插入新的序列中    int i = 0, j = 0, k = start;    while(i &lt; fr_len &amp;&amp; j &lt; bk_len)    {        if(fr[i] &lt; bk[j])            s[k++] = fr[i++];        else            s[k++] = bk[j++];    }    ///剩余元素合并    while(i &lt; fr_len)        s[k++] = fr[i++];    while(j &lt; bk_len)        s[k++] = bk[j++];}void merge_sort(int * s, int start, int over){    if(start &lt; over)    {        int mid = (start + over) / 2;        merge_sort(s, start, mid);        merge_sort(s, mid + 1, over);        my_merge(s, start, mid, over);    }}int main(){    int s[] = {9, 4, 5, 7, 3, 6, 8, 2, 0, 1};    int len = sizeof(s) / sizeof(int);    int ans[len];    merge_sort(s, 0, len - 1);    for(int i = 0; i &lt; len; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre><h3 id="Code-of-探索过程版"><a href="#Code-of-探索过程版" class="headerlink" title="Code of 探索过程版"></a>Code of 探索过程版</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;int fr[N];int bk[N];///合并两个排好序的序列void my_merge(int * s, int start, int mid, int over){    int fr_len = mid - start + 1;    int bk_len = over - mid;    cout &lt;&lt; &quot;前部分长度 &quot; &lt;&lt; fr_len &lt;&lt; &quot; 后部分长度 &quot; &lt;&lt; bk_len &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; fr_len; ++i)        fr[i] = s[start + i];    for(int i = 0; i &lt; bk_len; ++i)        bk[i] = s[mid + 1 + i];    cout &lt;&lt; &quot;前部分元素&quot; &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; fr_len; ++i)        cout &lt;&lt; fr[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    cout &lt;&lt; &quot;后部分元素&quot; &lt;&lt; &#39;\n&#39;;    for(int i = 0; i &lt; bk_len; ++i)        cout &lt;&lt; bk[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    ///两个序列中的数相互比较，将较小的数先插入新的序列中    int i = 0, j = 0, k = start;    while(i &lt; fr_len &amp;&amp; j &lt; bk_len)    {        cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; fr[i] &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; &#39; &#39; &lt;&lt; bk[j] &lt;&lt; &#39;\n&#39;;        if(fr[i] &lt; bk[j])            s[k++] = fr[i++];        else            s[k++] = bk[j++];    }    ///剩余元素合并    while(i &lt; fr_len)        s[k++] = fr[i++];    while(j &lt; bk_len)        s[k++] = bk[j++];    cout &lt;&lt; &quot;此次排序结果 ： &quot; &lt;&lt; &#39;\n&#39;;    for(int t = 0; t &lt; k; ++t)        cout &lt;&lt; s[t] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;}void merge_sort(int * s, int start, int over){    if(start &lt; over)    {        int mid = (start + over) / 2;        merge_sort(s, start, mid);        merge_sort(s, mid + 1, over);        my_merge(s, start, mid, over);    }}int main(){    int s[] = {9, 4, 5, 7, 3, 6, 8, 2, 0, 1};    int len = sizeof(s) / sizeof(int);    int ans[len];    merge_sort(s, 0, len - 1);    for(int i = 0; i &lt; len; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 技巧の归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2299  Ultra-QuickSort</title>
      <link href="2019/03/02/POJ-2299-Ultra-QuickSort/"/>
      <url>2019/03/02/POJ-2299-Ultra-QuickSort/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence  9 1 0 5 4 ,</p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2299" target="_blank" rel="noopener">http://poj.org/problem?id=2299</a></p><blockquote><p> Ultra-QuickSort produces the output  0 1 4 5 9 . Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence. </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 — the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>5</p><p>9 1 0 5 4</p><p>3</p><p>1 2 3</p><p>0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>6</p><p>0</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>因为是相邻的两个数两两交换，变成一个规定顺序的序列，相当于求一个序列的逆序数</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><strong>思路出处</strong> <a href="https://blog.csdn.net/summer__show_/article/details/52043126" target="_blank" rel="noopener">https://blog.csdn.net/summer__show_/article/details/52043126</a></p><p><del>我觉得他的代码不是按照他讲的写的</del></p><blockquote><p>转化为线段树：</p><p>我们先将原数组每个值附上一个序号pos，再将它排序。如题目的例子：</p><p>v：   9  1  0  5  4</p><p>pos：  1  2  3  4  5</p><p>排序后：</p><p>v：   0  1  4  5  9</p><p>pos：  3  2  5  4  1</p><p>然后由于排序后num为0的点排在原来数组的第3个，所以为了将它排到第一个去，那就至少需要向前移动两次，同时它也等价于最小的数0之前有2个数比它大（所以要移动两次），将0移到它自己的位置后，我们将0删掉（目的是为了不对后面产生影响）。再看第二大的数1，它出现在原数组的第二个，他之前有一个数比它大所以需要移动一次。这样一直循环下去那么着5个数所需要移动的次数就是：</p><p>v：  0  1  4  5  9</p><p>次数      2  1  2  1  0</p><p>将次数全部要加起来就是最后所需要移动的总次数</p></blockquote><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><blockquote><p>线段树区间节点的值存的是：此区间内元素的个数。由于有元素被删去，所以需要每次更新。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 500005;long long sum;///记住 &gt;= 2 个int相加可超intstruct node{    int L, R, val;}a[N &lt;&lt; 2];struct edge{    int v, pos;}b[N];bool cmp(edge a, edge b){    return a.v &lt; b.v;}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = 0;    if(l == r)    {        a[num].val = 1;        return ;    }    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}void update(int num, int pos){    if(a[num].L == a[num].R &amp;&amp; a[num].L == pos)    {        a[num].val = 0;///所谓删掉        return ;    }    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= pos)        update(num &lt;&lt; 1, pos);    else        update(num &lt;&lt; 1 | 1, pos);    a[num].val = a[num &lt;&lt; 1].val + a[num &lt;&lt; 1 | 1].val;}///num为当前区间编号，l、r为查询区间边界int query(int num, int l, int r){    if(l &gt; r)        return 0;//    cout &lt;&lt; &quot;目标区间 ：&quot; &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &#39;\n&#39;;    int sum = 0;    if(a[num].L == l &amp;&amp; a[num].R == r)    {//        cout &lt;&lt; &quot;找到了 &quot; &lt;&lt; l &lt;&lt; &#39; &#39; &lt;&lt; r &lt;&lt; &#39; &#39; &lt;&lt; a[num].val &lt;&lt; &#39;\n&#39;;        return a[num].val;    }    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        sum += query(num &lt;&lt; 1, l, r);///明确要找什么、去哪找    else if(mid &lt; l)        sum += query(num &lt;&lt; 1 | 1, l, r);    else        sum += query(num &lt;&lt; 1, l, mid) + query(num &lt;&lt; 1 | 1, mid + 1, r);    return sum;}int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)    {        init(1, 1, n);//        for(int i = 1; i &lt;= 2 * n - 1; ++i)//            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; a[i].L &lt;&lt; &#39; &#39; &lt;&lt; a[i].R &lt;&lt; &#39; &#39; &lt;&lt; a[i].val &lt;&lt; &#39;\n&#39;;        sum = 0;        for(int i = 1; i &lt;= n; ++i)        {            scanf(&quot;%d&quot;, &amp;b[i].v);            b[i].pos = i;        }        sort(b + 1, b + 1 + n, cmp);//        for(int i = 1; i &lt;= n; ++i)//            cout &lt;&lt; b[i].v &lt;&lt; &#39; &#39; &lt;&lt; b[i].pos &lt;&lt; &#39;\n&#39;;//        cout &lt;&lt; &#39;\n&#39;;        for(int i = 1; i &lt;= n; ++i)        {            int tem = query(1, 1, b[i].pos - 1);//            cout &lt;&lt; &quot;查询值 ： &quot; &lt;&lt; b[i].v &lt;&lt; &quot; 位置 ： &quot; &lt;&lt; b[i].pos &lt;&lt; &quot; 查询区间 ： &quot; &lt;&lt; &quot;1 ~ &quot; &lt;&lt; b[i].pos - 1 &lt;&lt; &#39; &#39; &lt;&lt; tem &lt;&lt; &#39;\n&#39;;            sum += tem;            update(1, b[i].pos);        }        cout &lt;&lt; sum &lt;&lt; &#39;\n&#39;;    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2528 Mayor&#39;s posters</title>
      <link href="2019/03/02/POJ-2528-Mayor-s-posters/"/>
      <url>2019/03/02/POJ-2528-Mayor-s-posters/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>The citizens of Bytetown, AB, could not stand that the candidates in the mayoral election campaign have been placing their electoral posters at all places at their whim. The city council has finally decided to build an electoral wall for placing the posters and introduce the following rules:  </p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://poj.org/problem?id=2528" target="_blank" rel="noopener">http://poj.org/problem?id=2528</a></p><ul><li>Every candidate can place exactly one poster on the wall. </li><li>All posters are of the same height equal to the height of the wall; the width of a poster can be any integer number of bytes (byte is the unit of length in Bytetown). </li><li>The wall is divided into segments and the width of each segment is one byte. </li><li>Each poster must completely cover a contiguous number of wall segments.</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The first line of input contains a number c giving the number of cases that follow. The first line of data for a single case contains number 1 &lt;= n &lt;= 10000. The subsequent n lines describe the posters in the order in which they were placed. The i-th line among the n lines contains two integer numbers li and ri which are the number of the wall segment occupied by the left end and the right end of the i-th poster, respectively. We know that for each 1 &lt;= i &lt;= n, 1 &lt;= li &lt;= ri &lt;= 10000000. After the i-th poster is placed, it entirely covers all wall segments numbered li, li+1 ,… , ri. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each input data set print the number of visible posters after all the posters are placed.   The picture below illustrates the case of the sample input.   </p></blockquote><p><img src="http://poj.org/images/2528_1.jpg" alt="样例"></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1</p><p>5</p><p>1 4</p><p>2 6</p><p>8 10</p><p>3 4</p><p>7 10</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>4</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>一面墙很长，贴海报于上。海报互遮挡，可见有几张？</p></blockquote><p><del>被敲代码耽误的诗人</del></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>离散化、线段树，赋给每个海报区间一个数字，最后找有几个不同的数字。”海报被覆盖“在代码中体现为“对应区间被赋予新值”，那就有个数字被覆盖了，意味着最终可数的数字减少</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote><p>简单的离散化可能会出现错误，给出下面两个简单的例子应该能体现普通离散化的缺陷:</p><p>例子一:1-10 1-4 5-10</p><p>例子二:1-10 1-4 6-10</p><p>普通离散化后都变成了[1,4][1,2][3,4]</p><p>线段2覆盖了[1,2],线段3覆盖了[3,4],那么线段1是否被完全覆盖掉了呢?</p><p>例子一是完全被覆盖掉了,而例子二没有被覆盖</p><p>解决的办法则是对于距离大于1的两相邻点，中间再插入一个点，本题还用到了Lazy标记的思想</p><p>直接更新区间进行标记而先不对子节点进行处理，如果需要往下更新再将标记下传一层。</p></blockquote><p><strong>原文出处</strong> <a href="https://www.cnblogs.com/xuejianye/p/5694750.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuejianye/p/5694750.html</a></p><h3 id="Code-of-improved-离散化"><a href="#Code-of-improved-离散化" class="headerlink" title="Code of improved 离散化"></a>Code of improved 离散化</h3><pre><code class="lang-c++">        ///改良版离散化        sort(tem, tem + tot);        ///m代表多少种数字；unique函数使得容器前m个数字不重复，        ///而后面的数字保持为原来的值        m = unique(tem, tem + tot) - tem;        int temporary = m;        for(int i = 0; i &lt; temporary - 1; ++i)            if(tem[i + 1] - tem[i] &gt; 1)                tem[m++] = tem[i] + 1;        sort(tem, tem + m);///离散化后的值&gt;=tem[0]</code></pre><h3 id="单点更新与区间更新"><a href="#单点更新与区间更新" class="headerlink" title="单点更新与区间更新"></a>单点更新与区间更新</h3><blockquote><p>区间更新涉及数据向下传递问题</p></blockquote><pre><code class="lang-c++">void down(int x)///数据下传{    if(a[x].val != -1)    {        a[x &lt;&lt; 1].val = a[x].val;        a[x &lt;&lt; 1 | 1].val = a[x].val;        a[x].val = -1;    }}</code></pre><h3 id="Code-of-this-problem-2019-3-2"><a href="#Code-of-this-problem-2019-3-2" class="headerlink" title="Code of this problem(2019/3/2)"></a>Code of this problem(2019/3/2)</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;struct node{    int L, R;    int val;} a[N &lt;&lt; 2];int m, ans;int b[N];int c[N];int tem[N &lt;&lt; 1];bool vis[N &lt;&lt; 1];void down(int x)///数据下传{    if(a[x].val != -1)    {        a[x &lt;&lt; 1].val = a[x].val;        a[x &lt;&lt; 1 | 1].val = a[x].val;        a[x].val = -1;    }}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = -1;///数字从0开始传的缘故    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}///针对不同的题目，更新函数必有所修改void update(int num, int l, int r, int t){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].val = t;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);///此节点非目标节点，数据下传    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r, t);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r, t);    else    {        update(num &lt;&lt; 1, l, mid, t);        update(num &lt;&lt; 1 | 1, mid + 1, r, t);    }}void slove(int num, int l, int r){//    cout &lt;&lt; num &lt;&lt; &#39; &#39; &lt;&lt; a[num].L &lt;&lt; &quot; &quot; &lt;&lt; a[num].R &lt;&lt; &#39; &#39; &lt;&lt; a[num].val &lt;&lt; &#39; &#39; &lt;&lt; vis[ a[num].val ] &lt;&lt; &#39;\n&#39;;    if(a[num].val != -1 &amp;&amp; !vis[ a[num].val ])    {        vis[ a[num].val ] = 1;        ans++;    }    if(a[num].L == a[num].R)///到底了,返回        return ;    down(num);    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    slove(num &lt;&lt; 1, l, mid);    slove(num &lt;&lt; 1 | 1, mid + 1, r);}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        memset(b, 0, sizeof(b));        memset(c, 0, sizeof(c));        memset(tem, 0, sizeof(tem));        memset(vis, 0, sizeof(vis));        int n;        cin &gt;&gt; n;        int tot = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);            tem[tot++] = b[i];            tem[tot++] = c[i];        }        ///改良版离散化        sort(tem, tem + tot);        m = unique(tem, tem + tot) - tem;        int temporary = m;        for(int i = 0; i &lt; temporary - 1; ++i)            if(tem[i + 1] - tem[i] &gt; 1)                tem[m++] = tem[i] + 1;        sort(tem, tem + m);        init(1, 1, m);        for(int i = 0; i &lt; n; ++i)///数字是从0开始传        {            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;            update(1, tl, tr, i);        }        ans = 0;        slove(1, 1, m + 1);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="第二次做（2019-4-15）"><a href="#第二次做（2019-4-15）" class="headerlink" title="第二次做（2019/4/15）"></a>第二次做（2019/4/15）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;struct node{    int L, R, val;}a[N &lt;&lt; 2 | 1];int ans, b[N], c[N], tem[N &lt;&lt; 1];bool vis[N &lt;&lt; 1];void down(int x){    if(a[x].val != -1)///0被占用    {        a[x &lt;&lt; 1].val = a[x].val;        a[x &lt;&lt; 1 | 1].val = a[x].val;        a[x].val = -1;    }}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = -1;///数字从0开始传的缘故    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void update(int num, int l, int r, int t){    if(a[num].L &gt; r || a[num].R &lt; l)        return ;    if(a[num].L &gt;= l &amp;&amp; a[num].R &lt;= r)    {        a[num].val = t;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);    update(num &lt;&lt; 1, l, r, t);    update(num &lt;&lt; 1 | 1, l, r, t);}void slove(int num, int l, int r)///区间[l,r]内有多少种数字{    if(a[num].val != -1 &amp;&amp; !vis[ a[num].val ])    {        vis[ a[num].val ] = 1;        ans++;///为了遍历到底，这里没有 return    }    if(a[num].L == a[num].R)///到底了,返回        return ;    down(num);    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    slove(num &lt;&lt; 1, l, mid);    slove(num &lt;&lt; 1 | 1, mid + 1, r);}int main(){    int t;    scanf(&quot;%d&quot;, &amp;t);    while(t--)    {        memset(b, 0, sizeof(b));        memset(c, 0, sizeof(c));        memset(tem, 0, sizeof(tem));        memset(vis, 0, sizeof(vis));        int n;        scanf(&quot;%d&quot;, &amp;n);        int tot = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);            tem[tot++] = b[i];            tem[tot++] = c[i];        }        sort(tem, tem + tot);        ///m代表多少种数字，函数把重复的数字后放        int m = unique(tem, tem + tot) - tem;        int tempory = m;        for(int i = 0; i + 1 &lt; tempory; ++i)            if(tem[i + 1] - tem[i] &gt; 1)                tem[m++] = tem[i] + 1;        sort(tem, tem + m);///离散化后的值&gt;=tem[0]        init(1, 1, m);        for(int i = 0; i &lt; n; ++i)        {   /// + 1 是因为线段树的左界是从1开始的            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;            update(1, tl, tr, i);///区间赋值为i        }        ans = 0;        slove(1, 1, m);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> 计算几何の离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散化 线段树 HDU 5124</title>
      <link href="2019/03/01/%E7%A6%BB%E6%95%A3%E5%8C%96-%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-5124/"/>
      <url>2019/03/01/%E7%A6%BB%E6%95%A3%E5%8C%96-%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-5124/</url>
      
        <content type="html"><![CDATA[<h3 id="关于离散化"><a href="#关于离散化" class="headerlink" title="关于离散化"></a>关于离散化</h3><blockquote><p>离散化是什么：一些数字，他们的范围很大（0-1e9），但是个数不算多（1-1e5），并且这些数本身的数字大小不重要，重要的是这些数字之间的相对大小（比如说某个数字是这些数字中的第几小，而与这个数字本身大小没有关系，要的是相对大小）（6 8 9 4 离散化后即为 2 3 4 1）（要理解相对大小的意思）（6在这4个数字中排第二小，那么就把6离散化成2，与数字6本身没有关系， 8,9,4亦是如此）</p></blockquote><p><del>我个人觉得“离散化”根据其功能明明应该命名为“聚敛化”</del></p> <a id="more"></a><p><strong>更多关于离散化</strong> <a href="https://blog.csdn.net/xiangaccepted/article/details/73276826" target="_blank" rel="noopener">https://blog.csdn.net/xiangaccepted/article/details/73276826</a> </p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>John has several lines. The lines are covered on the X  axis. Let A is a point which is covered by the most lines. John wants to know  how many lines cover A.</p></blockquote><p>题目链接： <a href="http://acm.hdu.edu.cn/showproblem.php?pid=5124" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=5124</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The first line contains a single integer (the data for  less than 11 cases),indicating the number of test cases.<br>Each test case begins with an integer ,indicating the number of lines.Next N lines contains two integers  and ,describing a line. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each case, output an integer means how many lines cover A. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="lang-c++">251 2 2 22 43 45 100051 12 23 34 45 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3</p><p>1</p></blockquote><h3 id="Code-of-离散化部分"><a href="#Code-of-离散化部分" class="headerlink" title="Code of 离散化部分"></a>Code of 离散化部分</h3><pre><code class="lang-c++">        for(int i = 0; i &lt; n; ++i)        {//            cin &gt;&gt; b[i] &gt;&gt; c[i];            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);///cin就超时，scanf就过...            tem[tot++] = b[i];            tem[tot++] = c[i];        }        sort(tem, tem + tot);        int m = unique(tem, tem + tot) - tem;        init(1, 1, m);        for(int i = 0; i &lt; n; ++i)        {                ///+ 1 是为了让区间标号从1开始            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;            update(1, tl, tr);        }</code></pre><blockquote><p>m记的是不同的元素个数，也就是要“聚敛“到 1 ~ m这个区间上</p><p>lower_bound操作等效聚敛</p></blockquote><h3 id="Code-of-this-problem"><a href="#Code-of-this-problem" class="headerlink" title="Code of this problem"></a>Code of this problem</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100005;struct node{    int L, R;    int val;    int mmax;} a[N &lt;&lt; 2];int b[N];int c[N];int tem[N &lt;&lt; 1];void down(int x)///对标号为x的区间的左右孩子区间更新val、mmax{    if(a[x].val)    {        a[x &lt;&lt; 1].val += a[x].val;        a[x &lt;&lt; 1].mmax += a[x].val;        a[x &lt;&lt; 1 | 1].val += a[x].val;        a[x &lt;&lt; 1 | 1].mmax += a[x].val;        a[x].val = 0;    }}void init(int num, int l, int r){    a[num].L = l;    a[num].R = r;    a[num].val = 0;    a[num].mmax = 0;    if(l == r)        return ;    int mid = (l + r) &gt;&gt; 1;    init(num &lt;&lt; 1, l, mid);    init(num &lt;&lt; 1 | 1, mid + 1, r);}void update(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].val++;        a[num].mmax++;        return ;    }    if(a[num].L == a[num].R)        return ;    down(num);    int mid = (a[num].L + a[num].R) &gt;&gt; 1;    if(mid &gt;= r)        update(num &lt;&lt; 1, l, r);    else if(mid &lt; l)        update(num &lt;&lt; 1 | 1, l, r);    else    {        update(num &lt;&lt; 1, l, mid);        update(num &lt;&lt; 1 | 1, mid + 1, r);    }    a[num].mmax = max(a[num &lt;&lt; 1].mmax, a[num &lt;&lt; 1 | 1].mmax);}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        memset(b, 0, sizeof(b));        memset(c, 0, sizeof(c));        memset(tem, 0, sizeof(tem));        int n;        cin &gt;&gt; n;        int tot = 0;        for(int i = 0; i &lt; n; ++i)        {//            cin &gt;&gt; b[i] &gt;&gt; c[i];            scanf(&quot;%d%d&quot;, &amp;b[i], &amp;c[i]);///cin就超时，scanf就过...            tem[tot++] = b[i];            tem[tot++] = c[i];        }        sort(tem, tem + tot);        int m = unique(tem, tem + tot) - tem;        init(1, 1, m);        for(int i = 0; i &lt; n; ++i)        {            int tl = lower_bound(tem, tem + m, b[i]) - tem + 1;            int tr = lower_bound(tem, tem + m, c[i]) - tem + 1;            update(1, tl, tr);//            cout &lt;&lt; tl &lt;&lt; &#39; &#39; &lt;&lt; tr &lt;&lt; &#39;\n&#39;;        }        cout &lt;&lt; a[1].mmax &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
            <tag> 计算几何の离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树 HDU 1556 Color the ball</title>
      <link href="2019/02/28/%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1556/"/>
      <url>2019/02/28/%E7%BA%BF%E6%AE%B5%E6%A0%91-HDU-1556/</url>
      
        <content type="html"><![CDATA[<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><blockquote><p>擅长处理区间，可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN)。而未优化的空间复杂度为2N，实际应用时一般还要开4N的数组以免越界，因此有时需要离散化让空间压缩。 </p></blockquote><a id="more"></a><p><img src="https://p1.ssl.qhmsg.com/t019962d43ac8e17481.png" alt="线段树"></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。  当N = 0，输入结束。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>31 12 23 331 11 21 30</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1 1 1</p><p>3 2 1</p></blockquote><p><strong>啥也不说了，<del>都在酒里，</del> 都在代码里。</strong></p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 100005;struct node{    int L, R;    int val;} a[N * 4];///对于三个函数中的l 、r///init: l、r是分割时被 “固定” 划分的区间///update与query：l、r是操作时外界“自由”给出的区间///初始化void init(int num, int l, int r)///num为从根到叶的区间排号{    ///初始化当前区间    a[num].L = l;    a[num].R = r;    a[num].val = 0;    if(l == r)///区间长度到1后退出        return ;    ///递归初始化子区间    int mid = (l + r) / 2;    init(num * 2, l, mid);    init(num * 2 + 1, mid + 1, r);}///更新(排号为num的、以l为左界以r为右界的区间的val)void update(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)    {        a[num].val++;///针对此题val加一，其他题视题意而定        return ;    }    if(a[num].L == a[num].R)///都找到&quot;点&quot;了，还没找到区间        return ;    int mid = (a[num].L + a[num].R) / 2;    ///当前查找区间 的中值 在 目标区间 的右侧，去左孩子找    if(mid &gt;= r)        update(num * 2, l, r);    ///当前查找区间 的中值 在目标区间 的左侧    else if(mid &lt; l)///注意！这里没有等号！这里没有等号！        update(num * 2 + 1, l, r);    ///当前查找区间 的中值 在目标区间 里！    else    {        update(num * 2, l, mid);        update(num * 2 + 1, mid + 1, r);    }}int query(int num, int l, int r){    if(a[num].L == l &amp;&amp; a[num].R == r)        return a[num].val;    if(a[num].L == a[num].R)        return 0;    int mid = (a[num].L + a[num].R) / 2;    if(mid &gt;= r)        return a[num].val + query(num * 2, l, r);    else if(mid &lt; l)        return a[num].val + query(num * 2 + 1, l, r);    else        return a[num].val + query(num * 2, l, mid) + query(num * 2 + 1, mid + 1, r);}int main(){    int n;    while(cin &gt;&gt; n &amp;&amp; n)    {        init(1, 1, n);        for(int i = 0; i &lt; n; ++i)        {            int a, b;            cin &gt;&gt; a &gt;&gt; b;            update(1, a, b);        }        for(int i = 1; i &lt;= n; ++i)            printf(&quot;%d%c&quot;, query(1, i, i), i == n ? &#39;\n&#39;: &#39; &#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序 HDU 3342</title>
      <link href="2019/02/28/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-HDU-3342/"/>
      <url>2019/02/28/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-HDU-3342/</url>
      
        <content type="html"><![CDATA[<p><strong>拓扑排序判断各工程先后顺序是否出现矛盾（a -&gt; b, b -&gt; c, c -&gt; a）</strong></p><blockquote><p>BFS在这方面较DFS有些先天优势，统计入队结点数，看是否等于工程数</p><p>DFS的vis[]数组改为0， -1， 1三个状态，0代表未访问，-1代表访问完毕，1代表是这一阶段正在访问的 （注意 if(-1) 相当于 if(1) ）【坑了自己一阵】</p></blockquote><p><strong>注意n个工程是（0 ~ n - 1 ）还是 （1 ~ n）</strong></p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>ACM-DIY is a large QQ group where many excellent acmers get together. It is so harmonious that just like a big family. Every day,many “holy cows” like HH, hh, AC, ZT, lcc, BF, Qinz and so on chat on-line to exchange their ideas. When someone has questions, many warm-hearted cows like Lost will come to help. Then the one being helped will call Lost “master”, and Lost will have a nice “prentice”. By and by, there are many pairs of “master and prentice”. But then problem occurs: there are too many masters and too many prentices, how can we know whether it is legal or not?  We all know a master can have many prentices and a prentice may have a lot of masters too, it’s legal. Nevertheless，some cows are not so honest, they hold illegal relationship. Take HH and 3xian for instant, HH is 3xian’s master and, at the same time, 3xian is HH’s master,which is quite illegal! To avoid this,please help us to judge whether their relationship is legal or not.   Please note that the “master and prentice” relation is transitive. It means that if A is B’s master ans B is C’s master, then A is C’s master. </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of several test cases. For each case, the first line contains two integers, N (members to be tested) and M (relationships to be tested)(2 &lt;= N, M &lt;= 100). Then M lines follow, each contains a pair of (x, y) which means x is y’s master and y is x’s prentice. The input is terminated by N = 0.  TO MAKE IT SIMPLE, we give every one a number (0, 1, 2,…, N-1). We use their numbers instead of their names. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case, print in one line the judgement of the messy relationship.  If it is legal, output “YES”, otherwise “NO”. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>3 20 11 22 20 11 00 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>YESNO</code></pre><h3 id="Code-DFS"><a href="#Code-DFS" class="headerlink" title="Code(DFS)"></a>Code(DFS)</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int vis[105];stack&lt;int&gt; ans;vector&lt;int&gt; v[105];bool dfs(int x){    vis[x] = 1;    for(int i = 0; i &lt; v[x].size(); ++i)    {        if( vis[ v[x][i] ] == 1 )///递归时搜到自己            return 0;        if( vis[ v[x][i] ] == 0 &amp;&amp; !dfs(v[x][i]) )            return 0;    }    vis[x] = -1;//    ans.push(x);    return 1;}int main(){    int n, m;    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))    {        bool flag = 1;        memset(vis, 0, sizeof(vis));///多组输入要加上        for(int i = 0; i &lt; n; ++i)            v[i].clear();        for(int i = 0; i &lt; m; ++i)        {            int a, b;            cin &gt;&gt; a &gt;&gt; b;            v[a].push_back(b);        }        for(int i = 0; i &lt; n; ++i)///不相连的多个图            if(vis[i] == 0)            {                if(!dfs(i))                {                    flag = 0;                    break;                }            }//        while(ans.size())//        {//            printf(&quot;%d%c&quot;, ans.top(), ans.size() == 1 ? &#39;\n&#39; : &#39; &#39;);//            ans.pop();//        }        if(flag)            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code-BFS"><a href="#Code-BFS" class="headerlink" title="Code(BFS)"></a>Code(BFS)</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int in[105];//vector&lt;int&gt; ans;vector&lt;int&gt; v[105];bool bfs(queue&lt;int&gt; q){    int sum = 0;    while(q.size())    {        int tem = q.front();//        ans.push_back(tem);        sum++;        q.pop();        for(int i = 0; i &lt; v[tem].size(); ++i)        {            in[ v[tem][i] ]--;            if(!in[ v[tem][i] ])                q.push(v[tem][i]);        }    }    return sum == n;}int main(){    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))    {        queue&lt;int&gt; q;        memset(in, 0, sizeof(in));//        ans.clear();        for(int i = 0; i &lt; n; ++i)            v[i].clear();        int a, b;        for(int i = 0; i &lt; m; ++i)        {            cin &gt;&gt; a &gt;&gt; b;            v[a].push_back(b);            in[b]++;        }        for(int i = 0; i &lt; n; ++i)///0 ~ n - 1            if(!in[i])                q.push(i);        cout &lt;&lt; ( bfs(q) ? &quot;YES&quot; : &quot;NO&quot; ) &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
            <tag> 图论の拓扑排序(判环) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序 UVA 10305</title>
      <link href="2019/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-UVA-10305/"/>
      <url>2019/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-UVA-10305/</url>
      
        <content type="html"><![CDATA[<p><strong>拓扑排序解决工程的先后问题</strong></p><blockquote><p>DFS在这方面较BFS有些先天优势，本身按工程的先后顺序搜索。答案由后向前存入stack</p><p>BFS加一个 in[] 数组，保证某一个工程（其前面有许多工程）在可行方案中尽量靠后放。答案由前向后存入vector</p></blockquote><a id="more"></a><p><strong>题目链接</strong>  <a href="https://vjudge.net/problem/UVA-10305" target="_blank" rel="noopener">https://vjudge.net/problem/UVA-10305</a></p><p><strong>更多关于拓扑排序</strong> <a href="https://blog.csdn.net/weixin_43918531/article/details/86740991" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43918531/article/details/86740991</a></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>John has n tasks to do. Unfortunately, the tasks are not independent and the execution of one task is only possible if other tasks have already been executed. </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input will consist of several instances of the problem. Each instance begins with a line containing two integers, 1 ≤ n ≤ 100 and m. n is the number of tasks (numbered from 1 to n) and m is the number of direct precedence relations between tasks. After this, there will be m lines with two integers i and j, representing the fact that task i must be executed before task j. An instance with n = m = 0 will finish the input. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each instance, print a line with n integers representing the tasks in a possible order of execution </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>5 41 22 31 31 50 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1 4 2 5 3</p></blockquote><h5 id="BFS与DFS（由于搜索方式不同）给出的可行方案也许、多半会不一样，像这题，BFS给出的方案同Sample-Output-：-1-4-2-5-3，而DFS是：4-1-5-2-3"><a href="#BFS与DFS（由于搜索方式不同）给出的可行方案也许、多半会不一样，像这题，BFS给出的方案同Sample-Output-：-1-4-2-5-3，而DFS是：4-1-5-2-3" class="headerlink" title="BFS与DFS（由于搜索方式不同）给出的可行方案也许、多半会不一样，像这题，BFS给出的方案同Sample Output ： 1 4 2 5 3，而DFS是：4 1 5 2 3"></a>BFS与DFS（由于搜索方式不同）给出的可行方案也许、多半会不一样，像这题，BFS给出的方案同Sample Output ： 1 4 2 5 3，而DFS是：4 1 5 2 3</h5><h3 id="Code（DFS）"><a href="#Code（DFS）" class="headerlink" title="Code（DFS）"></a>Code（DFS）</h3><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool vis[105];stack&lt;int&gt; ans;vector&lt;int&gt; v[105];void dfs(int x){    vis[x] = 1;    for(int i = 0; i &lt; v[x].size(); ++i)        if( !vis[ v[x][i] ] )            dfs(v[x][i]);    ans.push(x);}int main(){    int n, m;    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))    {        memset(vis, 0, sizeof(vis));///多组输入要加上        for(int i = 0; i &lt; 105; ++i)            v[i].clear();        for(int i = 0; i &lt; m; ++i)        {            int a, b;            cin &gt;&gt; a &gt;&gt; b;            v[a].push_back(b);        }        for(int i = 1; i &lt;= n; ++i)///不相连的多个图            if(!vis[i])                dfs(i);        while(ans.size())        {            printf(&quot;%d%c&quot;, ans.top(), ans.size() == 1 ? &#39;\n&#39; : &#39; &#39;);            ans.pop();        }    }    return 0;}</code></pre><h3 id="Code-BFS"><a href="#Code-BFS" class="headerlink" title="Code(BFS)"></a>Code(BFS)</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int in[105];vector&lt;int&gt; ans;vector&lt;int&gt; v[105];void bfs(queue&lt;int&gt; q){    while(q.size())    {        int tem = q.front();        ans.push_back(tem);        q.pop();        for(int i = 0; i &lt; v[tem].size(); ++i)        {            in[ v[tem][i] ]--;            if(!in[ v[tem][i] ])                q.push(v[tem][i]);        }    }}int main(){    int n, m;    while(cin &gt;&gt; n &gt;&gt; m &amp;&amp; (n || m))    {        queue&lt;int&gt; q;        memset(in, 0, sizeof(in));        ans.clear();        for(int i = 0; i &lt; 105; ++i)            v[i].clear();        int a, b;        for(int i = 0; i &lt; m; ++i)        {            cin &gt;&gt; a &gt;&gt; b;            v[a].push_back(b);            in[b]++;        }        for(int i = 1; i &lt;= n; ++i)            if(!in[i])                q.push(i);        bfs(q);        for(int i = 0; i &lt; ans.size(); ++i)            printf(&quot;%d%c&quot;, ans[i], i == ans.size() - 1 ? &#39;\n&#39; : &#39; &#39;);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
            <tag> 图论の拓扑排序(无环) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDNUOJ 1169火星人</title>
      <link href="2019/02/26/SDNUOJ-1169%E7%81%AB%E6%98%9F%E4%BA%BA/"/>
      <url>2019/02/26/SDNUOJ-1169%E7%81%AB%E6%98%9F%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。</p></blockquote><a id="more"></a><p><strong>题目链接</strong> <a href="http://www.acmicpc.sdnu.edu.cn/problem/show/1169" target="_blank" rel="noopener">http://www.acmicpc.sdnu.edu.cn/problem/show/1169</a></p><blockquote><p>火星人用一种非常简单的方式来表示数字——掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为1，2，3……。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。</p><p>一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指——拇指、食指、中指、无名指和小指分别编号为1，2，3，4和5，当它们按正常顺序排列时，形成了5位数12345，当你交换无名指和小指的位置时，会形成5位数12354，当你把五个手指的顺序完全颠倒时，会形成54321，在所有能够形成的120个5位数中，12345最小，它表示1；12354第二小，它表示2；54321最大，它表示120。下表展示了只有3根手指时能够形成的6个3位数和它们代表的数字：</p></blockquote><pre><code>三进制数 123 132 213 231 312 321代表的数字 1 2 3 4 5 6</code></pre><blockquote><p>现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>输入包括三行，第一行有一个正整数N，表示火星人手指的数目（1 &lt;= N &lt;= 10000）。第二行是一个正整数M，表示要加上去的小整数（1 &lt;= M &lt;= 100）。下一行是1到N这N个整数的一个排列，用空格隔开，表示火星人手指的排列顺序 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>输出只有一行，这一行含有N个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>531 2 3 4 5</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1 2 3 4 5</code></pre><h3 id="关于next-permutation与prev-permutation"><a href="#关于next-permutation与prev-permutation" class="headerlink" title="关于next_permutation与prev_permutation"></a>关于next_permutation与prev_permutation</h3><blockquote><p>next_permutation(start,end)//当前排列的下一个排列 </p><p>prev_permutation(start,end)//当前排列的上一个排列 </p></blockquote><h1 id="字典序！（记住这三个字，保持敏感）"><a href="#字典序！（记住这三个字，保持敏感）" class="headerlink" title="字典序！（记住这三个字，保持敏感）"></a>字典序！（记住这三个字，保持敏感）</h1><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int N;    cin &gt;&gt; N;    int tem;    cin &gt;&gt; tem;    int a[10005];    for(int i = 0; i &lt; N; ++i)        cin &gt;&gt; a[i];    while(next_permutation(a, a + N))    {        tem--;        if(!tem)        {            for(int i = 0; i &lt; N; ++i)                printf(&quot;%d%c&quot;, a[i], i == N - 1 ? &#39;\n&#39;: &#39; &#39;);            break;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 函数のnext_permutation </tag>
            
            <tag> 函数のprev_permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1716排列2</title>
      <link href="2019/02/26/HDU-1716%E6%8E%92%E5%88%972/"/>
      <url>2019/02/26/HDU-1716%E6%8E%92%E5%88%972/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>现有四张卡片，用这四张卡片能排列出很多不同的4位数，要求按从小到大的顺序输出这些4位数。  </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>每组数据占一行，代表四张卡片上的数字（0&lt;=数字&lt;=9），如果四张卡片都是0，则输入结束。  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对每组卡片按从小到大的顺序输出所有能由这四张卡片组成的4位数，千位数字相同的在同一行，同一行中每个四位数间用空格分隔。  每组输出数据间空一行，最后一组数据后面没有空行。  </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>1 2 3 41 1 2 30 1 2 30 0 0 0</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>1234 1243 1324 1342 1423 14322134 2143 2314 2341 2413 24313124 3142 3214 3241 3412 34214123 4132 4213 4231 4312 43211123 1132 1213 1231 1312 13212113 2131 23113112 3121 32111023 1032 1203 1230 1302 13202013 2031 2103 2130 2301 23103012 3021 3102 3120 3201 3210</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>用set自带的排序与除重，set操作不多不便，将其中数据传入vector</p><p>不过这题的输出格式真那啥…</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int a[4];    bool flag = 0;    while(cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2] &gt;&gt; a[3])    {        if(!a[0] &amp;&amp; !a[1] &amp;&amp; !a[2] &amp;&amp; !a[3] )            break;        if(flag)            cout &lt;&lt; &#39;\n&#39;;        flag = 1;        set&lt;int&gt; st;        for(int i = 0; i &lt; 4; ++i)            for(int j = 0; j &lt; 4; ++j)                for(int h = 0; h &lt; 4; ++h)                    for(int k = 0; k &lt; 4; ++k)                    {                        if(i == j || i == h || i == k || j == h || j == k || h == k)                            continue;                        int tem = 1000 * a[i] + 100 * a[j] + 10 * a[h] + a[k];                        if(tem &gt;= 1000)///保证是四位数                            st.insert(tem);                    }        vector&lt;int&gt; vec;        for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); ++it)            vec.push_back(*it);        for(int i = 0; i &lt; vec.size() - 1; ++i)            printf(&quot;%d%c&quot;, vec[i], vec[i] / 1000 == vec[i + 1] / 1000 ? &#39; &#39; : &#39;\n&#39;);        cout &lt;&lt; vec[vec.size() - 1] &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构のset </tag>
            
            <tag> 数据结构のvector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1231 最大连续子序列</title>
      <link href="2019/02/25/HDU-1231-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>2019/02/25/HDU-1231-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,  Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，  例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和  为20。  在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该  子序列的第一个和最后一个元素。  </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>测试输入包含若干测试用例，每个测试用例占2行，第1行给出正整数K( &lt; 10000 )，第2行给出K个整数，中间用空格分隔。当K为0时，输入结束，该用例不被处理。  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对每个测试用例，在1行里输出最大和、最大连续子序列的第一个和最后一个元  素，中间用空格分隔。如果最大连续子序列不唯一，则输出序号i和j最小的那个（如输入样例的第2、3组）。若所有K个元素都是负数，则定义其最大和为0，输出整个序列的首尾元素。  </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>6-2 11 -4 13 -5 -210-10 1 2 3 4 -5 -23 3 7 -2165 -8 3 2 5 01103-1 -5 -23-1 0 -20</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>20 11 1310 1 410 3 510 10 100 -1 -20 0 0</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>dp[i]表示以i结尾的最大连续子序列的和 (也可以直接以数学思维做)</p></blockquote><h3 id="Code-动态规划"><a href="#Code-动态规划" class="headerlink" title="Code(动态规划)"></a>Code(动态规划)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n;    while(cin &gt;&gt; n &amp;&amp; n)    {        long long a[10005];        long long dp[10005];        bool flag = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lld&quot;, &amp;a[i]);            if(a[i] &gt;= 0)                flag = 1;        }        if(!flag)        {            cout &lt;&lt; &#39;0&#39; &lt;&lt; &#39; &#39; &lt;&lt; a[0] &lt;&lt; &#39; &#39; &lt;&lt; a[n - 1] &lt;&lt; &#39;\n&#39;;            continue;        }        int mmax = -1;///为了不漏0        int start = 0;        int over = 0;        ///dp的时候注意第一个的初始化        dp[0] = a[0];        if(dp[0] &gt; mmax)        {            mmax = dp[0];            over = 0;        }        for(int i = 1; i &lt; n; ++i)        {            dp[i] = max(dp[i - 1] + a[i], a[i]);            if(dp[i] &gt; mmax)            {                mmax = dp[i];                over = i;            }        }        ///找最靠前的start        int tem = mmax;        for(int i = over; i &gt;= 0; --i)        {            tem -= a[i];            if(tem == 0)                start = i;        }        cout &lt;&lt; mmax &lt;&lt; &quot; &quot; &lt;&lt; a[start] &lt;&lt; &quot; &quot; &lt;&lt; a[over] &lt;&lt; &#39;\n&#39;;    }}</code></pre><p><strong>数学思维</strong>  <a href="https://blog.csdn.net/chikchen/article/details/84501429" target="_blank" rel="noopener">https://blog.csdn.net/chikchen/article/details/84501429</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1263 水果</title>
      <link href="2019/02/25/HDU-1263-%E6%B0%B4%E6%9E%9C/"/>
      <url>2019/02/25/HDU-1263-%E6%B0%B4%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Joe经营着一个不大的水果店.他认为生存之道就是经营最受顾客欢迎的水果.现在他想要一份水果销售情况的明细表 </p></blockquote><p><strong>题目链接</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1263" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1263</a></p><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>第一行正整数N(0&lt;N&lt;=10)表示有N组测试数据.  每组测试数据的第一行是一个整数M(0&lt;M&lt;=100),表示工有M次成功的交易.其后有M行数据,每行表示一次交易,由水果名称(小写字母组成,长度不超过80),水果产地(小写字母组成,长度不超过80)和交易的水果数目(正整数,不超过100)组成.  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对于每一组测试数据,请你输出一份排版格式正确(请分析样本输出)的水果销售情况明细表.这份明细表包括所有水果的产地,名称和销售数目的信息.水果先按产地分类,产地按字母顺序排列;同一产地的水果按照名称排序,名称按字母顺序排序.  两组测试数据之间有一个空行.最后一组测试数据之后没有空行.  </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>15apple shandong 3pineapple guangdong 1sugarcane guangdong 1pineapple guangdong 3pineapple guangdong 1</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code>guangdong   |----pineapple(5)   |----sugarcane(1)shandong   |----apple(3)</code></pre><h3 id="关于map"><a href="#关于map" class="headerlink" title="关于map"></a>关于map</h3><blockquote><p>map中的元素是自动按Key升序排序 </p><p>用insert函数插入数据，在数据的 插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值 </p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main(){    int t,n;    int cnt;    string fruit,address;    cin &gt;&gt; t;    while(t--)    {        map&lt;string, map&lt;string,int&gt; &gt;mm;        map&lt;string, map&lt;string,int&gt; &gt;::iterator itw;        map&lt;string,int&gt;::iterator itn;        cin &gt;&gt; n;        while(n--)        {            cin &gt;&gt; fruit &gt;&gt; address &gt;&gt; cnt;            mm[address][fruit] += cnt;///精华        }        for(itw = mm.begin(); itw != mm.end(); itw++)        {            cout &lt;&lt; itw -&gt; first &lt;&lt; &#39;\n&#39;;            for(itn = itw -&gt; second.begin(); itn != itw -&gt; second.end(); itn++)            {                cout &lt;&lt; &quot;   |----&quot; &lt;&lt; itn -&gt; first &lt;&lt; &quot;(&quot; &lt;&lt; itn -&gt; second &lt;&lt; &quot;)&quot; &lt;&lt; &#39;\n&#39;;            }        }        if(t!=0)            cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1075 What are you Talking About</title>
      <link href="2019/02/25/HDU-1075-What-are-you-Talking-About/"/>
      <url>2019/02/25/HDU-1075-What-are-you-Talking-About/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Ignatius is so lucky that he met a Martian yesterday. But he didn’t know the language the Martians use. The Martian gives him a history book of Mars and a dictionary when it leaves. Now Ignatius want to translate the history book into English. Can you help him?  </p></blockquote><a id="more"></a><p><em>题目链接</em>  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1075" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1075</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The problem has only one test case, the test case consists of two parts, the dictionary part and the book part. The dictionary part starts with a single line contains a string “START”, this string should be ignored, then some lines follow, each line contains two strings, the first one is a word in English, the second one is the corresponding word in Martian’s language. A line with a single string “END” indicates the end of the directory part, and this string should be ignored. The book part starts with a single line contains a string “START”, this string should be ignored, then an article written in Martian’s language. You should translate the article into English with the dictionary. If you find the word in the dictionary you should translate it and write the new word into your translation, if you can’t find the word in the dictionary you do not have to translate it, and just copy the old word to your translation. Space(‘ ‘), tab(‘\t’), enter(‘\n’) and all the punctuation should not be translated. A line with a single string “END” indicates the end of the book part, and that’s also the end of the input. All the words are in the lowercase, and each word will contain at most 10 characters, and each line will contain at most 3000 characters.  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>In this problem, you have to output the translation of the history book. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>START</p><p>from fiwo</p><p>hello difh</p><p>mars riwosf</p><p>earth fnnvk</p><p>like fiiwj</p><p>END</p><p>START</p><p>difh, i’m fiwo riwosf.</p><p>i fiiwj fnnvk!</p><p>END</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>hello, i’m from mars.</p><p>i like earth!</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>map\<string, string="">存字典，map\<string, bool="">标记是否字典里能查到</string,></string,></p><p>输出时，遍历截取（substr）每个单词（以小写字母为标准）</p></blockquote><h3 id="关于string的substr"><a href="#关于string的substr" class="headerlink" title="关于string的substr"></a>关于string的substr</h3><blockquote><p>假设：string s = “0123456789”;</p><p><strong>string sub1 = s.substr(5); //只有一个数字5表示从下标为5开始一直到结尾：sub1 = “56789”</strong></p><p><strong>string sub2 = s.substr(5, 3); //从下标为5开始截取长度为3位：sub2 = “567”</strong> </p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;map&lt;string, string&gt; mp;map&lt;string, bool&gt; vis;int main(){    string s1, s2;    cin &gt;&gt; s1;///必定是START    while(1)    {        cin &gt;&gt; s1;        if(s1 == &quot;END&quot;)            break;        cin &gt;&gt; s2;        mp[s2] = s1;        vis[s2] = 1;//        cout &lt;&lt; &quot;s1: &quot; &lt;&lt; s1 &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;s2: &quot; &lt;&lt; s2 &lt;&lt; &#39;\n&#39;;    }    cin &gt;&gt; s1;///必定是START    getchar();///后面紧跟有getline(能读入回车)，此处读回车避免错误    string tem;    while(1)    {        getline(cin, tem);        if(tem == &quot;END&quot;)            break;        for(int i = 0, j = 0; i &lt; tem.length(); i = j)        {            if(!(tem[i] &gt;= &#39;a&#39; &amp;&amp; tem[i] &lt;= &#39;z&#39;))            {                cout &lt;&lt; tem[i];                j++;            }            else            {                while(tem[j] &gt;= &#39;a&#39; &amp;&amp; tem[j] &lt;= &#39;z&#39;)///拓展上界                    j++;                string s = tem.substr(i, j - i);                if(vis[s])                    cout &lt;&lt; mp[s];                else                    cout &lt;&lt; s ;            }        }        cout &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のmap </tag>
            
            <tag> 数据类型のstring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超链接测试</title>
      <link href="2019/02/25/%E8%B6%85%E9%93%BE%E6%8E%A5%E6%B5%8B%E8%AF%95/"/>
      <url>2019/02/25/%E8%B6%85%E9%93%BE%E6%8E%A5%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>这是 <a href="www.baidu.com">百度</a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=437755157&auto=1&height=66"></iframe><p><a href="www.baidu.com">baidu</a></p><pre><code class="lang-c++">        **&lt;a href=&quot;https://fireworks99.github.io/2019/04/10/Gitment-%E8%AF%84%E8%AE%BA/&quot; style=&quot;color:violet;&quot;&gt;如何参与Gitment评论&lt;/a&gt;**</code></pre><pre><code class="lang-css">**&lt;a href=&quot;网址&quot; style=&quot;color:violet;&quot;&gt;题目链接&lt;/a&gt;**</code></pre><p><a href="https://www.csdn.net/" title="CSDN" target="_blank" rel="noopener">csdn</a></p><p><a href="https://fireworks99.github.io/" target="_blank" rel="noopener">https://fireworks99.github.io/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1969 Pie</title>
      <link href="2019/02/25/HDU-1969-Pie/"/>
      <url>2019/02/25/HDU-1969-Pie/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>My birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces ……</p></blockquote><a id="more"></a><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1969" target="_blank" rel="noopener">题目链接</a></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>One line with a positive integer: the number of test cases. Then for each test case: —-One line with two integers N and F with 1 &lt;= N, F &lt;= 10 000: the number of pies and the number of friends.  —-One line with N integers ri with 1 &lt;= ri &lt;= 10 000: the radii of the pies.  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10^(-3). </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code>33 34 3 31 24510 51 4 2 3 4 5 6 5 4 2</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>25.1327</p><p>3.1416</p><p>50.2655</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>n块同高（为1）不同半径的“派”平均分给f + 1个人，每个人分到的蛋糕必须来自同一块</p></blockquote><h3 id="思路：二分"><a href="#思路：二分" class="headerlink" title="思路：二分"></a>思路：二分</h3><blockquote><p>二分三大要素：上限、下限（多数为0）、bool judge（）函数</p><p>上限：每块派都近乎完美，那样答案是所有的体积的和 / 人数</p><p>下限：0</p><p>judge（mid）函数：遍历每块派，他们的体积 / mid 取整的和 &gt;= 人数即满足条件</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const double pi = acos(-1.0);int n, f;double a[10005];bool judge(double x){    int tot = 0;    for(int i = 0; i &lt; n; ++i)        tot += int(a[i] / x);    if(tot &gt;= f)        return 1;    return 0;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        memset(a, 0, sizeof(a));        cin &gt;&gt; n &gt;&gt; f;        f++;        double sum = 0;        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%lf&quot;, &amp;a[i]);            a[i] *= a[i];///同高时体积可看成底面积，pi可忽略（最后算上）            sum += a[i];        }        double left = 0, right = sum / f;        while(right - left &gt; 0.000001)///double卡精度        {            double mid = (left + right) / 2;            if(judge(mid))                left = mid;            else                right = mid;        }        printf(&quot;%.4f\n&quot;, right * pi);    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1010 Tempter of the Bone</title>
      <link href="2019/02/25/HDU-1010-Tempter-of-the-Bone/"/>
      <url>2019/02/25/HDU-1010-Tempter-of-the-Bone/</url>
      
        <content type="html"><![CDATA[<h3 id="奇偶剪枝"><a href="#奇偶剪枝" class="headerlink" title="奇偶剪枝"></a>奇偶剪枝</h3><blockquote><p>若 t-[abs(ex-sx)+abs(ey-sy)] 结果为非偶数(奇数)，则无法在<strong>t步恰好</strong>到达.</p></blockquote><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>The maze was a rectangle with sizes N by M. There was a door in the maze. At the beginning, the door was closed and it would open at the T-th second for a short period of time (less than 1 second). Therefore the doggie had to arrive at the door on exactly the T-th second.  </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of multiple test cases. The first line of each test case contains three integers N, M, and T (1 &lt; N, M &lt; 7; 0 &lt; T &lt; 50), which denote the sizes of the maze and the time at which the door will open, respectively. The next N lines give the maze layout, with each line containing M characters. A character is one of the following:  </p><p> ‘X’: a block of wall, which the doggie cannot enter; </p><p> ‘S’: the start point of the doggie;  </p><p>‘D’: the Door; or </p><p> ‘.’: an empty block.   </p><p>The input is terminated with three 0’s. This test case is not to be processed.  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case, print in one line “YES” if the doggie can survive, or “NO” otherwise.  </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><pre><code class="lang-c++">4 4 5S.X...X...XD....3 4 5S.X...X....D0 0 0</code></pre></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>NO</p><p>YES</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>恰好到达，不能用bfs，用dfs。另外dfs搜索量大要剪枝，另外dfs用不到结构体</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;///BFS要以（ 结构体 ）形式存数据///DFS只要两点：当前点与终点（不需结构体）int n, m, time, now_x, now_y, ex, ey, t;bool vis[10][10];///可改图以省略（通路访问完毕改为墙）char mp[10][10];int dx[] = {0, 1, 0, -1};int dy[] = {1, 0, -1, 0};bool flag;///DFS无法中断，return返回的不知是哪一级，尽量不要在此函数里执行输出操作(易多次输出)void dfs(int x, int y, int t){    ///①检验部分    if(mp[x][y] == &#39;D&#39; &amp;&amp; t == time)    {        flag = 1;        return ;    }    ///②剪枝部分    if(t &gt;= time || flag)///超时剪枝 || 成功剪枝        return ;    if(abs(x - ex) + abs(y - ey) &gt; time )///缺时剪枝        return ;    if(abs( time - t - abs(x - ex) - abs(y - ey) )% 2)///奇偶剪枝        return ;    ///③搜索部分    for(int i = 0; i &lt; 4; ++i)    {        int xx = x + dx[i];        int yy = y + dy[i];        if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0 || vis[xx][yy] || mp[xx][yy] == &#39;X&#39; )            continue;        vis[xx][yy] = 1;        dfs(xx, yy, t + 1);        vis[xx][yy] = 0;///取消标记，另寻他路    }    return ;}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;time) &amp;&amp; (n || m || t))    {        flag = 0;        memset(vis, 0, sizeof(vis));///两个数组都要初始化        memset(mp, 0, sizeof(mp));///我起初把初始化放在了读图的后面！        ///读图        for(int i = 0; i &lt; n; ++i)        {            scanf(&quot;%s&quot;, mp[i]);///或者cin读入            for(int j = 0; j &lt; m; ++j)            {                if(mp[i][j] == &#39;S&#39;)                {                    now_x = i;                    now_y = j;                }                if(mp[i][j] == &#39;D&#39;)                {                    ex = i;                    ey = j;                }            }        }        ///对起点的“剪枝”,相当于“刨根”吧        if(abs(now_x - ex) + abs(now_y - ey) &gt; time || abs(time -abs(now_x - ex) - abs(now_y - ey) ) &amp; 1 )        {            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;            continue;        }        vis[now_x][now_y] = 1;        dfs(now_x, now_y, 0);        if(flag)            cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;        else            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;//        for(int i = 0; i &lt; n; ++i)//        {//            for(int j = 0; j &lt; m; ++j)//                cout &lt;&lt; mp[i][j];//            cout &lt;&lt; &#39;\n&#39;;//        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のDFS </tag>
            
            <tag> 题解 </tag>
            
            <tag> 简单搜索の剪枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘法逆元</title>
      <link href="2019/02/24/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/"/>
      <url>2019/02/24/%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是逆元？"><a href="#什么是逆元？" class="headerlink" title="什么是逆元？"></a>什么是逆元？</h2><blockquote><p>设x是a的倒数，那么 x * a = 1（即x = 1 / a).</p><p>设x是a的逆元，那么 x * a % p = 1.</p></blockquote><a id="more"></a><h2 id="逆元的用处"><a href="#逆元的用处" class="headerlink" title="逆元的用处"></a>逆元的用处</h2><p><strong>关于取模运算:</strong></p><blockquote><p>(a + b) % p = (a % p + b % p) % p</p><p>(a - b) % p = ( (a % p - b % p) + p) % p</p><p>(a <em> b) % p = (a % p ) </em> ( b % p )  % p</p><p>(a / b) % p = （a * （b的逆元））% p </p><p>逆元可以将除法取模转为乘法取模</p></blockquote><h2 id="如何求解一个数的逆元？"><a href="#如何求解一个数的逆元？" class="headerlink" title="如何求解一个数的逆元？"></a>如何求解一个数的逆元？</h2><h3 id="①费马小定理"><a href="#①费马小定理" class="headerlink" title="①费马小定理"></a>①费马小定理</h3><blockquote><p>给出质数 p ，有一个与 p 互质的数 a （即 gcd(a, p) == 1 )，那么有a ^ (p - 1) % p == 1恒成立</p></blockquote><p><strong>根据这一点得 a 的逆元 x = a ^ (p - 2)</strong></p><p><strong>所以求一个数的逆元，要明确它本身和一个与它  <em>互质</em>  的  <em>质数</em>  ,根据快速幂求得</strong></p><h3 id="②扩展欧几里得"><a href="#②扩展欧几里得" class="headerlink" title="②扩展欧几里得"></a>②扩展欧几里得</h3><blockquote><p>已知整数a、b，扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足等式：<img src="https://upload.wikimedia.org/math/6/8/f/68f75cdc71ebee2a9f11970a0357cda8.png" alt="ax + by = \gcd(a, b)">。 </p></blockquote><h4 id="为什么可以用扩展欧几里得求解逆元？"><a href="#为什么可以用扩展欧几里得求解逆元？" class="headerlink" title="为什么可以用扩展欧几里得求解逆元？"></a>为什么可以用扩展欧几里得求解逆元？</h4><blockquote><p>因为a <em> x % p = 1 就是a </em> x - p * y = 1.</p><p>把y写成+的形式就是ax+py=1，为方便理解下面我们把p写成b就是ax+by=1。</p><p>就表示x是a的模b乘法逆元，y是b的模a乘法逆元。然后就可以用扩展欧几里得求了。</p></blockquote><p><strong>所以求一个数 a 的模 p 逆元 ，不管p质数与否，只需明确a与p</strong></p><h5 id="Code（exgcd扩展欧几里得）"><a href="#Code（exgcd扩展欧几里得）" class="headerlink" title="Code（exgcd扩展欧几里得）"></a>Code（exgcd扩展欧几里得）</h5><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;void exgcd(ll a, ll b, ll &amp;gcd, ll &amp;x, ll &amp;y){    if(!b)    {        gcd = a;        x = 1;        y = 0;    }    else    {        exgcd(b, a % b, gcd, y, x);        y -= x * (a / b);    }}ll inv(ll a, ll p){    ll gcd, x, y;    exgcd(a, p, gcd, x, y);    return gcd == 1 ? (x + p) % p : -1;}int main(){    ll a, p;    while(cin &gt;&gt; a &gt;&gt;p)        cout &lt;&lt; inv(a, p) &lt;&lt;&#39;\n&#39;;    return 0;}</code></pre><h3 id="例题HDU-1576-A-B"><a href="#例题HDU-1576-A-B" class="headerlink" title="例题HDU 1576 A / B"></a>例题HDU 1576 A / B</h3><h4 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h4><blockquote><p>要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。 </p></blockquote><h4 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h4><blockquote><p>数据的第一行是一个T，表示有T组数据。  每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。 </p></blockquote><h4 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h4><blockquote><p>对应每组数据输出(A/B)%9973。 </p></blockquote><h4 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h4><blockquote><p>2</p><p>1000 53</p><p>87 123456789</p></blockquote><h4 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h4><blockquote><p>7922</p><p>6060</p></blockquote><h3 id="Code-费马小定理"><a href="#Code-费马小定理" class="headerlink" title="Code(费马小定理)"></a>Code(费马小定理)</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const ll mod = 9973;ll quick_pow(ll a, ll b){    ll ans = 1;    while(b)    {        if(b &amp; 1)            ans = ans * a % mod;        a = a * a % mod;        b &gt;&gt;= 1;    }    return ans % mod;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        ll n, b;        cin &gt;&gt; n &gt;&gt; b;        cout &lt;&lt; (n * quick_pow(b, mod - 2)) % mod &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre><h3 id="Code（扩展欧几里得）"><a href="#Code（扩展欧几里得）" class="headerlink" title="Code（扩展欧几里得）"></a>Code（扩展欧几里得）</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;void exgcd(ll a, ll b, ll &amp;gcd, ll &amp;x, ll &amp;y){    if(!b)    {        gcd = a;        x = 1;        y = 0;    }    else    {        exgcd(b, a % b, gcd, y, x);        y -= x * (a / b);    }}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        ll n, b, x, y, gcd;        cin &gt;&gt; n &gt;&gt; b;        exgcd(b, 9973, gcd, x, y);        x = (x + 9973) % 9973;        cout &lt;&lt; (n * x % 9973) % 9973 &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 数论の费马小定理 </tag>
            
            <tag> 数论の扩展欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1559 最大子矩阵</title>
      <link href="2019/02/24/HDU-1559/"/>
      <url>2019/02/24/HDU-1559/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>给你一个m×n的整数矩阵，在上面找一个x×y的子矩阵，使子矩阵中所有元素的和最大。 </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>输入数据的第一行为一个正整数T，表示有T组测试数据。每一组测试数据的第一行为四个正整数m,n,x,y（0&lt;m,n&lt;1000 AND 0&lt;x&lt;=m AND 0&lt;y&lt;=n），表示给定的矩形有m行n列。接下来这个矩阵，有m行，每行有n个不大于1000的正整数。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>对于每组数据，输出一个整数，表示子矩阵的最大和。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1</p><p>4 5 2 2</p><p>3 361 649 676 588</p><p>992 762 156 993 169</p><p>662 34 638 89 543</p><p>525 165 254 809 280</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>2474</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>int a[i][j]存读入的数值，int sum[i][j]计算二维前缀和（从左上角顶点到点（i, j）所形成矩阵的和)，动态规划求最值。</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int a[1005][1005];int sum[1005][1005];int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        int m, n, x, y;        cin &gt;&gt; m &gt;&gt; n &gt;&gt; x &gt;&gt; y;        ///数据存储        for(int i = 1; i &lt;= m; ++i)            for(int j = 1; j &lt;= n; ++j)            cin &gt;&gt; a[i][j];        ///二维前缀和计算        for(int i = 1; i &lt;= m; ++i)            for(int j = 1; j &lt;= n; ++j)            sum[i][j] = a[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];        ///动态规划        int ans = 0;/// 初始化为 &lt;= 0的任何数都行        for(int i = x; i &lt;= m; ++i)            for(int j = y; j &lt;= n; ++j)            ans = max(ans, sum[i][j] - sum[i - x][j] - sum[i][j - y] + sum[i - x][j - y]);        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;        memset(a, 0, sizeof(a));        memset(sum, 0, sizeof(sum));    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DPの线性DP </tag>
            
            <tag> 技巧の前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1556 Color the ball（差分）</title>
      <link href="2019/02/24/HDU-1556/"/>
      <url>2019/02/24/HDU-1556/</url>
      
        <content type="html"><![CDATA[<h3 id="用差分实现区间操作"><a href="#用差分实现区间操作" class="headerlink" title="用差分实现区间操作"></a>用差分实现区间操作</h3><h3 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h3><blockquote><p>给定一个长度为n的数列a，要求支持操作add(L,R,k)表示对a[L]~a[R]的每个数都加上k。并求修改后的序列a。 </p><p>设原数组为a[i]a[i], 设数组d[i]=a[i]−a[i−1](a[0]=0)，则 a[i]=∑ij=1d[j] </p><p>更新操作update(s, t, d)把区间A[s]…A[t]都增加d，我们引入一个数组delta[i]，表示</p><p>A[i]…A[n]的共同增量，n是数组的大小。那么update操作可以转化为：</p><p>1）令delta[s] = delta[s] + d，表示将A[s]…A[n]同时增加d，但这样A[t+1]…A[n]就多加了d</p><p>2）再令delta[t+1] = delta[t+1] - d，表示将A[t+1]…A[n]同时减d</p></blockquote><p><strong>我们考虑用差分的做法。这里 需要一个辅助数组c，c用来记录某一个位置上的总改变量。c[i]表示的是i~n这些元素都加上c[i]这个数。我们对[L,R]区间进行加值操作，在c[L]处加一个k，在c[R+1]处就减去一个k。最后求序列的每个位置变成了多少，只需要求一下c数组的前缀和，然后和原数组按位相加就好。</strong></p><a id="more"></a><h3 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h3><blockquote><p>一个n*m的矩阵，要求支持操作add(x1,y1,x2,y2,a)，表示对于以(x1,y1)为左下角，(x2,y2)为右上角的矩形区域，每个元素都加上a。要求修改后的矩阵。 </p></blockquote><p><strong>做法和一维类似。用数组c存储总改变量。在    c[x1][y1]    处加上 a ，在    c[x2 + 1][y1]    和   c[x1][y2 + 1]    处减a，在    c[x2 + 1][y2 + 1]    再加上a。最后(i,k)位置上的数值就是c数组在(i,k)位置的前缀和。 </strong></p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>N个气球排成一排，从左到右依次编号为1,2,3….N.每次给定2个整数a b(a &lt;= b),lele便为骑上他的“小飞鸽”牌电动车从气球a开始到气球b依次给每个气球涂一次颜色。但是N次以后lele已经忘记了第I个气球已经涂过几次颜色了，你能帮他算出每个气球被涂过几次颜色吗？ </p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>每个测试实例第一行为一个整数N,(N &lt;= 100000).接下来的N行，每行包括2个整数a b(1 &lt;= a &lt;= b &lt;= N)。  当N = 0，输入结束。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>每个测试实例输出一行，包括N个整数，第I个数代表第I个气球总共被涂色的次数。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3</p><p>1 1</p><p>2 2</p><p>3 3</p><p>3</p><p>1 1</p><p>1 2</p><p>1 3</p><p>0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1 1 1</p><p>3 2 1</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int a[100005];int main(){    int n;    while(cin &gt;&gt; n &amp;&amp; n)    {        int left, right;        for(int i = 0; i &lt; n; ++i)        {            cin &gt;&gt; left &gt;&gt; right;            a[left] ++;            a[right + 1] --;        }        for(int i = 1; i &lt;= n; ++i)        {            a[i] += a[i - 1];            printf(&quot;%d%c&quot;, a[i], i == n ? &#39;\n&#39; : &#39; &#39;);        }        memset(a, 0, sizeof(a));    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 题解 </tag>
            
            <tag> 技巧の前缀和 </tag>
            
            <tag> 技巧の差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吉姆拉尔森计算公式</title>
      <link href="2019/02/24/%E5%90%89%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/"/>
      <url>2019/02/24/%E5%90%89%E5%A7%86%E6%8B%89%E5%B0%94%E6%A3%AE%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="吉姆拉尔森计算公式：根据日期计算星期几（另有蔡勒公式）"><a href="#吉姆拉尔森计算公式：根据日期计算星期几（另有蔡勒公式）" class="headerlink" title="吉姆拉尔森计算公式：根据日期计算星期几（另有蔡勒公式）"></a>吉姆拉尔森计算公式：根据日期计算星期几（另有蔡勒公式）</h3><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p><code>w = (d + 1 + 2 * m + 3 * (m + 1) / 5 + y + (y &gt;&gt; 2) - y / 100 + y / 400) % 7;</code></p><h4 id="小注"><a href="#小注" class="headerlink" title="小注"></a>小注</h4><blockquote><p>d -&gt; day          m -&gt; month           y -&gt; year</p><p>w == 0 ? 7 : w ;</p></blockquote><a id="more"></a><h4 id="特别之处"><a href="#特别之处" class="headerlink" title="特别之处"></a>特别之处</h4><blockquote><p>把一月和二月看成是上一年的十三月和十四月，例:如果是2004-1-10则换算成:2003-13-10来代入公式计算。 </p></blockquote><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="lang-c++">int cal(int y, int m, int d){    if(m &lt; 3)    {        m += 12;        --y;    }    int w = (d + 1 + 2 * m + 3 * (m + 1) / 5 + y + (y &gt;&gt; 2) - y / 100 + y / 400) % 7;    return w == 0 ? 7 : w;}</code></pre><h3 id="例题HDU-6112-今夕何夕"><a href="#例题HDU-6112-今夕何夕" class="headerlink" title="例题HDU 6112 今夕何夕"></a>例题HDU 6112 今夕何夕</h3><blockquote><p>给出一个日期，求下一个<strong>同月同日同星期</strong>的一天在哪一年</p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><blockquote><p>用公式计算星期几，枚举年份</p></blockquote><h4 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h4><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int y, m, d;bool judge(int year){    if((year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0))        return 1;    else        return 0;}bool special(int now_year){    if(judge(y) &amp;&amp; !judge(now_year) &amp;&amp; (m == 2 &amp;&amp; d == 29))        return 1;    else        return 0;}int cal(int y, int m, int d){    if(m &lt; 3)    {        m += 12;        --y;    }    int w = (d + 1 + 2 * m + 3 * (m + 1) / 5 + y + (y &gt;&gt; 2) - y / 100 + y / 400) % 7;    return w == 0 ? 7 : w;}int main(){    int t;    cin &gt;&gt; t;    while(t--)    {        scanf(&quot;%d-%d-%d&quot;, &amp;y, &amp;m, &amp;d);        int mine = cal(y, m, d);        for(int i = y + 1; ; ++i)        {            int yours = cal(i, m, d);            if(special(i))                continue;            if(mine == yours)            {                cout &lt;&lt; i &lt;&lt; &#39;\n&#39;;                break;            }        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1495 非常可乐</title>
      <link href="2019/02/23/HDU-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/"/>
      <url>2019/02/23/HDU-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。 </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>如果能平分的话请输出最少要倒的次数，否则输出”NO”。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>7 4 3</p><p>4 1 3</p><p>0 0 0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>NO</p><p>3</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>六种倒水情况，a -&gt; b, a -&gt; c, b -&gt; a, b -&gt; c, c -&gt; a, c -&gt; b, BFS穷竭搜索</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int s, n, m;struct node{    int a, b, c, step;};bool vis[105][105][105];int bfs(){    node now;    now.a = s;    now.b = 0;    now.c = 0;    now.step = 0;    queue&lt;node&gt; q;    q.push(now);    vis[s][0][0] = 1;    while(q.size())    {        now = q.front();        q.pop();        if((now.a == 0 &amp;&amp; now.b == now.c) || (now.b == 0 &amp;&amp; now.a == now.c) || (now.c == 0 &amp;&amp; now.a == now.b))            return now.step;        node nex;        int tra;///要转移的水        if(now.a)///a剩有部分水        {            tra = min(now.a, n - now.b);///a -&gt; b 转移的水要么是a所剩，要么是b所缺            if(tra)///这部分 &gt; 0 才可转移            {                nex.a = now.a - tra;                nex.b = now.b + tra;                nex.c = now.c;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }            tra = min(now.a, m - now.c);///a -&gt; c            if(tra)            {                nex.a = now.a - tra;                nex.c = now.c + tra;                nex.b = now.b;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }        }        if(now.b)        {            tra = min(now.b, s - now.a);///b -&gt; a            if(tra)            {                nex.b = now.b - tra;                nex.a = now.a + tra;                nex.c = now.c;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }            tra = min(now.b, m - now.c);///b -&gt; c            if(tra)            {                nex.b = now.b - tra;                nex.c = now.c + tra;                nex.a = now.a;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }        }        if(now.c)        {            tra = min(now.c, s - now.a);///c -&gt; a            if(tra)            {                nex.c = now.c - tra;                nex.a = now.a + tra;                nex.b = now.b;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }            tra = min(now.c, n - now.b);///c -&gt; b            if(tra)            {                nex.c = now.c - tra;                nex.b = now.b + tra;                nex.a = now.a;                nex.step = now.step + 1;                if(!vis[nex.a][nex.b][nex.c])                {                    q.push(nex);                    vis[nex.a][nex.b][nex.c] = 1;                }            }        }    }    return 0;}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;s, &amp;n, &amp;m) &amp;&amp;(s || n || m))    {        if(s &amp; 1)///奇数不可能平分            cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;        else        {            memset(vis, 0, sizeof(vis));            int ans = bfs();            if(ans)                cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;            else                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ 2833 The Average</title>
      <link href="2019/02/23/POJ-2833-The-average/"/>
      <url>2019/02/23/POJ-2833-The-average/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In a speech contest, when a contestant finishes his speech, the judges will then grade his performance. The staff remove the highest grade and the lowest grade and compute the average of the rest as the contestant’s final grade. This is an easy problem because usually there are only several judges.</p></blockquote><a id="more"></a><blockquote><p>Let’s consider a generalized form of the problem above. Given <em>n</em> positive integers, remove the greatest <em>n</em>1 ones and the least <em>n</em>2 ones, and compute the average of the rest.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of several test cases. Each test case consists two lines. The first line contains three integers <em>n</em>1, <em>n</em>2 and <em>n</em> (1 ≤ <em>n</em>1, <em>n</em>2 ≤ 10, <em>n</em>1 + <em>n</em>2 &lt; <em>n</em> ≤ 5,000,000) separate by a single space. The second line contains <em>n</em> positive integers <em>ai</em> (1 ≤ <em>ai</em> ≤ 108 for all <em>i</em> s.t. 1 ≤ <em>i</em> ≤ <em>n</em>) separated by a single space. The last test case is followed by three zeroes. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each test case, output the average rounded to six digits after decimal point in a separate line. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>1 2 5</p><p>1 2 3 4 5</p><p>4 2 10</p><p>2121187 902 485 531 843 582 652 926 220 155</p><p>0 0 0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3.500000</p><p>562.500000</p></blockquote><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><blockquote><p>This problem has very large input data. <em>scanf</em> and <em>printf</em> are recommended for C++ I/O.</p><p>The memory limit might not allow you to store everything in the memory.</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给出n个数，去掉前n1个大的和前n2个小的，求平均值</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>Hint里说了暴力会MLE，那就计算所有数字的和，vector存要去掉的n1 + n2个数字，最后减掉求平均值</p></blockquote><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><blockquote><p>数据量较大时，不能强行用较高精度的类型（例如：double）去存储较低精度的类型数值（例如：int）， 在存储与计算时会TLE</p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int a, b, n;    while(~scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;n) &amp;&amp; !(a == 0 &amp;&amp; b == 0 &amp;&amp; n == 0))    {        int s = a + b;        vector&lt;float&gt; vec;        double sum = 0;        for(int i = 0; i &lt; n; ++i)        {            int tem;            scanf(&quot;%d&quot;, &amp;tem);            sum += tem;            vec.insert(lower_bound(vec.begin(), vec.end(), tem), tem);            if(vec.size() &gt; s)                vec.erase(vec.begin() + b);            }            for(int i = 0; i &lt; vec.size(); ++i)                sum -= vec[i];            double ans = sum / (n - s);            printf(&quot;%.6f\n&quot;, ans);        }        return 0;    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のvector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 1018 Big Number(求一个数的阶乘是几位数)</title>
      <link href="2019/02/23/HDU-1018-Big-Number/"/>
      <url>2019/02/23/HDU-1018-Big-Number/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>In many applications very large integers numbers are required. Some of these  applications are using keys for secure transmission of data, encryption, etc. In  this problem you are given a number, you have to determine the number of digits  in the factorial of the number.</p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>Input consists of several lines of integer numbers. The  first line contains an integer n, which is the number of cases to be tested,  followed by n lines, one integer 1 ≤ n ≤ 107 on each line. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>The output contains the number of digits in the  factorial of the integers appearing in the input. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>2</p><p>10</p><p>20</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>7</p><p>19</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>求一个数阶乘的位数  </p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>456 = 4.56 * 10 ^ 2 三位数</p><p>4567 = 4.567 * 10 ^ 3 四位数</p><p>45678 = 4.5678 * 10 ^ 4 五位数</p><p>结论：问一个数有几位，将这个数向下取到10的N次方（456 -&gt; 100, 4567 -&gt; 1000) ，N + 1就是答案</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>一个数的位数等于他对10取对数+1 </p></blockquote><h4 id="log与log10"><a href="#log与log10" class="headerlink" title="log与log10"></a>log与log10</h4><blockquote><p><strong>log:</strong> 求log e x，In x。返回计算结果。 <strong>double log(double x);</strong></p><p><strong>log10:</strong> 求log10x。返回计算结果。 <strong>double log10(double x);</strong></p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std;int main(){    int n;    while(cin &gt;&gt; n)    {        while(n--)        {            int tem;            cin &gt;&gt; tem;            double sum = 0;            for(int i = 1; i &lt;= tem; ++i)                sum += log10(double(i));            cout &lt;&lt; (int)sum + 1 &lt;&lt; &#39;\n&#39;;        }    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces B. New Skateboard(被4整除的规律)</title>
      <link href="2019/02/15/Codeforces-B-New-Skateboard/"/>
      <url>2019/02/15/Codeforces-B-New-Skateboard/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Max wants to buy a new skateboard. He has calculated the amount of money that is needed to buy a new skateboard. He left a calculator on the floor and went to ask some money from his parents. Meanwhile his little brother Yusuf came and started to press the keys randomly. Unfortunately Max has forgotten the number which he had calculated. The only thing he knows is that the number is divisible by 4.</p></blockquote><a id="more"></a><blockquote><p>You are given a string <em>s</em> consisting of digits (the number on the display of the calculator after Yusuf randomly pressed the keys). Your task is to find the number of substrings which are divisible by 4. A substring can start with a zero.</p><p>A substring of a string is a nonempty sequence of consecutive characters.</p><p>For example if string <em>s</em> is 124 then we have four substrings that are divisible by 4: 12, 4, 24 and 124. For the string 04 the answer is three: 0, 4, 04.</p><p>As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use gets/scanf/printf instead of getline/cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The only line contains string <em>s</em> (1 ≤ |<em>s</em>| ≤ 3·105). The string <em>s</em> contains only digits from 0 to 9. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>Print integer <em>a</em> — the number of substrings of the string <em>s</em> that are divisible by 4.</p><p>Note that the answer can be huge, so you should use 64-bit integer type to store it. In C++ you can use the long long integer type and in Java you can use long integer type.</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><blockquote><p>124</p></blockquote><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><blockquote><p>4</p></blockquote><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><blockquote><p>04</p></blockquote><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><blockquote><p>3</p></blockquote><h4 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h4><blockquote><p>5810438174</p></blockquote><h4 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h4><blockquote><p>9</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给出一个字符串 ,问有多少个可以被4整除的子串 </p></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>若一个整数的末尾两位数能被4整除，则这个数能被4整除。</strong></p><p>（<strong>若一个整数的末尾三位数能被8整除，则这个数能被8整除。 </strong>）</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){    string s;    while(cin &gt;&gt; s)    {        long long ans = 0;        for(int i = 0; i &lt; s.length(); ++i)        {            if((s[i] - &#39;0&#39;) % 4 == 0)                ans ++;            if((i != s.length() - 1) &amp;&amp; ((((s[i]- &#39;0&#39;) * 10) + s[i + 1]) % 4 == 0))                ans += i + 1;        }        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论の杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POJ Fence Repair</title>
      <link href="2019/02/14/POJ-Fence-Repair/"/>
      <url>2019/02/14/POJ-Fence-Repair/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Farmer John wants to repair a small length of the fence around the pasture. He measures the fence and finds that he needs <em>N</em> (1 ≤ <em>N</em> ≤ 20,000) planks of wood, each having some integer length <em>Li</em> (1 ≤ <em>Li</em> ≤ 50,000) units. He then purchases a single long board just long enough to saw into the <em>N</em> planks (i.e., whose length is the sum of the lengths <em>Li</em>). FJ is ignoring the “kerf”, the extra length lost to sawdust when a sawcut is made; you should ignore it, too.</p></blockquote><a id="more"></a><blockquote><p>FJ sadly realizes that he doesn’t own a saw with which to cut the wood, so he mosies over to Farmer Don’s Farm with this long board and politely asks if he may borrow a saw.</p><p>Farmer Don, a closet capitalist, doesn’t lend FJ a saw but instead offers to charge Farmer John for each of the <em>N</em>-1 cuts in the plank. The charge to cut a piece of wood is exactly equal to its length. Cutting a plank of length 21 costs 21 cents.</p><p>Farmer Don then lets Farmer John decide the order and locations to cut the plank. Help Farmer John determine the minimum amount of money he can spend to create the <em>N</em> planks. FJ knows that he can cut the board in various different orders which will result in different charges since the resulting intermediate planks are of different lengths.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>Line 1: One integer <em>N</em>, the number of planks  </p><p>Lines 2..<em>N</em>+1: Each line contains a single integer describing the length of a needed plank </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>Line 1: One integer: the minimum amount of money he must spend to make <em>N</em>-1 cuts </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3</p><p>8 5 8</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>34</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><blockquote><p>一块木板切成N块，每次开销是当前木板长度，给出最终每块木板长度，求最小开销</p></blockquote><p>详见《挑战程序设计》（第二版）48页</p><p>自己举几个简单的例子发现：将 <em>最短板</em>  与 <em>次短板</em>  视为来自同一块板，合成新板重复此过程便得到答案</p><h3 id="关键处"><a href="#关键处" class="headerlink" title="关键处"></a>关键处</h3><blockquote><p>为了找最短板与次短板，避免多次sort，采用vector的lower_bound式insert</p></blockquote><p><code>vec.insert(lower_bound(vec.begin(), vec.end(), tem), tem);</code></p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main(){    vector&lt;int&gt; vec;    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 0; i &lt; n; ++i)    {        int tem;        scanf(&quot;%d&quot;, &amp;tem);        vec.insert(lower_bound(vec.begin(), vec.end(), tem), tem);///vector据大小插入    }    long long ans = 0;/// &gt;= 2个int可能超int    while(vec.size() &gt; 1)    {        int t = vec[0] + vec[1];        ans += t;        vec.erase(vec.begin());        vec.erase(vec.begin());        vec.insert(lower_bound(vec.begin(), vec.end(), t), t);    }    cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 基本算法の贪心 </tag>
            
            <tag> 数据结构のvector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDU 2141 Can you find it?</title>
      <link href="2019/01/29/HDU-2141-Can-you-find-it/"/>
      <url>2019/01/29/HDU-2141-Can-you-find-it/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Give you three sequences of numbers A, B, C, then we  give you a number X. Now you need to calculate if you can find the three numbers  Ai, Bj, Ck, which satisfy the formula Ai+Bj+Ck = X. </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>There are many cases. Every data case is described as  followed: In the first line there are three integers L, N, M, in the second line  there are L integers represent the sequence A, in the third line there are N  integers represent the sequences B, in the forth line there are M integers  represent the sequence C. In the fifth line there is an integer S represents  there are S integers X to be calculated. 1&lt;=L, N, M&lt;=500,  1&lt;=S&lt;=1000. all the integers are 32-integers. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>For each case, firstly you have to print the case  number as the form “Case d:”, then for the S queries, you calculate if the  formula can be satisfied or not. If satisfied, you print “YES”, otherwise print  “NO”. </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 3 3</p><p>1 2 3 </p><p>1 2 3</p><p>1 2 3</p><p>3</p><p>1</p><p>4</p><p>10</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Case 1:</p><p>NO</p><p>YES</p><p>NO</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>给出三个数组，每个数组选一个数相加，让其等于下面给出的和</p></blockquote><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote><p>将a + b + c = s 视为 s - a = b + c</p><p>将b + c形成一个新数组k，并sort（排序，二分查找的前提）</p><p>一个for循环(s - a)</p><p>暴力超时</p></blockquote><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int L, N, M;int l[505];int n[505];int m[505];int k[250005];bool diy_search(int x){    int l = 0, r = M * N;    while(r - l &gt;= 1)    {        int i = (l + r) / 2;        if(k[i] == x)            return 1;        else if(k[i] &lt; x)            l = i + 1;        else            r = i;    }    return 0;}int main(){    int tot = 1;    while(~scanf(&quot;%d%d%d&quot;, &amp;L, &amp;N, &amp;M))    {        printf(&quot;Case %d:\n&quot;, tot);        tot++;        for(int i = 0; i &lt; L; ++i)            scanf(&quot;%d&quot;, &amp;l[i]);        for(int i = 0; i &lt; N; ++i)            scanf(&quot;%d&quot;, &amp;n[i]);        for(int i = 0; i &lt; M; ++i)            scanf(&quot;%d&quot;, &amp;m[i]);        for(int i = 0; i &lt; N; ++i)            for(int j = 0; j &lt; M; ++j)                k[i * N + j] = n[i] + m[j];        sort(k, k + N * M);        int s;        scanf(&quot;%d&quot;, &amp;s);        for(int i = 0; i &lt; s; ++i)        {            int tem;            scanf(&quot;%d&quot;, &amp;tem);            bool flag = 0;            for(int j = 0; j &lt; L; ++j)                if(diy_search(tem - l[j]))                {                    flag = 1;                    cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;                    goto over;///goto跳出多重循环                }            if(!flag)                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;over:            ;        }    }    return 0;}</code></pre><h3 id="用-upper-bound-lower-bound-gt-0-代替自己写的二分查找函数"><a href="#用-upper-bound-lower-bound-gt-0-代替自己写的二分查找函数" class="headerlink" title="用(upper_bound - lower_bound &gt; 0)代替自己写的二分查找函数"></a>用(upper_bound - lower_bound &gt; 0)代替自己写的二分查找函数</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int L, N, M;int l[505];int n[505];int m[505];int k[250005];int main(){    int tot = 1;    while(~scanf(&quot;%d%d%d&quot;, &amp;L, &amp;N, &amp;M))    {        printf(&quot;Case %d:\n&quot;, tot);        tot++;        for(int i = 0; i &lt; L; ++i)            scanf(&quot;%d&quot;, &amp;l[i]);        for(int i = 0; i &lt; N; ++i)            scanf(&quot;%d&quot;, &amp;n[i]);        for(int i = 0; i &lt; M; ++i)            scanf(&quot;%d&quot;, &amp;m[i]);        for(int i = 0; i &lt; N; ++i)            for(int j = 0; j &lt; M; ++j)                k[i * N + j] = n[i] + m[j];        sort(k, k + N * M);        int s;        scanf(&quot;%d&quot;, &amp;s);        for(int i = 0; i &lt; s; ++i)        {            int tem;            scanf(&quot;%d&quot;, &amp;tem);            bool flag = 0;            for(int j = 0; j &lt; L; ++j)                if(upper_bound(k, k + N * M, tem - l[j]) - lower_bound(k, k + N * M, tem - l[j]))                {                    flag = 1;                    cout &lt;&lt; &quot;YES&quot; &lt;&lt; &#39;\n&#39;;                    goto over;                }            if(!flag)                cout &lt;&lt; &quot;NO&quot; &lt;&lt; &#39;\n&#39;;over:            ;        }    }    return 0;}</code></pre><h4 id="关于goto"><a href="#关于goto" class="headerlink" title="关于goto"></a>关于goto</h4><blockquote><p>goto 语句可以无条件地转移到过程中指定的行。</p><p>goto 语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p></blockquote><h4 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h4><blockquote><p>在结构化程序设计中一般不主张使用 goto 语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。 </p></blockquote><p><a href="https://blog.csdn.net/hzwy23/article/details/82747706" target="_blank" rel="noopener">goto的使用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 优化の二分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C. Replace To Make Regular Bracket Sequence</title>
      <link href="2019/01/29/C-Replace-To-Make-Regular-Bracket-Sequence/"/>
      <url>2019/01/29/C-Replace-To-Make-Regular-Bracket-Sequence/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>You are given string <em>s</em> consists of opening and closing brackets of four kinds &lt;&gt;, {}, [], (). There are two types of brackets: opening and closing. You can replace any bracket by another of the same type. For example, you can replace &lt; by the bracket {, but you can’t replace it by ) or &gt;.</p></blockquote><a id="more"></a><blockquote><p>The following definition of a regular bracket sequence is well-known, so you can be familiar with it.</p><p>Let’s define a regular bracket sequence (RBS). Empty string is RBS. Let <em>s</em>1 and <em>s</em>2 be a RBS then the strings &lt;<em>s</em>1&gt;<em>s</em>2, {<em>s</em>1}<em>s</em>2, [<em>s</em>1]<em>s</em>2, (<em>s</em>1)<em>s</em>2 are also RBS.</p><p>For example the string “[[(){}]&lt;&gt;]” is RBS, but the strings “[)()” and “][()()” are not.</p><p>Determine the least number of replaces to make the string <em>s</em> RBS.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The only line contains a non empty string <em>s</em>, consisting of only opening and closing brackets of four kinds. The length of <em>s</em> does not exceed 106. </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>If it’s impossible to get RBS from <em>s</em> print Impossible.</p><p>Otherwise print the least number of replaces needed to get RBS from <em>s</em>.</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="Input-1"><a href="#Input-1" class="headerlink" title="Input"></a>Input</h4><blockquote><p>[&lt;}){}</p></blockquote><h4 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h4><blockquote><p>2</p></blockquote><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><blockquote><p>{()}[]</p></blockquote><h4 id="Output-2"><a href="#Output-2" class="headerlink" title="Output"></a>Output</h4><blockquote><p>0</p></blockquote><h4 id="Input-2"><a href="#Input-2" class="headerlink" title="Input"></a>Input</h4><blockquote><p>]]</p></blockquote><h4 id="Output-3"><a href="#Output-3" class="headerlink" title="Output"></a>Output</h4><blockquote><p>Imposssible</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>四种括号，离左括号（右括号）最近的右括号（左括号）恰是配对的就算完美了，若不是求最少改动几次，不能就输出Impossible</p></blockquote><pre><code class="lang-c++">#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;bool check_left(char ch){    if(ch == &#39;[&#39; || ch == &#39;&lt;&#39; || ch == &#39;{&#39; || ch == &#39;(&#39;)        return 1;    else        return 0;}bool couple(int a, int b)///char类型是特殊的int类型{    if(a == &#39;[&#39; &amp;&amp; b == &#39;]&#39;)        return 1;    if(a == &#39;{&#39; &amp;&amp; b == &#39;}&#39;)        return 1;    if(a == &#39;(&#39; &amp;&amp; b == &#39;)&#39;)        return 1;    if(a == &#39;&lt;&#39; &amp;&amp; b == &#39;&gt;&#39;)        return 1;    return 0;}int main(){    string s;    cin &gt;&gt; s;    int ans = 0;    stack&lt;char&gt; st;    for(int i = 0; i &lt; s.length(); ++i)    {        if(check_left(s[i]))///如果是左括号，放入栈            st.push(s[i]);        else///如果是右括号        {            if(st.empty())///栈里没有左括号            {                cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; &#39;\n&#39;;                return 0;            }            else            {                ///利用了栈的先进后出                char last = st.top();///离此右括号最近的左括号                st.pop();                if(couple(last, s[i]))///匹配继续检测                    continue;                else                    ans++;///不匹配就改动一次            }        }    }    if(!st.empty())///若还有左括号没匹配完    {        cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; &#39;\n&#39;;        return 0;    }    else        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构の栈(stack) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces C.Pearls in a Row</title>
      <link href="2019/01/29/Pearls%20in%20a%20Row/"/>
      <url>2019/01/29/Pearls%20in%20a%20Row/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>There are <em>n</em> pearls in a row. Let’s enumerate them with integers from 1 to <em>n</em> from the left to the right. The pearl number <em>i</em> has the type <em>ai</em>.</p></blockquote><a id="more"></a><blockquote><p>Let’s call a sequence of consecutive pearls a segment. Let’s call a segment good if it contains two pearls of the same type.</p><p>Split the row of the pearls to the maximal number of good segments. Note that each pearl should appear in exactly one segment of the partition.</p><p>As input/output can reach huge size it is recommended to use fast input/output methods: for example, prefer to use scanf/printfinstead of cin/cout in C++, prefer to use BufferedReader/PrintWriter instead of Scanner/System.out in Java.</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The first line contains integer <em>n</em> (1 ≤ <em>n</em> ≤ 3·105) — the number of pearls in a row.</p><p>The second line contains <em>n</em> integers <em>a**i</em> (1 ≤ <em>a**i</em> ≤ 109) – the type of the <em>i</em>-th pearl.</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>On the first line print integer <em>k</em> — the maximal number of segments in a partition of the row.</p><p>Each of the next <em>k</em> lines should contain two integers <em>l**j</em>, <em>r**j</em> (1 ≤ <em>l**j</em> ≤ <em>r**j</em> ≤ <em>n</em>) — the number of the leftmost and the rightmost pearls in the <em>j</em>-th segment.</p><p>Note you should print the correct partition of the row of the pearls, so each pearl should be in exactly one segment and all segments should contain two pearls of the same type.</p><p>If there are several optimal solutions print any of them. You can print the segments in any order.</p><p>If there are no correct partitions of the row print the number “-1”.</p></blockquote><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><blockquote><p>5</p><p>1 2 3 4 1</p></blockquote><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><blockquote><p>1</p><p>1 5</p></blockquote><h4 id="input-1"><a href="#input-1" class="headerlink" title="input"></a>input</h4><blockquote><p>5</p><p>1 2 3 4 5</p></blockquote><h4 id="output-1"><a href="#output-1" class="headerlink" title="output"></a>output</h4><blockquote><p>-1</p></blockquote><h4 id="input-2"><a href="#input-2" class="headerlink" title="input"></a>input</h4><blockquote><p>7</p><p>1 2 1 3 1 2 1</p></blockquote><h4 id="output-2"><a href="#output-2" class="headerlink" title="output"></a>output</h4><blockquote><p>2</p><p>1 3</p><p>4 7</p></blockquote><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><blockquote><p>要把一个数字序列分成几个序列（每个序列均含有相同元素），尽可能多地分（也就是让每个序列只含有一组相同元素）。找不到输出 -1 ，否则输出序列个数与起止点</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><blockquote><p>可以利用 <em>set</em> 自带除重的特点，将序列中的数字向set里放，每放一次检测一次大小，大了很正常，没变大说明出现了同样的元素，这就有了一个序列</p></blockquote><h3 id="坑点（末尾处理）"><a href="#坑点（末尾处理）" class="headerlink" title="坑点（末尾处理）"></a>坑点（末尾处理）</h3><blockquote><p>如果原序列是 </p><p>7</p><p>1 2 1 3 4 3 6</p><p>那么第一个符合要求的序列是 1 2 1，第二个是3 4 3 6，而不是3 4 3</p></blockquote><pre><code class="lang-c++">#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct node{    int left, right;}ans[1000005];int main(){    int n;    while(~scanf(&quot;%d&quot;, &amp;n))    {        bool flag = 0;        set&lt;int&gt; st;        int tem = st.size();        int tot = 0;        ans[tot].left = 1;        for(int i = 1; i &lt;= n; ++i)        {            int a;            scanf(&quot;%d&quot;, &amp;a);            st.insert(a);            if(st.size() &gt; tem)                tem = st.size();            else            {                flag = 1;                st.clear();                ans[tot].right = i;                tot++;                ans[tot].left = i + 1;                tem = st.size();            }        }        if(!flag)            cout &lt;&lt; &quot;-1&quot; &lt;&lt; &#39;\n&#39;;        else        {            cout &lt;&lt; tot &lt;&lt; &#39;\n&#39;;            for(int i = 0; i &lt; tot - 1; ++i)                cout &lt;&lt; ans[i].left &lt;&lt; &#39; &#39; &lt;&lt; ans[i].right &lt;&lt; &#39;\n&#39;;            if(ans[tot - 1].right != n)                cout &lt;&lt; ans[tot - 1].left &lt;&lt; &#39; &#39; &lt;&lt; n &lt;&lt; &#39;\n&#39;;        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟 The kth great number HDU4006</title>
      <link href="2019/01/24/%E6%A8%A1%E6%8B%9F%EF%BC%88vector%EF%BC%89The-kth-great-number-HDU4006/"/>
      <url>2019/01/24/%E6%A8%A1%E6%8B%9F%EF%BC%88vector%EF%BC%89The-kth-great-number-HDU4006/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>Xiao Ming and Xiao Bao are playing a simple Numbers game. In a round Xiao Ming can choose to write down a number, or ask Xiao Bao what the kth great number is. Because the number written by Xiao Ming is too much, Xiao Bao is feeling giddy. Now, try to help Xiao Bao. </p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>There are several test cases. For each test case, the first line of input contains two positive integer n, k. Then n lines follow. If Xiao Ming choose to write down a number, there will be an “ I” followed by a number that Xiao Ming will write down. If Xiao Ming choose to ask Xiao Bao, there will be a “Q”, then you need to output the kth great number.  </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>The output consists of one integer representing the largest number of islands that all lie on one line.  </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>8 3</p><p>I  1</p><p>I  2</p><p>I  3</p><p>Q</p><p>I  5</p><p>Q</p><p>I  4</p><p>Q</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>1</p><p>2</p><p>3</p></blockquote><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><blockquote><p>Xiao  Ming  won’t  ask  Xiao  Bao  the  kth  great  number  when  the  number  of  the  written number is smaller than k. (1=&lt;k&lt;=n&lt;=1000000).</p></blockquote><p>如果每次Q就sort排序一次会TLE，那么就先用vector存下一个数，每次存数时按大小插入</p><h2 id="vector-的-insert"><a href="#vector-的-insert" class="headerlink" title="vector 的 insert"></a>vector 的 insert</h2><blockquote><p>v.insert(v.begin()+2,1);//在迭代器中第二个元素<strong>前</strong>插入新元素   </p></blockquote><h2 id="lower-bound-与-upperbound"><a href="#lower-bound-与-upperbound" class="headerlink" title="lower_bound 与 upperbound"></a>lower_bound 与 upperbound</h2><blockquote><p>ForwardIter  lower_bound(ForwardIter first, ForwardIter last,const _Tp&amp; val)算法返回一个非递减序列[first, last)中的第一个大于等于值val的位置。</p><p>ForwardIter  upper_bound(ForwardIter first, ForwardIter last, const _Tp&amp; val)算法返回一个非递减序列[first, last)中第一个大于val的位置。</p></blockquote><h3 id="vector版"><a href="#vector版" class="headerlink" title="vector版"></a>vector版</h3><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n, k;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))    {        getchar();        vector&lt;int&gt; vec;        for(int i = 0; i &lt; n; ++i)        {            char c;            scanf(&quot;%c&quot;, &amp;c);            switch(c)            {            case &#39;I&#39;:                int tem;                scanf(&quot;%d&quot;, &amp;tem);                vec.insert(lower_bound(vec.begin(), vec.end(), tem), tem);                getchar();                break;            case &#39;Q&#39;:                getchar();                cout &lt;&lt; *(vec.end() - k) &lt;&lt; &#39;\n&#39;;            }        }    }    return 0;}</code></pre><h3 id="multiset版"><a href="#multiset版" class="headerlink" title="multiset版"></a>multiset版</h3><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;int main(){    int n, k;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))    {        getchar();        multiset&lt;int&gt; m;        for(int i = 0; i &lt; n; ++i)        {            char ch;            scanf(&quot;%c&quot;, &amp;ch);            switch(ch)            {            case &#39;I&#39;:                int tem;                scanf(&quot;%d&quot;, &amp;tem);                m.insert(tem);                getchar();                if(m.size() &gt; k)                    m.erase(m.begin());                break;            case &#39;Q&#39;:                getchar();                cout &lt;&lt; *m.begin() &lt;&lt; &#39;\n&#39;;            }        }    }    return 0;}</code></pre><h3 id="priority-queue版"><a href="#priority-queue版" class="headerlink" title="priority_queue版"></a>priority_queue版</h3><pre><code class="lang-c++">#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int main(){    int n, k;    while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;k))    {        getchar();        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;        for(int i = 0; i &lt; n; ++i)        {            char c;            scanf(&quot;%c&quot;, &amp;c);            switch(c)            {            case &#39;I&#39;:                int tem;                scanf(&quot;%d&quot;, &amp;tem);                q.push(tem);                getchar();                if(q.size() &gt; k)                    q.pop();                break;            case &#39;Q&#39;:                getchar();                cout &lt;&lt; q.top() &lt;&lt; &#39;\n&#39;;            }        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のvector </tag>
            
            <tag> 数据结构のpriority_queue </tag>
            
            <tag> 数据结构のmultiset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stable_sort稳定排序</title>
      <link href="2019/01/17/stable-sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F/"/>
      <url>2019/01/17/stable-sort%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="stable-sort稳定的排序"><a href="#stable-sort稳定的排序" class="headerlink" title="stable_sort稳定的排序"></a>stable_sort稳定的排序</h2><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29544002&auto=1&height=66"></iframe><p><strong>sort</strong> 与 <strong>stable_sort</strong> 区别：</p><blockquote><p>stable_sort(另外还有stable_partition)可保证相等元素的原本相对次序在排序后保持不变。或许你会问，既然相等，你还管他相对位置呢，也分不清楚谁是谁了？这里需要弄清楚一个问题，这里的相等，是指你提供的函数表示两个元素相等，并不一定是一模一样的元素。</p></blockquote><pre><code>#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(string a, string b){    return a.length() &lt; b.length();}int main(){    string s[5];    s[0] = &quot;fireworks&quot;;    s[1] = &quot;algorithm&quot;;    s[2] = &quot;iostreamm&quot;;    s[3] = &quot;stringcpy&quot;;    s[4] = &quot;111111111&quot;;    stable_sort(s, s + 5, cmp);    for(int i = 0; i &lt; 5; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39;\n&#39;;///结果///fireworks///algorithm///iostreamm///stringcpy///111111111    cout &lt;&lt; &#39;\n&#39;;    sort(s, s + 5);    for(int i = 0; i &lt; 5; ++i)        cout &lt;&lt; s[i] &lt;&lt; &#39;\n&#39;;///结果///111111111///algorithm///fireworks///iostreamm///stringcpy    return 0;}</code></pre><p><em>五个string在长度（length）方面相等，在stable_sort后相对位置没变，在sort后位置变了，就酱……</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟、思维 SDNUOJ 1271</title>
      <link href="2019/01/17/%E6%A8%A1%E6%8B%9F%E3%80%81%E6%80%9D%E7%BB%B4-SDNUOJ-1271/"/>
      <url>2019/01/17/%E6%A8%A1%E6%8B%9F%E3%80%81%E6%80%9D%E7%BB%B4-SDNUOJ-1271/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>大家都知道小宇是一个很纯洁的小孩！有一天他做梦了，梦见好多MM排着队随他挑。这些MM来自不同的国家，但也有同一个国家的，而他想尽量认识不同国家的MM。因此小宇想知道他可以认识到不同国家的MM区间长度的最大值，并且小宇想知道共有多少个国家的MM供他选择。</p><p>题目来了：</p></blockquote><a id="more"></a><blockquote><p>现在有多个MM，给出她们所在的国家的标号（标号仅由1个小写字母组成，不同的字母表示不同的国家）。她们按顺序从左到右站成一排。小宇想找到一个区域，使他能够找到最多不同国家的MM，要求输出所有MM属于多少个不同的国家和可以认识不同国家MM的最大区间长度（该区间内没有来自同一个国家的MM）。比如在整个队伍内他按从左向右顺序找到了3个a国的MM，1个b国MM，1个c国MM。那么不同国家的最大数为3（a国、b国、c国），最大可以认识不同国家MM的区间长度为3（只须认识a国的最右面的一个人以及b、c国即可得到最大区间长度3）。假设在队伍内的人他都还没有认识。</p></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>输入一行为一串由小写字母组成的MM队列，表示MM来自的不同国家。 </p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>输出数据为一行，包含两个整数，第一个整数所有供小宇选择的MM来自多少个国家。第二个整数代表小宇能找到不同国家MM的最大区间长度。 </p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>aaabc</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>3 3</p></blockquote><p><strong>set</strong> 自带 <em>除重</em>  与 <em>排序</em>  ，这里利用除重特点。（PS: <strong>vector</strong> 有上限，<del>嗯，有上限</del> )</p><pre><code class="lang-c++">#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int main(){    char a;    set&lt;char&gt; st;    vector&lt;char&gt; vec;    while(~scanf(&quot;%c&quot;, &amp;a))    {        if(a == &#39;\n&#39;)            break;        st.insert(a);        vec.push_back(a);    }    cout &lt;&lt; st.size() &lt;&lt; &#39; &#39;;    st.clear();    int tem = st.size();    int mmax = 0;    for(int i = 0; i &lt; vec.size(); ++i)    {        st.insert(vec[i]);        if(st.size() &gt; tem)            tem = st.size();        else        {            if(st.size() &gt; mmax)                mmax = st.size();            st.clear();            st.insert(vec[i]);            tem = st.size();///我写这里时初次写了int tem!        }        if(i == vec.size() - 1)            if(st.size() &gt; mmax)                mmax = st.size();    }    cout &lt;&lt; mmax &lt;&lt; &#39;\n&#39;;    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数据结构のvector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>照片测试</title>
      <link href="2019/01/16/%E7%85%A7%E7%89%87%E6%B5%8B%E8%AF%95/"/>
      <url>2019/01/16/%E7%85%A7%E7%89%87%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>博客照片上传测试</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=445153490&auto=1&height=66"></iframe><p><img src="https://i.loli.net/2019/01/16/5c3ebad9a68ae.jpg" alt="支付宝"></p><p><img src="https://i.loli.net/2019/01/16/5c3eeef493d23.jpg" alt="微信"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFS（三维）Dungeon Master POJ2251</title>
      <link href="2019/01/15/BFS%EF%BC%88%E4%B8%89%E7%BB%B4%EF%BC%89Dungeon%20Master%20POJ2251/"/>
      <url>2019/01/15/BFS%EF%BC%88%E4%B8%89%E7%BB%B4%EF%BC%89Dungeon%20Master%20POJ2251/</url>
      
        <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote><p>You are trapped in a 3D dungeon and need to find the quickest way out! The dungeon is composed of unit cubes which may or may not be filled with rock. It takes one minute to move one unit north, south, east, west, up or down. You cannot move diagonally and the maze is surrounded by solid rock on all sides.</p><p>Is an escape possible? If yes, how long will it take?</p></blockquote><a id="more"></a><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><blockquote><p>The input consists of a number of dungeons. Each dungeon description starts with a line containing three integers L, R and C (all limited to 30 in size).</p><p>L is the number of levels making up the dungeon.</p><p>R and C are the number of rows and columns making up the plan of each level.</p><p>Then there will follow L blocks of R lines each containing C characters. Each character describes one cell of the dungeon. A cell full of rock is indicated by a ‘#’ and empty cells are represented by a ‘.’. Your starting position is indicated by ‘S’ and the exit by the letter ‘E’. There’s a single blank line after each level. Input is terminated by three zeroes for L, R and C.</p></blockquote><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><blockquote><p>Each maze generates one line of output. If it is possible to reach the exit, print a line of the form</p><p>Escaped in x minute(s).</p><p>where x is replaced by the shortest time it takes to escape.</p><p>If it is not possible to escape, print the line</p><p>Trapped!</p></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote><p>3 4 5</p><p>S….</p><p>.###.</p><p>.##..</p><p>###.#</p><p>#####</p><p>#####</p><p>##.##</p><p>##...</p><p>#####</p><p>#####</p><p>#.###</p><p>####E</p><p>1 3 3</p><p>S##</p><p>#E#</p><p>###</p><p>0 0 0</p></blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote><p>Escaped in 11 mintue(s).</p><p>Trapped!</p></blockquote><p><u>相对于二维的BFS，仅仅是多了一维而已</u></p><p><u>另外多组输入记得数组用完初始化</u></p><p><u>做好访问标记vis数组，防超时</u></p><pre><code class="lang-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 40;int L, R, C;char m[maxn][maxn][maxn];bool vis[maxn][maxn][maxn];int dx[] = {1, -1, 0, 0, 0, 0};int dy[] = {0, 0, 1, -1, 0, 0};int dz[] = {0, 0, 0, 0, 1, -1};struct node{    int x, y, z;    int step;}start, over;void bfs(node a, node b){    queue&lt;node&gt; q;    q.push(a);    while(!q.empty())    {        a = q.front();        q.pop();        if(a.x == b.x &amp;&amp; a.y == b.y &amp;&amp; a.z == b.z)        {            cout &lt;&lt; &quot;Escaped in &quot; &lt;&lt; a.step &lt;&lt; &quot; minute(s).&quot; &lt;&lt; &#39;\n&#39;;            return ;        }        for(int i = 0; i &lt; 6; ++i)        {            int xx = a.x + dx[i];            int yy = a.y + dy[i];            int zz = a.z + dz[i];            if(xx &gt; L || xx &lt;= 0 || yy &gt; R || yy &lt;= 0 || zz &gt; C || zz &lt;= 0 )                continue;            if(m[xx][yy][zz] == &#39;#&#39; || vis[xx][yy][zz] == 1)                continue;            vis[xx][yy][zz] = 1;///漏了这句超时            node tem;            tem.x = xx;            tem.y = yy;            tem.z = zz;            tem.step = a.step + 1;            q.push(tem);        }    }    cout &lt;&lt; &quot;Trapped!&quot; &lt;&lt; &#39;\n&#39;;}int main(){    while(~scanf(&quot;%d%d%d&quot;, &amp;L, &amp;R, &amp;C) &amp;&amp; !(L == 0 &amp;&amp; R == 0 &amp;&amp; C == 0) )    {        getchar();        for(int i = 1; i &lt;= L; ++i)        {            for(int j = 1; j &lt;= R; ++j)            {                for(int k = 1; k &lt;= C; ++k)                {                    scanf(&quot;%c&quot;, &amp;m[i][j][k]);                    if(m[i][j][k] == &#39;S&#39;)                    {                        start.x = i;                        start.y = j;                        start.z = k;                        start.step = 0;                    }                    if(m[i][j][k] == &#39;E&#39;)                    {                        over.x = i;                        over.y = j;                        over.z = k;                    }                }                getchar();            }            getchar();        }        bfs(start, over);        ///错了不知怎么错的，加上这两句就过了...        memset(m, 0, sizeof(m));        memset(vis, 0, sizeof(vis));    }    return 0;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 简单搜索のBFS </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my first blog!</title>
      <link href="2019/01/14/my-first-blog/"/>
      <url>2019/01/14/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>第一次用hexo + hithub搞了一篇个人博客，还是蛮激动的！！！</p><p>在这里练习一下markdown语法</p><a id="more"></a><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1310636770&auto=1&height=66"></iframe><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p></blockquote></blockquote></blockquote></blockquote><p><code>cout &lt;&lt; &quot;单行代码&quot; &lt;&lt; &#39;\n&#39;;</code></p><pre><code>```cout &lt;&lt; &quot;多行代码&quot; &lt;&lt; &#39;\n&#39;;return 0;```c</code></pre><div class="table-container"><table><thead><tr><th>name</th><th>relation</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>标签分割线</title>
      <link href="2018/05/22/0%E6%A0%87%E7%AD%BE%E5%88%86%E5%89%B2%E7%BA%BF/"/>
      <url>2018/05/22/0%E6%A0%87%E7%AD%BE%E5%88%86%E5%89%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>点这里没用，点具体的那几项……</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> DP---------------------------- </tag>
            
            <tag> Vue--------------------------- </tag>
            
            <tag> NodeJS--------------------- </tag>
            
            <tag> Web API-------------------- </tag>
            
            <tag> JavaScript------------------ </tag>
            
            <tag> 优化------------------------- </tag>
            
            <tag> 图论-------------------------- </tag>
            
            <tag> 简单搜索--------------------- </tag>
            
            <tag> 字符串----------------------- </tag>
            
            <tag> 技巧------------------------- </tag>
            
            <tag> 数据结构------------------- </tag>
            
            <tag> 数论-------------------------- </tag>
            
            <tag> 网络流----------------------- </tag>
            
            <tag> 二分图----------------------- </tag>
            
            <tag> 最小生成树------------------ </tag>
            
            <tag> 最短路----------------------- </tag>
            
            <tag> 组合数学---------------------- </tag>
            
            <tag> 计算几何---------------------- </tag>
            
            <tag> 连通图----------------------- </tag>
            
            <tag> 基本算法-------------------- </tag>
            
            <tag> 函数-------------------------- </tag>
            
            <tag> 其他语言-------------------- </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异态常态递推</title>
      <link href="2018/05/15/%E5%BC%82%E6%80%81%E5%B8%B8%E6%80%81%E9%80%92%E5%BD%92/"/>
      <url>2018/05/15/%E5%BC%82%E6%80%81%E5%B8%B8%E6%80%81%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><blockquote><p>异态经过 a 个单位时间可变为 常态</p><p>常态经过 b 个单位时间可产生 一个异态</p><p>给出初始值，求第 n 年的数值<code>num[n]=?</code></p></blockquote><a id="more"></a><h1 id="这是一条废贴…"><a href="#这是一条废贴…" class="headerlink" title="这是一条废贴…"></a>这是一条废贴…</h1><blockquote><blockquote><p>还是多写几个强行找规律叭</p></blockquote></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 基本算法の递推 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
